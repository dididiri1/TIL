# Java Comparator, Comparable 정렬 정리

## 📌 Comparator

### ✅ 배열 정렬 기본
- 배열 정렬 시 Arrays.sort(data) 메서드를 사용한다.
#### 🔼 오름차순 정렬 (기본)
``` 
int[] arr = {87, 89, 92, 100, 76};

Arrays.sort(arr);
// [76, 87, 89, 92, 100]
``` 

#### 🔽 내림차순 정렬
- Arrays.sort(data, Collections.reverseOrder()) 사용
- 단, int 같은 Primitive 타입은 사용할 수 없으므로 **Wrapper Class (Integer)** 필요
``` 
public class SortMain {

    public static void main(String[] args) {
        Integer[] arr = {87, 89, 92, 100, 76};
        Arrays.sort(arr, Comparator.reverseOrder());

        System.out.println(Arrays.toString(arr));
        // [100, 92, 89, 87, 76]
    }
}
```
### ✅ 익명 클래스 Comparator
``` 
public class SortMain {

    public static void main(String[] args) {
        Integer[] arr = {87, 89, 92, 100, 76};

        Arrays.sort(arr, new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return o1.compareTo(o2); // 오름차순
            }
        });

        System.out.println(Arrays.toString(arr));
    }
}
``` 
### ✅ 스트림(Stream) 정렬
#### 🔸 익명 클래스 버전
``` 
public class SortMain {

    public static void main(String[] args) {
        int[] arr = {87, 89, 92, 100, 76};
        
        List<Integer> sortArr = Arrays.stream(arr).boxed().sorted(new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return o1.compareTo(o2);
            }
        }).collect(Collectors.toList());
    }
}
``` 
#### 🔸 람다 버전
``` 
public class SortMain {

    public static void main(String[] args) {
        int[] arr = {87, 89, 92, 100, 76};
        
        List<Integer> sortArr = Arrays.stream(arr).boxed().sorted((o1, o2) -> o1.compareTo(o2)).collect(Collectors.toList());
    }
}
``` 
#### 🔸 내림차순 (람다 & Comparator)
``` 
public class SortMain {

    public static void main(String[] args) {
        int[] arr = {87, 89, 92, 100, 76};

        List<Integer> sortArr = Arrays.stream(arr).boxed().sorted(Comparator.reverseOrder()).collect(Collectors.toList());
        
        Integer[] sortedArr2 = Arrays.stream(arr).boxed().toArray(Integer[]::new);
        Arrays.sort(sortedArr2, Comparator.reverseOrder());
    }
}
``` 

### ✅ 사용자 정의 Comparator 클래스
```
import java.util.Arrays;
import java.util.Comparator;

public class SortMain {

    public static void main(String[] args) {
        Integer[] arr = {87, 89, 92, 100, 76};
        Arrays.sort(arr, new MyComparator());

        System.out.println(Arrays.toString(arr));
    }
}

class MyComparator implements Comparator<Integer> {

    @Override
    public int compare(Integer o1, Integer o2) {
        return o2.compareTo(o1);
    }
}
```

### ✅ 1. Comparable 사용 (클래스 내부에 기본 정렬 정의)
- Comparable은 클래스 내부에 고정된 정렬 기준(나이 오름차순)을 넣어둔 것.
```

import java.util.*;

class User implements Comparable<User> {

    private String name;
    private int age;
    private int height;

    public User(String name, int age, int height) {
        this.name = name;
        this.age = age;
        this.height = height;
    }

    @Override
    public int compareTo(User o) {
        if (this.age == o.age) {
            // 나이가 같으면 키 기준 오름차순
            return this.height - o.height;
        } else {
            // 나이 기준 오름차순
            return this.age - o.age;
        }
    }
}

public class SortMain {

    public static void main(String[] args) {
        User user1 = new User("Kim", 20, 180);
        User user2 = new User("Lee", 20, 173);
        User user3 = new User("Park", 18, 168);

        List<User> users = List.of(user1, user2, user3);

        Collections.sort(users); // User의 compareTo() 기준으로 정렬
    }
}
```
#### 결과
```
[User{name='Park', age=18, height=168}, User{name='Lee', age=20, height=173}, User{name='Kim', age=20, height=180}]
```

### ✅ 2. Comparator 사용 (외부에서 정렬 기준 제공)
```
package lambda.ex3;

import java.util.*;

class Customer {

    public String name;
    public int age;

    public Customer(String name, int age) {
        this.name = name;
        this.age = age;
    }
}

public class ComparatorExample {
    public static void main(String[] args) {
        List<Customer> users = new ArrayList<>();
        users.add(new Customer("Kim", 25));
        users.add(new Customer("Lee", 20));
        users.add(new Customer("Park", 30));

        // ✅ 이름 기준 오름차순 정렬
        Collections.sort(users, (o1, o2) -> o1.name.compareTo(o2.name));
        System.out.println(users);
        // [Kim(25), Lee(20), Park(30)]

        // ✅ 나이 기준 내림차순 정렬 (람다 버전)
        users.sort((u1, u2) -> u2.age - u1.age);
        System.out.println(users);
        // [Park(30), Kim(25), Lee(20)]
    }
}
```
- age가 int 기본형이라면 compareTo() 메서드 사용 불가
- compareTo()는 Integer 객체에서만 사용 가능
```
Collections.sort(users, (o1, o2) -> o1.age.compareTo(o2.age));  // ❌ 컴파일 에러 발생
```

### 📌 Comparator vs Comparable
- ✅ Comparable
- 클래스 자체에 정렬 기준을 정의.
- 한 클래스에 하나의 정렬 기준만 고정적으로 가질 수 있음.
- 기본적으로 사용하기 편리하고 Collections.sort() 호출 시 자동 적용.

#### ✅ Comparator
- 외부에서 정렬 기준을 정의.
- 여러 가지 정렬 기준을 자유롭게 제공할 수 있어 유연성 높음.
- 익명 클래스, 람다, 메서드 레퍼런스로 쉽게 구현 가능.

#### ✅ 언제 어떤 걸 써야 할까?
- 클래스에 디폴트(기본) 정렬 방식이 필요하다면 → Comparable
- 상황에 따라 여러 정렬 기준을 적용해야 한다면 → Comparator

#### 💡 권장 패턴:
- 클래스 내부에 Comparable 구현 → 기본 정렬 정의
- 외부에서 Comparator를 사용 → 필요할 때 정렬 기준 변경

> 📌 핵심 요약 
> Arrays.sort() → 오름차순 기본  
> Arrays.sort(arr, Comparator.reverseOrder()) → 내림차순 (Integer[] 필요)  
> Comparator.reverseOrder()는 (o1, o2) -> o2.compareTo(o1) 람다와 동일  
> Stream 사용 시 sorted()에 익명 클래스나 람다로 Comparator 전달 가능  
