# 섹션 13. 병렬 스트림

## 단일 스트림
자바 병렬 스트림을 제대로 이해하려면, 우리가 앞서 학습한 스트림은 물론이고, 멀티스레드, Fork/Join 프레임워크에 대한 기본 지식이 필요하다.
멀티스레드에 대한 부분은 **김영한의 실전 자바 고급 1편** 강의를 참고하자.
여기서는 단일 스트림부터 시작해서 멀티스레드, 스레드 풀, Fork/Join 프레임워크, 그리고 자바 병렬 스트림으로 이어지는 전체 과정을 예제를 통해 
점진적으로 설명하겠다.

### 병렬 스트림 준비 예제
병렬 스트림을 학습하기 전에 먼저 로깅 유틸리티와 무거운 작업을 시뮬레이션하는 클래스를 준비하자.
```
package util;

import java.time.LocalTime;
import java.time.format.DateTimeFormatter;

public abstract class MyLogger {

    private static final DateTimeFormatter formatter =
            DateTimeFormatter.ofPattern("HH:mm:ss.SSS");

    public static void log(Object obj) {
        String time = LocalTime.now().format(formatter);
        System.out.printf("%s [%9s] %s\n", time, Thread.currentThread().getName(), obj);
    }
}
```
- MyLogger 클래스는 현재 시간, 스레드 이름, 그리고 전달받은 객체를 로그로 출력한다. 이 클래스를 사용하면 어떤 스레드에서 어떤 작업이 실행되는지 
  시간과 함께 확인할 수 있다.

```
package parallel;

import util.MyLogger;
import java.util.concurrent.ForkJoinPool;

public class HeavyJob {

    public static int heavyTask(int i) {
        MyLogger.log("calculate " + i + " -> " + i * 10);
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        return i * 10;
    }

    public static int heavyTask(int i, String name) {
        MyLogger.log("[" + name + "] " + i + " -> " + i * 10);
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        return i * 10;
    }
}
```
- HeavyJob 클래스는 오래 걸리는 작업을 시뮬레이션하는데, 각 작업은 1초 정도 소요된다고 가정하겠다. 입력값에 10을 곱한 결과를 반환하며, 
  작업이 실행될 때마다 로그를 출력한다.
- 추가로 로그를 찍어서 어느 스레드가 이 작업을 처리 중인지 확인할 수 있다.

### 예제1 - 단일 스트림
- 먼저 **단일 스트림**(sequential stream)으로 IntStream.rangeClosed(1, 8) 에서 나온 1부터 8까지의 숫자 각각에 대해 heavyTask() 를 
  순서대로 수행해보자.
```
package parallel;

import java.util.stream.IntStream;
import static util.MyLogger.log;

public class ParallelMain1 {

    public static void main(String[] args) {
        long startTime = System.currentTimeMillis();

        int sum = IntStream.rangeClosed(1, 8)
                .map(HeavyJob::heavyTask)
                .reduce(0, (a, b) -> a + b); // sum()

        long endTime = System.currentTimeMillis();
        log("time: " + (endTime - startTime) + "ms, sum: " + sum);
    }
}
```
- map(HeavyJob::heavyTask) 로 1초씩 걸리는 작업을 8번 순차로 호출하므로, 약 8초가 소요된다.
- 마지막에 reduce(0, (a, b) -> a + b) , 또는 sum() 으로 최종 결과를 합산한다.
- 결과적으로 **단일 스레드**(main 스레드)에서 작업을 순차적으로 수행하기 때문에 로그에도 [main] 스레드만 표시된다.

#### 실행 결과
```
15:27:03.155 [ main] calculate 1 -> 10
15:27:04.162 [ main] calculate 2 -> 20
15:27:05.164 [ main] calculate 3 -> 30
15:27:06.170 [ main] calculate 4 -> 40
15:27:07.175 [ main] calculate 5 -> 50
15:27:08.181 [ main] calculate 6 -> 60
15:27:09.186 [ main] calculate 7 -> 70
15:27:10.192 [ main] calculate 8 -> 80
15:27:11.201 [ main] time: 8067ms, sum: 360
```
- 실제 출력 로그를 보면 calculate 1 -> 10 , calculate 2 -> 20 , …, calculate 8 -> 80 등이 순서대로 찍힌다.
- 전체 시간이 8초 정도 걸리는 것을 확인할 수 있다.

8초는 너무 오래 걸린다. 스레드를 사용해서 실행 시간을 단축해보자.

## 스레드 직접 사용
앞서 하나의 메인 스레드로 1 ~ 8 의 범위를 모두 계산했다.
이제 여러 스레드를 동시에 사용해서 작업을 더 빨리 처리해보자.
각 스레드는 한 번에 하나의 작업만 처리할 수 있다. 따라서 1 ~ 8 을 처리하는 큰 단위의 작업을 더 작은 단위의 작업으로 분할해야 한다.
여기서는 1 ~ 8 의 큰 작업을 1 ~ 4 , 5 ~ 8 과 같이 절반으로 분할해서 두 개의 스레드로 처리해보자.

### 예제2 - 스레드 직접 사용
```
package parallel;

import static util.MyLogger.log;

public class ParallelMain2 {

    public static void main(String[] args) throws InterruptedException {
        long startTime = System.currentTimeMillis();

        // 1. Fork 작업을 분할한다.
        SumTask task1 = new SumTask(1, 4);
        SumTask task2 = new SumTask(5, 8);

        Thread thread1 = new Thread(task1, "thread-1");
        Thread thread2 = new Thread(task2, "thread-2");

        // 2. 분할한 작업을 처리한다.
        thread1.start();
        thread2.start();

        // 3. join - 처리한 결과를 합친다.
        thread1.join();
        thread2.join();
        log("main 스레드 대기 완료");

        int sum = task1.result + task2.result;

        long endTime = System.currentTimeMillis();
        log("time: " + (endTime - startTime) + "ms, sum: " + sum);
    }

    static class SumTask implements Runnable {
        int startValue;
        int endValue;
        int result = 0;

        public SumTask(int startValue, int endValue) {
            this.startValue = startValue;
            this.endValue = endValue;
        }

        @Override
        public void run() {
            log("작업 시작");
            int sum = 0;
            for (int i = startValue; i <= endValue; i++) {
                int calculated = HeavyJob.heavyTask(i);
                sum += calculated;
            }
            result = sum;
            log("작업 완료 result=" + result);
        }
    }
}
```
- SumTask 는 Runnable 을 구현했고, 내부에서 1초씩 걸리는 heavyTask() 를 루프 돌면서 합산한다.
- new SumTask(1, 4) , new SumTask(5, 8) 을 통해 작업을 두 개로 분할한다.
- thread1.start() , thread2.start() 로 각 스레드가 동시에 작업을 시작하고, thread1.join(), thread2.join() 으로 두 스레드가 
  끝날 때까지 main 스레드가 대기한다.
- 작업 완료 후, task1 , task2 의 결과를 더해서 최종 합계( sum )를 구한다.

#### 실행 결과
```
15:29:27.018 [ thread-1] 작업 시작
15:29:27.018 [ thread-2] 작업 시작
15:29:27.024 [ thread-1] calculate 1 -> 10
15:29:27.024 [ thread-2] calculate 5 -> 50
15:29:28.025 [ thread-2] calculate 6 -> 60
15:29:28.029 [ thread-1] calculate 2 -> 20
15:29:29.030 [ thread-2] calculate 7 -> 70
15:29:29.032 [ thread-1] calculate 3 -> 30
15:29:30.036 [ thread-2] calculate 8 -> 80
15:29:30.036 [ thread-1] calculate 4 -> 40
15:29:31.043 [ thread-1] 작업 완료 result=100
15:29:31.043 [ thread-2] 작업 완료 result=260
15:29:31.043 [ main] main 스레드 대기 완료
15:29:31.047 [ main] time: 4042ms, sum: 360
```
- thread-1 , thread-2 가 작업을 분할해서 처리했기 때문에 8초의 작업을 4초로 줄일 수 있었다.
- 하지만 이렇게 스레드를 직접 사용하면 스레드 수가 늘어나면 코드가 복잡해지고, 예외 처리, 스레드 풀 관리 등 추가 관리 포인트가 생기는 문제가 있다.

## 스레드 풀 사용
이번에는 자바가 제공하는 ExecutorService 를 사용해서 더 편리하게 병렬 처리를 해보자.
> 참고: 스레드 풀 관련해서는 김영한의 실전 자바 고급 1편 - 멀티스레드와 동시성 강의의 스레드 풀과 Executor 프레임워크1, 2를 참고하자.

### 예제3 - 스레드 풀
```
package parallel;

import java.util.concurrent.*;

import static util.MyLogger.log;

public class ParallelMain3 {

    public static void main(String[] args) throws InterruptedException, ExecutionException {
        // 스레드 풀을 준비한다.
        ExecutorService es = Executors.newFixedThreadPool(2);

        long startTime = System.currentTimeMillis();

        // 1. 작업을 분할한다.
        SumTask task1 = new SumTask(1, 4);
        SumTask task2 = new SumTask(5, 8);

        // 2. 분할한 작업을 처리한다.
        Future<Integer> future1 = es.submit(task1);
        Future<Integer> future2 = es.submit(task2);

        // 3. join - 처리한 결과를 합친다. get: 결과가 나올 때까지 대기한다.
        Integer result1 = future1.get();
        Integer result2 = future2.get();
        int sum = result1 + result2;

        long endTime = System.currentTimeMillis();
        log("time: " + (endTime - startTime) + "ms, sum: " + sum);

        es.close();
    }

    static class SumTask implements Callable<Integer> {
        int startValue;
        int endValue;

        public SumTask(int startValue, int endValue) {
            this.startValue = startValue;
            this.endValue = endValue;
        }

        @Override
        public Integer call() {
            log("작업 시작");
            int sum = 0;
            for (int i = startValue; i <= endValue; i++) {
                int calculated = HeavyJob.heavyTask(i);
                sum += calculated;
            }
            log("작업 완료 result=" + sum);
            return sum;
        }
    }
}
```
- Executors.newFixedThreadPool(2) 로 스레드 풀을 만든다. 이 스레드 풀은 최대 2개의 스레드를 제공한다.
- new SumTask(1, 4) , new SumTask(5, 8) 을 통해 작업을 두 개로 분할한다.
- submit(Callable) 로 스레드 풀에 작업을 맡기면 Future 객체를 반환 받는다.
- 메인 스레드는 future.get() 을 통해 실제 계산 결과가 반환될 때까지 대기(join 과 유사)한다.

이 예제는 스레드 풀과 Future 을 사용해서 결과값을 반환받는 방식으로 구현되었다. 작업이 완료되면 Future의 get() 메서드를 통해 결과를 얻는다. 
참고로 get() 메서드는 블로킹 메서드이다. 이전 예제와 마찬가지로 2개의 스레드가 병렬로 계산을 처리하므로 약 4초가 소요된다.

#### 실행 결과
```
15:31:19.238 [pool-1-thread-1] 작업 시작
15:31:19.238 [pool-1-thread-2] 작업 시작
15:31:19.244 [pool-1-thread-1] calculate 1 -> 10
15:31:19.244 [pool-1-thread-2] calculate 5 -> 50
15:31:20.247 [pool-1-thread-1] calculate 2 -> 20
15:31:20.247 [pool-1-thread-2] calculate 6 -> 60
15:31:21.248 [pool-1-thread-2] calculate 7 -> 70
15:31:21.253 [pool-1-thread-1] calculate 3 -> 30
15:31:22.252 [pool-1-thread-2] calculate 8 -> 80
15:31:22.258 [pool-1-thread-1] calculate 4 -> 40
15:31:23.258 [pool-1-thread-2] 작업 완료 result=260
15:31:23.258 [pool-1-thread-1] 작업 완료 result=100
15:31:23.270 [ main] time: 4040ms, sum: 360
```
- 이전 예제처럼 스레드가 2개이므로 각각 4개씩 나눠 처리한다.
- Future 로 반환값을 쉽게 받아올 수 있기 때문에, 결과값을 합산하는 과정이 더 편리해졌다.
- 하지만 여전히 코드 레벨에서 분할/병합 로직을 직접 짜야 하고, 스레드 풀 생성과 관리도 개발자가 직접해야 한다.

## Fork/Join 패턴
### 분할(Fork), 처리(Execute), 모음(Join)
스레드는 한 번에 하나의 작업을 처리할 수 있다. 따라서 하나의 큰 작업을 여러 스레드가 처리할 수 있는 작은 단위의 작업으로 분할(Fork)해야 한다.
그리고 이렇게 분할한 작업을 각각의 스레드가 처리(Execute)하는 것이다. 각 스레드의 분할된 작업 처리가 끝나면 분할된 결과를 하나로 모아야(Join) 한다.
이렇게 **분할(Fork) 처리(Execute) 모음(Join)** 의 단계로 이루어진 멀티스레딩 패턴을 **Fork/Join 패턴**이라고 부른다.
이 패턴은 병렬 프로그래밍에서 매우 효율적인 방식으로, 복잡한 작업을 병렬적으로 처리할 수 있게 해준다.

지금까지 우리는 이런 과정을 다음과 같이 직접 처리했다. 우리가 진행했던 예제를 그림과 함께 다시 정리해보자.

![](https://github.com/dididiri1/TIL/blob/main/Java/ractical/images/13_01.png?raw=true)

#### 1. 작업 분할(Fork)
1 ~ 8 분할
- 1 ~ 4 : thread-1 처리
- 5 ~ 8 : thread-2 처리

1 ~ 8 의 작업을 절반으로 분할하자. 그래서 1 ~ 4 의 작업은 thread-1 이 처리하고, 5 ~ 8 의 작업은 thread-2 가 처리하는 것이다.
이렇게 하면 작업의 수를 늘려서 여러 스레드가 동시에 많은 작업을 처리할 수 있다.
예제에서는 하나의 스레드가 처리하던 작업을 두 개의 스레드가 처리하므로 처리 속도를 최대 2배로 늘릴 수 있다.

이렇게 큰 작업을 여러 작은 작업으로 쪼개어(Fork) 각각의 스레드나 작업 단위로 할당하는 것을 포크(Fork)라 한다.
참고로 포크라는 이름은 식당에서 사용하는 포크가 여러 갈래로 나뉘어 있는 모양을 떠올려보면 된다. 이처럼 하나의 큰 작업을 여러 작은 작업으로 분할하는 
것을 포크라 한다.

#### 2. 처리(Execute)
- 1 ~ 4 처리( thread-1 )
  - 1 10
  - 2 20
  - 3 30
  - 4 40
  - 결과: 10 + 20 + 30 + 40 = 100
- 5 ~ 8 처리( thread-2 )
  - 5 50
  - 6 60
  - 7 70
  - 8 80
  - 결과: 50 + 60 + 70 + 80 = 260

thread-1 , thread-2 는 분할된 각각의 작업을 처리한다.

#### 3. Join 모음, 결과 합치기
분할된 작업들이 모두 끝나면, 각 스레드 혹은 작업 단위별 결과를 **하나로 합쳐야한다.**
예제에서는 thread1.join() , thread2.join() 을 통해 모든 스레드가 종료되길 기다린 뒤, task1.result + task2.result 로 최종 결과를 계산한다.
Join은 이렇게 갈라진 작업들이 모두 끝난 뒤, 다시 **합류**하여 하나로 **결과를 모으는** 모습을 의미한다.

#### 정리
지금까지 작업을 직접 분할하고, 처리하고, 처리된 결과를 합쳤다.
이러한 분할 -> 처리(작업 병렬 실행) -> 모음의 과정을 더 편리하게 구현할 수 있는 방법은 없을까?
자바는 **Fork/Join** 프레임워크를 제공해서 개발자가 이러한 패턴을 더 쉽게 구현할 수 있도록 지원한다.

## Fork/Join 프레임워크1 - 소개
### Fork/Join 프레임워크 소개
자바의 Fork/Join 프레임워크는 자바 7부터 도입된 java.util.concurrent 패키지의 일부로, 멀티코어 프로세서를 효율적으로 활용하기 위한 병렬 
처리 프레임워크이다. 주요 개념은 다음과 같다.

#### 분할 정복(Divide and Conquer) 전략
- 큰 작업(task)을 작은 단위로 재귀적으로 분할(fork)
- 각 작은 작업의 결과를 합쳐(join) 최종 결과를 생성
- 멀티코어 환경에서 작업을 효율적으로 분산 처리

#### 작업 훔치기(Work Stealing) 알고리즘
- 각 스레드는 자신의 작업 큐를 가짐
- 작업이 없는 스레드는 다른 바쁜 스레드의 큐에서 작업을 "훔쳐와서" 대신 처리
- 부하 균형을 자동으로 조절하여 효율성 향상

### 주요 클래스
Fork/Join 프레임워크를 이루는 주요 클래스는 다음과 같다.
- ForkJoinPool
- ForkJoinTask
  - RecursiveTask
  - RecursiveAction

#### ForkJoinPool
- Fork/Join 작업을 실행하는 특수한 ExecutorService 스레드 풀
- 작업 스케줄링 및 스레드 관리를 담당
- 기본적으로 사용 가능한 프로세서 수 만큼 스레드 생성
  - 예) CPU 코어가 10 코어면 10개의 스레드 생성
- 쉽게 이야기해서 **분할 정복과 작업 훔치기에 특화된 스레드 풀**이다.

```
// 기본 풀 생성 (프로세서 수에 맞춰 스레드 생성)
ForkJoinPool pool = new ForkJoinPool();

// 특정 병렬 수준으로 풀 생성
ForkJoinPool customPool = new ForkJoinPool(4);
```
#### ForkJoinTask
- ForkJoinTask 는 Fork/Join 작업의 기본 추상 클래스다.
- Future 를 구현했다.
- 개발자는 주로 다음 두 하위 클래스를 구현해서 사용한다.
  - RecursiveTask<V> : 결과를 반환하는 작업
  - RecursiveAction : 결과를 반환하지 않는 작업(void)
  
####  RecursiveTask / RecursiveAction의 구현 방법
- compute() 메서드를 재정의해서 필요한 작업 로직을 작성한다.
- 일반적으로 일정 기준(임계값)을 두고, **작업 범위가 작으면 직접 처리**하고, **크면 작업을 둘로 분할**하여 각각 병렬로 처리하도록 구현한다.

#### fork() / join() 메서드
- fork() : 현재 스레드에서 다른 스레드로 작업을 **분할**하여 보내는 동작(비동기 실행)
- join() : 분할된 작업이 끝날 때까지 기다린 후 결과를 가져오는 동작

> 참고: Fork/Join 프레임워크를 실무에서 직접적으로 다루는 일은 드물다. 따라서 이런게 있다 정도만 알아두고 넘어가자.  
> 개념 정도만 대략 알아두면 충분하다.

### Fork/Join 프레임워크 활용
실제 Fork/Join 프레임워크를 사용해서 우리가 앞서 처리한 예시를 개발해보자.
기본적인 처리 방식은 다음과 같다.

![](https://github.com/dididiri1/TIL/blob/main/Java/ractical/images/13_02.png?raw=true)

핵심은 작업의 크기가 임계값 보다 크면 분할하고, 임계값 보다 같거나 작으면 직접 처리하는 것이다.
예를 들어 작업의 크기가 8이고, 임계값이 4라고 가정해보자.
1. **Fork**: 작업의 크기가 8이면 임계값을 넘었다. 따라서 작업을 절반으로 분할한다.
2. **Execute**: 다음으로 작업의 크기가 4라면 임계값의 범위 안에 들어오므로 작업을 분할하지 않고, 처리한다.
3. **Join**: 최종 결과를 합친다.

Fork/Join 프레임워크를 사용하려면 RecursiveTask.compute() 메서드를 재정의해야 한다.
다음에 작성한 SumTask 는 RecursiveTask<Integer> 를 상속받아 리스트의 합을 계산하는 작업을 병렬로 처리
하는 클래스이다. 이 클래스는 Fork/Join 프레임워크의 **분할 정복** 전략을 구현한다.
```
package parallel.forkjoin;

import parallel.HeavyJob;

import java.util.List;
import java.util.concurrent.RecursiveTask;

import static util.MyLogger.log;

public class SumTask extends RecursiveTask<Integer> {

    private static final int THRESHOLD = 4; // 임계값
    private final List<Integer> list;

    public SumTask(List<Integer> list) {
        this.list = list;
    }

    @Override
    protected Integer compute() {
        // 작업 범위가 작으면 직접 합산
        if (list.size() <= THRESHOLD) {
            log("[처리 시작] " + list);
            int sum = list.stream()
                    .mapToInt(HeavyJob::heavyTask)
                    .sum();
            log("[처리 완료] " + list + " -> sum: " + sum);
            return sum;
        } else {
            // 작업 범위가 크면 반으로 나누어 병렬 처리
            int mid = list.size() / 2;
            List<Integer> leftList = list.subList(0, mid);
            List<Integer> rightList = list.subList(mid, list.size());
            log("[분할] " + list + " -> LEFT" + leftList + ", RIGHT" + rightList);

            SumTask leftTask = new SumTask(leftList);
            SumTask rightTask = new SumTask(rightList);

            // 왼쪽 작업은 다른 스레드에서 처리
            leftTask.fork();
            // 오른쪽 작업은 현재 스레드에서 처리
            int rightResult = rightTask.compute();
            // 왼쪽 작업 결과를 기다림
            int leftResult = leftTask.join();

            // 왼쪽과 오른쪽 작업 결과를 합침
            int joinSum = leftResult + rightResult;
            log("LEFT[" + leftResult + "] + RIGHT[" + rightResult + "] -> sum: " + joinSum);
            return joinSum;
        }
    }
}
```
- **THRESHOLD (임계값)**: 작업을 더 이상 분할하지 않고 직접 처리할 리스트의 크기를 정의한다. 여기서는 4로 설정되어, 리스트 크기가 4 이하일 때 
  직접 계산한다. 4보다 크면 작업을 분할한다.
- **작업 분할**: 리스트의 크기가 임계값보다 크면, 리스트를 반으로 나누어 leftList 와 rightList 로 분할한다.
- **fork(), compute()**
  - fork() 는 왼쪽 작업을 다른 스레드에 위임하여 병렬로 처리한다.
  - compute() 는 오른쪽 작업을 현재 스레드에서 직접 수행한다(재귀 호출).
- **join()**: 분할된 왼쪽 작업이 완료될 때까지 기다린 후 결과를 가져온다.
- **결과 합산**: 왼쪽과 오른쪽 결과를 합쳐 최종 결과를 반환한다.

이렇게 구현한 코드를 실제 실행해보자.
```
package parallel.forkjoin;

import java.util.List;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ForkJoinPool;
import java.util.stream.IntStream;

import static util.MyLogger.log;

public class ForkJoinMain1 {

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        List<Integer> data = IntStream.rangeClosed(1, 8)
                .boxed()
                .toList();
        log("[생성] " + data);

        // ForkJoinPool 생성 및 작업 수행
        ForkJoinPool pool = new ForkJoinPool(10);
        long startTime = System.currentTimeMillis();

        SumTask task = new SumTask(data);
        // 병렬로 합을 구한 후 결과 출력
        int result = pool.invoke(task);

        pool.close();

        long endTime = System.currentTimeMillis();
        log("time: " + (endTime - startTime) + "ms, sum: " + result);
        log("pool: " + pool);
    }
}
```
1. **데이터 생성**: IntStream.rangeClosed(1, 8) 를 사용해 1부터 8까지의 숫자 리스트를 생성한다.
2. **ForkJoinPool 생성:**
- new ForkJoinPool(10) 으로 최대 10개의 스레드를 사용할 수 있는 풀을 생성한다.
- 참고로 기본 생성자( new ForkJoinPool() )를 사용하면 시스템의 프로세서 수에 맞춰 스레드가 생성된다.
3. **invoke()**: 메인 스레드가 pool.invoke(task) 를 호출하면 SumTask 를 스레드 풀에 전달한다. SumTask는 ForkJoinPool 에 
  있는 별도의 스레드에서 실행된다. 메인 스레드는 작업이 완료될 때까지 기다린 후 결과 를 받는다.
4. **pool.close()**: 더 이상 작업이 없으므로 풀을 종료한다.
5. **결과 출력**: 계산된 리스트의 합과 실행 시간을 출력한다.

#### 실행 결과
```
15:15:15.919 [ main] [생성] [1, 2, 3, 4, 5, 6, 7, 8]
15:15:15.928 [ForkJoinPool-1-worker-1] [분할] [1, 2, 3, 4, 5, 6, 7, 8] -> 
LEFT[1, 2, 3, 4], RIGHT[5, 6, 7, 8]
15:15:15.929 [ForkJoinPool-1-worker-1] [처리 시작] [5, 6, 7, 8]
15:15:15.929 [ForkJoinPool-1-worker-2] [처리 시작] [1, 2, 3, 4]
15:15:15.932 [ForkJoinPool-1-worker-1] calculate 5 -> 50
15:15:15.932 [ForkJoinPool-1-worker-2] calculate 1 -> 10
15:15:16.936 [ForkJoinPool-1-worker-1] calculate 6 -> 60
15:15:16.936 [ForkJoinPool-1-worker-2] calculate 2 -> 20
15:15:17.941 [ForkJoinPool-1-worker-1] calculate 7 -> 70
15:15:17.941 [ForkJoinPool-1-worker-2] calculate 3 -> 30
15:15:18.946 [ForkJoinPool-1-worker-1] calculate 8 -> 80
15:15:18.946 [ForkJoinPool-1-worker-2] calculate 4 -> 40
15:15:19.955 [ForkJoinPool-1-worker-1] [처리 완료] [5, 6, 7, 8] -> sum: 260
15:15:19.955 [ForkJoinPool-1-worker-2] [처리 완료] [1, 2, 3, 4] -> sum: 100
15:15:19.960 [ForkJoinPool-1-worker-1] LEFT[100] + RIGHT[260] -> sum: 360
15:24:02.152 [ main] time: 4040ms, sum: 360
15:24:02.153 [ main] pool: 
java.util.concurrent.ForkJoinPool@57baeedf[Terminated, parallelism = 10, size 
= 0, active = 0, running = 0, steals = 2, tasks = 0, submissions = 0]
```
작업이 2개로 분할 되어서 총 4초의 시간이 걸린 것을 확인할 수 있다.

![](https://github.com/dididiri1/TIL/blob/main/Java/ractical/images/13_03.png?raw=true)
#### 작업 시작
1. main 스레드가 invoke(task) 를 호출해서
2. ForkJoinPool 에 작업을 요청
3. 스레드 풀은 스레드를 꺼내서 작업을 실행 여기서는 ForkJoinPool-1-worker-1 스레드가 실행됨, 줄여서 w1 이라고 표현하겠음
4. w1 스레드는 task(SumTask) 의 compute() 를 호출함

#### 작업 분할
```
[w1] [분할] [1, 2, 3, 4, 5, 6, 7, 8] -> LEFT[1, 2, 3, 4], RIGHT[5, 6, 7, 8]
```
5. 리스트 크기가 THRESHOLD(4) 보다 크므로 분할됨.
  - [1,2,3,4,5,6,7,8] 이 LEFT[1,2,3,4] 와 RIGHT[5,6,7,8] 로 나뉨.
6. w1 은 분할한 왼쪽 리스트인 LEFT[1,2,3,4] 는 fork(leftTask) 를 호출해서 다른 스레드가 작업을 처리하도록 요청함
7. w1 은 분할할 오른쪽 리스트인 RIGHT[5,6,7,8] 는 자기 자신의 메서드인 compute(rightTask) 를 호출해서 자기 자신이 스스로 처리함 (재귀 호출)

#### 병렬 처리
- 각 스레드가 동시에 HeavyJob.heavyTask()를 실행하며 병렬로 계산.
  - 8. w1 스레드가 [5,6,7,8] 을 순서대로 처리, SUM: 260 (리스트 크기가 THRESHOLD(4) 이하)
  - A-1. w2 스레드가 [1,2,3,4] 를 순서대로 처리, SUM: 100 (리스트 크기가 THRESHOLD(4) 이하)
- [1,2,3,4] 작업의 합은 100, [5,6,7,8] 의 작업의 합은 260

#### 작업 완료:
9. 최종 결과의 합을 구하기 위해 w1 스레드는 w2 스레드의 작업에 join() 메서드를 호출해서 w2 의 결과를 기
   다림
10. 두 결과가 합쳐져 최종 합계 360이 계산됨

#### 정리
- Fork/Join 프레임워크를 사용하면 RecursiveTask 를 통해 작업을 재귀적으로 분할하는 것을 확인할 수 있다. 
  여기서는 작업을 단순히 2개로만 분할해서 스레드도 동시에 2개만 사용할 수 있었다.
- THRESHOLD (임계값)을 더 줄여서 작업을 더 잘게 분할하면 더 많은 스레드를 활용할 수 있다. 물론 이 경우 풀의 스레드 수도 2개보다 더 
  많아야 효과가 있다.

#### 참고 - 작업 훔치기
- 이번 그림은 단순하게 설명하게 위해 작업 훔치기는 생략했다.
- 실제로는 Fork/Join 풀의 스레드는 각자 자신의 작업 큐를 가진다. 그리고 자신의 작업이 없는 경우 다른 스레드에 대기중인 작업을 훔쳐서 대신 
  처리할 수 있다. 이 부분은 다음에 설명한다.


