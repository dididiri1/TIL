# 섹션 10. 스트림 API - 컬렉터

## 컬렉터1

스트림이 중간 연산을 거쳐 최종 연산으로써 데이터를 처리할 때, 그 결과물이 필요한 경우가 많다.   
대표적으로 "리스트나 맵 같은 자료 구조에 담고 싶다"거나"통계 데이터를 내고 싶다"는 식의 요구가 있을 때,   
이 최종 연산에 Collectors 를 활용한다.

collect 연산(예: stream.collect(...) )은 반환값을 만들어내는 최종 연산이다. collect(Collector<? super T, A, R> collector) 
형태를 주로 사용하고, Collectors 클래스 안에 준비된 여러 메서드를 통해서 다양한 수집 방식을 적용할 수 있다.

**참고**: 필요한 대부분의 기능이 Collectors 에 이미 구현되어 있기 때문에, Collector 인터페이스를 직접 구현하는 것보다는 Collectors 의   
사용법을 익히는 것이 중요하다.

### Collectors의 주요 기능 표 정리
다음 표는 Collectors 에서 자주 쓰이는 메서드와 그 설명을 간단히 정리한 것이다.

| 분류        | 메서드 예시                                                                 | 설명                                                                                                   | 반환 타입                   |
|-------------|----------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------|-----------------------------|
| **List로 수집** | `toList()`, `toUnmodifiableList()`                                           | 스트림 요소를 `List`로 모은다. `toUnmodifiableList()`는 **불변 리스트**를 만든다.                        | `List<T>`                  |
| **Set으로 수집** | `toSet()`, `toCollection(HashSet::new)`                                    | 스트림 요소를 `Set`으로 모은다. 중복 요소는 제거된다. 특정 `Set` 타입으로 모으려면 `toCollection()` 사용. | `Set<T>`                   |
| **Map으로 수집** | `toMap(keyMapper, valueMapper)`,<br>`toMap(keyMapper, valueMapper, mergeFunction, mapSupplier)` | 스트림 요소를 `(키, 값)` 형태로 수집. 중복 키 발생 시 `mergeFunction`으로 해결, `mapSupplier`로 맵 타입 지정 가능. | `Map<K, V>`                |
| **그룹화**      | `groupingBy(classifier)`,<br>`groupingBy(classifier, downstreamCollector)` | 기준 함수(`classifier`)에 따라 그룹화. 각 그룹에 대해 추가 Collector 적용 가능.                          | `Map<K, List<T>>` 또는 `Map<K, R>` |
| **분할**       | `partitioningBy(predicate)`,<br>`partitioningBy(predicate, downstreamCollector)` | `predicate` 결과(`true/false`)에 따라 두 그룹으로 분할.                                                 | `Map<Boolean, List<T>>` 또는 `Map<Boolean, R>` |
| **통계**       | `counting()`, `summingInt()`, `averagingInt()`,<br>`summarizingInt()` 등     | 요소 개수, 합계, 평균, 최소, 최대값 등을 구하거나 `IntSummaryStatistics` 같은 통계 객체 생성 가능.           | `Long`, `Integer`, `Double`, `IntSummaryStatistics` 등 |
| **리듀싱**      | `reducing(...)`                                                            | `reduce()`와 유사. Collector 환경에서 요소를 하나로 합치는 연산 가능.                                     | `Optional<T>` 또는 다른 타입 |
| **문자열 연결**  | `joining(delimiter, prefix, suffix)`                                      | 문자열 스트림을 연결. 구분자(`delimiter`), 접두사(`prefix`), 접미사(`suffix`) 지정 가능.                   | `String`                   |
| **매핑**       | `mapping(mapper, downstream)`                                             | 각 요소를 변환(`mapper`) 후 다운스트림 Collector로 전달.                                                  | 다운스트림 결과 타입에 따름      |

### 가장 기본적인 수집 예시
```
package stream.collectors;

import java.util.List;
import java.util.Set;
import java.util.TreeSet;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class Collectors1Basic {
    public static void main(String[] args) {
        // 기본 기능
        List<String> list = Stream.of("Java", "Spring", "JPA")
                .collect(Collectors.toList()); // 수정 가능 리스트 반환
        System.out.println("list = " + list);

        // 수정 불가능 리스트
        List<Integer> unmodifiableList = Stream.of(1, 2, 3)
                .collect(Collectors.toUnmodifiableList());
        // unmodifiableList.add(4); // 런타임 예외
        System.out.println("unmodifiableList = " + unmodifiableList);

        Set<Integer> set = Stream.of(1, 2, 2, 3, 3, 3)
                .collect(Collectors.toSet());
        System.out.println("set = " + set);

        // 타입 지정
        Set<Integer> treeSet = Stream.of(3, 4, 5, 2, 1)
                .collect(Collectors.toCollection(TreeSet::new));
        System.out.println("treeSet = " + treeSet); // TreeSet은 정렬 상태를 유지
    }
}
```
#### 실행 결과
```
list = [Java, Spring, JPA]
unmodifiableList = [1, 2, 3]
set = [1, 2, 3]
treeSet = [1, 2, 3, 4, 5]
```
이 예시에서는 스트림을 다양한 컬렉션으로 수집하는 방법을 보여준다.
- toList() 는 수정 가능한 ArrayList 로 수집한다.
- toUnmodifiableList() 는 자바 10부터 제공하는 불변 리스트를 만들어서 수정할 수 없다.
- toSet() 은 중복을 제거한 채로 Set에 수집한다.
- toCollection(TreeSet::new) 처럼 toCollection() 을 사용하면 원하는 컬렉션 구현체를 직접 지정할 수 있다.  
  예제에서는 TreeSet 을 선택해 정렬 상태를 유지하게 했다.

**참고**: Collectors.toList() 대신에 자바 16 부터는 stream.toList() 를 바로 호출할 수 있다. 이 기능은 불변 리스트를 제공한다.

**참고: Collectors를 사용할 때는 static import 사용을 추천한다.**

### Map 수집
```
package stream.collectors;

import java.util.LinkedHashMap;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class Collectors2Map {
    public static void main(String[] args) {
        Map<String, Integer> map1 = Stream.of("Apple", "Banana", "Tomato")
                .collect(Collectors.toMap(
                        name -> name,        // keyMapper
                        name -> name.length() // valueMapper
                ));
        System.out.println("map1 = " + map1);

        // 키 중복 예외: java.lang.IllegalStateException: Duplicate key
        /*
        Map<String, Integer> map2 = Stream.of("Apple", "Apple", "Banana")
                .collect(Collectors.toMap(
                        name -> name, 
                        name -> name.length()
                ));
        System.out.println("map2 = " + map2);
        */

        // 키 중복 대안 (병합)
        Map<String, Integer> map3 = Stream.of("Apple", "Apple", "Banana")
                .collect(Collectors.toMap(
                        name -> name,
                        name -> name.length(),
                        (oldVal, newVal) -> oldVal + newVal // 중복될 경우 기존 값 + 새 값
                ));
        System.out.println("map3 = " + map3);

        // Map의 타입 지정
        LinkedHashMap<String, Integer> map4 = Stream.of("Apple", "Apple", "Banana")
                .collect(Collectors.toMap(
                        name -> name,
                        String::length,
                        (oldVal, newVal) -> oldVal + newVal, // key 중복 발생 시 조정 로직
                        LinkedHashMap::new // 결과 Map 타입 지정
                ));
        System.out.println("map4 = " + map4.getClass());
    }
}
```
#### 실행 결과
```
map1 = {Apple=5, Tomato=6, Banana=6}
map3 = {Apple=10, Banana=6}
map4 = class java.util.LinkedHashMap
```
- toMap(keyMapper, valueMapper) : 각 요소에 대한 키, 값을 지정해서 Map 을 만든다.
- 키가 중복되면 IllegalStateException 이 발생한다(주석 해제 시 map2 예제).
- (oldVal, newVal) -> oldVal + newVal 같은 병합 함수를 지정하면, 중복 키가 나오더라도 기존 값과 새 값을 합쳐서 처리한다.
- 마지막 인자로 LinkedHashMap::new를 넘기면, 결과를 LinkedHashMap으로 얻을 수 있다(입력 순서를 유지).

#### 실행 결과 - 주석 해제
```
map1 = {Apple=5, Tomato=6, Banana=6}
Exception in thread "main" java.lang.IllegalStateException: Duplicate key 
Apple (attempted merging values 5 and 5)
   at java.base/
java.util.stream.Collectors.duplicateKeyException(Collectors.java:135)
   at java.base/
```
- map2 에서는 동일한 키("Apple")가 두 번 생겼는데, 병합 함수가 없으므로 중복된 키 때문에 예외가 발생한 것이다.
- 이런 상황을 처리하려면 세 번째 인자로 병합 함수를 넘기거나, 스트림 단계에서 키가 중복되지 않도록 미리 걸러야 한다.

## 컬렉터2
### 그룹과 분할 수집
```
package stream.collectors;

import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public class Collectors3Group {
    public static void main(String[] args) {
        // 첫 글자 알파벳을 기준으로 그룹화
        List<String> names = List.of("Apple", "Avocado", "Banana", "Blueberry", "Cherry");
        Map<String, List<String>> grouped = names.stream()
                .collect(Collectors.groupingBy(name -> name.substring(0, 1)));
        System.out.println("grouped = " + grouped);

        // 짝수(even)인지 여부로 분할(파티셔닝)
        List<Integer> numbers = List.of(1, 2, 3, 4, 5, 6);
        Map<Boolean, List<Integer>> partitioned = numbers.stream()
                .collect(Collectors.partitioningBy(n -> n % 2 == 0));
        System.out.println("partitioned = " + partitioned);
    }
}
```

#### 실행 결과
```
grouped = {A=[Apple, Avocado], B=[Banana, Blueberry], C=[Cherry]}
partitioned = {false=[1, 3, 5], true=[2, 4, 6]}
```
- groupingBy(...) 는 특정 기준(예: 첫 글자)에 따라 스트림 요소를 여러 그룹으로 묶는다. 결과는 Map<기준, List<요소>> 형태다.
- partitioningBy(...) 는 단순하게 true 와 false 두 그룹으로 나눈다. 예제에서는 짝수(true), 홀수(false)로 분할했다.

### 최솟값 최댓값 수집
```
package stream.collectors;

import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;

public class Collectors4MinMax {
    public static void main(String[] args) {
        // 다운스트림 컬렉터에서 유용하게 사용
        Integer max1 = Stream.of(1, 2, 3)
                .collect(Collectors.maxBy(
                        (i1, i2) -> i1.compareTo(i2)
                ))
                .get();
        System.out.println("max1 = " + max1);

        Integer max2 = Stream.of(1, 2, 3)
                .max((i1, i2) -> i1.compareTo(i2))
                .get();
        System.out.println("max2 = " + max2);

        Integer max3 = Stream.of(1, 2, 3)
                .max(Integer::compareTo)
                .get();
        System.out.println("max3 = " + max3);

        // 기본형 특화 스트림 사용
        int max4 = IntStream.of(1, 2, 3)
                .max()
                .getAsInt();
        System.out.println("max4 = " + max4);
    }
}
```
#### 실행 결과
```
max1 = 3
max2 = 3
max3 = 3
max4 = 3
```
- Collectors.maxBy(...) 나 Collectors.minBy(...) 를 통해 최소, 최댓값을 구할 수 있다.
- 다만 스트림 자체가 제공하는 max() , min() 메서드를 쓰면 더 간단하다.
- 기본형 특화 스트림( IntStream 등)을 쓰면 .max().getAsInt() 처럼 바로 기본형으로 결과를 얻을 수 있다.
- Collectors 의 일부 기능은 스트림에서 직접 제공하는 기능과 중복된다. Collectors 의 기능들은 뒤에서 설명할 다운 스트림 컬렉터에서   
  유용하게 사용할 수 있다.

### 통계 수집
```
package stream.collectors;

import java.util.IntSummaryStatistics;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;

public class Collectors4Summing {
    public static void main(String[] args) {
        // 다운스트림 컬렉터에서 유용하게 사용
        long count1 = Stream.of(1, 2, 3)
                .collect(Collectors.counting());
        System.out.println("count1 = " + count1);

        long count2 = Stream.of(1, 2, 3)
                .count();
        System.out.println("count2 = " + count2);

        // 다운스트림 컬렉터에서 유용하게 사용
        double average1 = Stream.of(1, 2, 3)
                .collect(Collectors.averagingInt(i -> i));
        System.out.println("average1 = " + average1);

        // 기본형 특화 스트림으로 변환
        double average2 = Stream.of(1, 2, 3)
                .mapToInt(i -> i)
                .average()
                .getAsDouble();
        System.out.println("average2 = " + average2);

        // 기본형 특화 스트림 사용
        double average3 = IntStream.of(1, 2, 3)
                .average()
                .getAsDouble();
        System.out.println("average3 = " + average3);

        // 통계
        IntSummaryStatistics stats = Stream.of("Apple", "Banana", "Tomato")
                .collect(Collectors.summarizingInt(String::length));

        System.out.println(stats.getCount());   // 3
        System.out.println(stats.getSum());     // 17 (5+6+6)
        System.out.println(stats.getMin());     // 5
        System.out.println(stats.getMax());     // 6
        System.out.println(stats.getAverage()); // 5.66...
    }
}
```
#### 실행 결과
```
count1 = 3
count2 = 3
average1 = 2.0
average2 = 2.0
average3 = 2.0
3
17
5
6
5.666666666666667
```
- counting() 은 요소 개수를 구한다.
- averagingInt() 는 요소들의 평균을 구한다.
- summarizingInt() 는 합계, 최솟값, 최댓값, 평균 등 다양한 통계 정보를 담은 IntSummaryStatistics 객체를 얻는다.
- 자주 쓰이는 통계 메서드로 summingInt() , maxBy() , minBy() , counting() 등이 있다.
- Collectors 의 일부 기능은 스트림에서 직접 제공하는 기능과 중복된다. Collectors 의 기능들은 뒤에서 설명할 다운 스트림 컬렉터에서    
  유용하게 사용할 수 있다.

### 리듀싱 수집
```
package stream.collectors;

import java.util.List;
import java.util.stream.Collectors;

public class Collectors5Reducing {
    public static void main(String[] args) {
        List<String> names = List.of("a", "b", "c", "d");

        // 컬렉션의 리듀싱은 주로 다운스트림에 활용 (스트림이 제공하는 리듀싱이 있으므로)
        // 모든 이름을 하나의 문자열로 이어 붙이기
        String joined1 = names.stream()
                .collect(Collectors.reducing((s1, s2) -> s1 + "," + s2))
                .get();
        System.out.println("joined1 = " + joined1);

        String joined2 = names.stream()
                .reduce((s1, s2) -> s1 + "," + s2)
                .get();
        System.out.println("joined2 = " + joined2);

        // 문자열 전용 기능
        String joined3 = names.stream()
                .collect(Collectors.joining(","));
        System.out.println("joined3: " + joined3);

        String joined4 = String.join(",", "a", "b", "c", "d");
        System.out.println("joined4: " + joined4);
    }
}
```
#### 실행 결과
```
joined1 = a,b,c,d
joined2 = a,b,c,d
joined3: a,b,c,d
joined4: a,b,c,d
```
- Collectors.reducing(...) 은 최종적으로 하나의 값으로 요소들을 합치는 방식을 지정한다. 여기서는 문자열들을 ,``로 이어붙였다.
- 스트림 자체의 reduce(...) 메서드와 유사한 기능이다.
- 문자열을 이어 붙일 때는 Collectors.joining() 이나 String.join() 을 쓰는 게 더 간편하다.
- Collectors 의 일부 기능은 스트림에서 직접 제공하는 기능과 중복된다. Collectors 의 기능들은 뒤에서 설명할 다운 스트림 컬렉터에서    
  유용하게 사용할 수 있다.

## 다운 스트림 컬렉터1
### 다운 스트림 컬렉터가 필요한 이유
- groupingBy(...) 를 사용하면 일단 요소가 그룹별로 묶이지만, 그룹 내 요소를 구체적으로 어떻게 처리할지는 기본적으로 toList() 만 적용된다.
- 그런데 실무에서는 "그룹별 **총합, 평균, 최대/최솟값, 매핑된 결과, 통계"** 등을 바로 얻고 싶을 때가 많다.
- 예를 들어, "학년별로 학생들을 그룹화한 뒤, 각 학년 그룹에서 **평균 점수**를 구하고 싶다"는 상황에서는 단순히 List<Student> 로 끝나는 것이   
  아니라, 그룹 내 학생들의 점수를 합산하고 평균을 내는 동작이 더 필요하다. 
  이처럼 **그룹화된 이후 각 그룹 내부에서 추가적인 연산 또는 결과물(예: 평균, 합계, 최댓값, 최솟값, 통계, 다른 타입으로 변환 등)을 정의**하는 
  역할을 하는 것이 바로 다운 스트림 컬렉터(Downstream Collector)이다.
- 이때 **다운 스트림 컬렉터를 활용**하면 "그룹 내부"를 다시 한번 모으거나 집계하여 원하는 결과를 얻을 수 있다.
  - 예: groupingBy(분류함수, counting()) → 그룹별 개수
  - 예: groupingBy(분류함수, summingInt(Student::getScore)) → 그룹별 점수 합계
  - 예: groupingBy(분류함수, mapping(Student::getName, toList())) → 그룹별 학생 이름 리스트

#### 다운 스트림 컬렉터 예시 그림
![](https://github.com/dididiri1/TIL/blob/main/Java/ractical/images/10_01.png?raw=true)
- 각 학년별로 그룹화를 한 다음, 그룹화한 학년별 점수의 합을 구하는 방법

### 다운 스트림 컬렉터란?
- Collectors.groupingBy(...) 또는 Collectors.partitioningBy(...) 에서 **두 번째 인자**로 전달되는 Collector 를 가리켜 
  "다운 스트림 컬렉터"라 한다.
- 예를 들어 Collectors.groupingBy(classifier, downstreamCollector) 형태로 사용될 때, downstreamCollector 는 classifier 에 
  의해 분류된 각 그룹 내부의 요소들을 **다시 한 번** 어떻게 처리할지를 정의하는 역할을 한다.
- 예를 들어 학년 별로 그룹화 한다면, 그룹화한 각 학년별 요소들을 다시 한 번 어떻게 처리할지 정의하는 것이다.
```
// 예시
Map<KeyType, DownstreamResult> result =
    stream.collect(Collectors.groupingBy(
        element -> 분류 기준 Key, // 1) groupingBy용 분류 함수
        downstreamCollector // 2) 그룹 내부를 처리할 다운 스트림 컬렉터
    ));
```
- 만약 다운 스트림 컬렉터를 명시하지 않으면, 기본적으로 Collectors.toList() 가 적용되어서 **그룹별 요소들을 List**로 모은다.
- 그러나 그룹별 개**수를 세거나, 평균을 구하거나, 특정 필드를 뽑아서 맵핑**하거나 등등의 작업이 필요하다면, 적절한 다운 스트림 컬렉터를
  추가로 지정해야 한다.
- 다운 스트림 컬렉터는 그룹화(또는 분할)를 먼저 한 뒤, 각 그룹(또는 파티션) 내부의 요소들을 어떻게 처리할 것인가? 를 지정하는 데 사용된다.
  - 예를 들어, groupingBy(분류 함수, counting()) 라면 "각 그룹에 속한 요소들의 **개수**"를 구하는 다운 스트림 컬렉터가 된다.
  - 또 groupingBy(분류 함수, averagingInt(속성)) 라면 "각 그룹에 속한 요소들의 **속성 평균**"을 구하게 된다.
  - 여러 Collector 를 중첩할 수도 있다. 예: groupingBy(분류 함수, mapping(다른 함수, toList())) 처럼 "각 그룹에서 특정 속성만 
    매핑한 뒤 List로 수집하기" 등을 할 수 있다.

### 다운 스트림 컬렉터의 종류
# Collector 사용 메서드 정리

| Collector 사용 메서드      | 예시                                                      | 설명                                                                 | 반환 타입               |
|-------------------------|---------------------------------------------------------|--------------------------------------------------------------------|----------------------|
| counting()              | `Collectors.counting()`                                 | 그룹 내(혹은 스트림 내) 요소들의 개수를 센다.                              | Long                 |
| summingInt() 등          | `Collectors.summingInt(...)`, `Collectors.summingLong(...)` | 그룹 내 요소들의 특정 정수형 속성을 모두 합산한다.                           | Integer, Long 등      |
| averagingInt() 등        | `Collectors.averagingInt(...)`, `Collectors.averagingDouble(...)` | 그룹 내 요소들의 특정 속성 평균값을 구한다.                                  | Double               |
| minBy(), maxBy()         | `Collectors.minBy(Comparator)`, `Collectors.maxBy(Comparator)` | 그룹 내 최소, 최댓값을 구한다.                                           | Optional<T>          |
| summarizingInt() 등      | `Collectors.summarizingInt(...)`, `Collectors.summarizingLong(...)` | 개수, 합계, 평균, 최소, 최댓값을 동시에 구할 수 있는 SummaryStatistics 객체를 반환 | IntSummaryStatistics 등 |
| mapping()               | `Collectors.mapping(변환 함수, 다운스트림)`              | 각 요소를 다른 값으로 변환한 뒤, 변환된 값들을 다시 다른 Collector로 수집 가능      | 다운스트림 반환 타입에 따라 다름 |
| collectingAndThen()      | `Collectors.collectingAndThen(다른 컬렉터, 변환 함수)`       | 다운 스트림 컬렉터의 결과를 최종적으로 한 번 더 가공(후처리)할 수 있다.               | 후처리 후의 타입       |
| reducing()              | `Collectors.reducing(초깃값, 변환 함수, 누적 함수)` <br> `Collectors.reducing(누적 함수)` | 스트림의 reduce()와 유사하게, 그룹 내 요소들을 하나로 합치는 로직 정의 가능          | 누적 로직에 따라 다름   |
| toList(), toSet()        | `Collectors.toList()`, `Collectors.toSet()`             | 그룹 내(혹은 스트림 내) 요소를 리스트나 집합으로 수집. `toCollection(...)`으로 구현체 지정 가능 | List<T>, Set<T>       |

이 표는 다운 스트림 컬렉터의 대표적인 예시이다. groupingBy(...) , partitioningBy(...) 에서 두 번째 인
자로 활용되거나, 스트림의 collect() 에서 직접 쓰이기도 한다.


### 다운 스트림 컬렉터 예제 1
다운 스트림 컬렉터를 실제로 사용해보자. 예제를 위해 간단한 학생(Student) 클래스를 먼저 만들자.
```
package stream.collectors;

public class Student {
    private String name;
    private int grade;
    private int score;

    // Constructor
    public Student(String name, int grade, int score) {
        this.name = name;
        this.grade = grade;
        this.score = score;
    }

    // Getter
    public String getName() {
        return name;
    }

    public int getGrade() {
        return grade;
    }

    public int getScore() {
        return score;
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", grade=" + grade +
                ", score=" + score +
                '}';
    }
}
```

```
package stream.collectors;

import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public class DownStreamMain1 {
    public static void main(String[] args) {
        List<Student> students = List.of(
                new Student("Kim", 1, 85),
                new Student("Park", 1, 70),
                new Student("Lee", 2, 70),
                new Student("Han", 2, 90),
                new Student("Hoon", 3, 90),
                new Student("Ha", 3, 89)
        );

        // 1단계: 학년별로 학생들을 그룹화
        Map<Integer, List<Student>> collect1_1 = students.stream()
                .collect(Collectors.groupingBy(
                        Student::getGrade, // 그룹화 기준: 학년
                        Collectors.toList() // 다운스트림1: 학생을 리스트로 수집
                ));
        System.out.println("collect1_1 = " + collect1_1);

        // 다운스트림에서 toList() 생략 가능
        Map<Integer, List<Student>> collect1_2 = students.stream()
                .collect(Collectors.groupingBy(Student::getGrade));
        System.out.println("collect1_2 = " + collect1_2);

        // 2단계: 학년별로 학생들의 이름을 출력
        Map<Integer, List<String>> collect2 = students.stream()
                .collect(Collectors.groupingBy(
                        Student::getGrade, // 그룹화 기준: 학년
                        Collectors.mapping(
                                Student::getName, // 다운스트림 1: 학생 -> 이름 변환
                                Collectors.toList() // 다운스트림 2: 변환된 값(이름)을 List로 수집
                        )
                ));
        System.out.println("collect2 = " + collect2);

        // 3단계: 학년별로 학생들의 수를 출력
        Map<Integer, Long> collect3 = students.stream()
                .collect(Collectors.groupingBy(
                        Student::getGrade,
                        Collectors.counting()
                ));
        System.out.println("collect3 = " + collect3);

        // 4단계: 학년별로 학생들의 평균 성적 출력
        Map<Integer, Double> collect4 = students.stream()
                .collect(Collectors.groupingBy(
                        Student::getGrade,
                        Collectors.averagingInt(Student::getScore)
                ));
        System.out.println("collect4 = " + collect4);
    }
}
```

#### 다운스트림 컬렉터 - Collectors.toList()
![](https://github.com/dididiri1/TIL/blob/main/Java/ractical/images/10_02.png?raw=true)

groupingBy(Student::getGrade)
- 학년(grade)을 기준으로 학생(Student) 객체를 그룹화한다.
- **다운 스트림 컬렉터를 생략**하면 자동으로 Collectors.toList() 가 적용되어 Map<Integer, List<Student>> 형태가 된다.

groupingBy(Student::getGrade, toList())
- 명시적으로 다운 스트림 컬렉터를 toList() 로 지정한 것. 결과는 같음.

#### 다운스트림 컬렉터 - mapping()
![](https://github.com/dididiri1/TIL/blob/main/Java/ractical/images/10_03.png?raw=true)

groupingBy(Student::getGrade, mapping(Student::getName, toList()))
- 스트림의 map 을 떠올리면 된다.
- 먼저 "학년"으로 그룹화한 뒤, 그 그룹 내부에서 다시 학생(Student)을 "이름(String)"으로 매핑(mapping). 그리고 최종적으로 그 이름들을 리스트에 담는다.
- 즉, **그룹별로 학생들의 이름 목록**을 얻는다.

#### 다운스트림 컬렉터 - 집계
groupingBy(Student::getGrade, counting())
- 그룹별로 **학생 수**를 구한다. 결과는 Map<Integer, Long> .

groupingBy(Student::getGrade, averagingInt(Student::getScore))
- 그룹별로 학생들의 **점수 평균**을 구한다. 결과는 Map<Integer, Double> .

#### 실행 결과
```
collect1_1 = {1=[Student{name='Kim', grade=1, score=85}, Student{name='Park', 
grade=1, score=70}], 2=[Student{name='Lee', grade=2, score=70}, 
Student{name='Han', grade=2, score=90}], 3=[Student{name='Hoon', grade=3, 
score=90}, Student{name='Ha', grade=3, score=89}]}

collect1_2 = {1=[Student{name='Kim', grade=1, score=85}, Student{name='Park', 
grade=1, score=70}], 2=[Student{name='Lee', grade=2, score=70}, 
Student{name='Han', grade=2, score=90}], 3=[Student{name='Hoon', grade=3, 
score=90}, Student{name='Ha', grade=3, score=89}]}

collect2 = {1=[Kim, Park], 2=[Lee, Han], 3=[Hoon, Ha]}
collect3 = {1=2, 2=2, 3=2}
collect4 = {1=77.5, 2=80.0, 3=89.5}
```






  
  



