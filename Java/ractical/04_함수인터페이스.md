# 섹션 4. 함수형 인터페이스

## 함수형 인터페이스와 제네릭1
함수형 인터페이스도 인터페이스이기 떄문에 제네릭을 도입할 수 있다.
먼저 함수형 인터페이스에 제네릭이 필요한 이우를 알아보자.

### 각각 다른 타입 사용
다음 코드는 문자 타입, 숫자 타입을 각각 처리하는 두 개의 함수형 인터페이스를 사용한다.
```
package lambda.lambda3;

public class GenericMain1 {
    public static void main(String[] args) {
        StringFunction upperCase = s -> s.toUpperCase();
        String result1 = upperCase.apply("hello");
        System.out.println("result1 = " + result1);

        NumberFunction square = n -> n * n;
        Integer result2 = square.apply(3);
        System.out.println("result2 = " + result2);
    }

    @FunctionalInterface
    interface StringFunction {
        String apply(String s);
    }

    @FunctionalInterface
    interface NumberFunction {
        Integer apply(Integer s);
    }
}
```
#### 실행 결괴
```
result1 = HELLO
result2 = 9
```
StringFunction 이 제공하는 apply 메서드와 NumberFunction 이 제공하는 apply 메서드는 둘다 하나의 인자를 입력받고, 결과를 반환한다.
다만 입력받는 타입과 반환 타입이 다를 뿐이다. 이렇게 매개변수나 반환 타입이 다를 때마다 계속 함수형 인터페이스를 만들어야 할까?

### Object 타입으로 합치기
Object 는 모든 타입의 부모이다. 따라서 다형성(다형적 참조)를 사용해서 이 문제를 간단히 해결할 수 있을 것 같다.

```
package lambda.lambda3;

public class GenericMain2 {
    public static void main(String[] args) {
        ObjectFunction upperCase = s -> ((String) s).toUpperCase();
        String result1 = (String) upperCase.apply("hello");
        System.out.println("result1 = " + result1);

        ObjectFunction square = n -> (Integer) n * (Integer) n;
        Integer result2 = (Integer) square.apply(3);
        System.out.println("result2 = " + result2);
    }

    @FunctionalInterface
    interface ObjectFunction {
        Object apply(Object s);
    }
}
```
- 메서드가 Object 를 매개변수로 사용하고, Object 를 반환하면 모든 타입을 입력 받고, 또 모든 타입을 반환할 수 있다. 
  따라서 이전과 같이 타입에 따라 각각 다른 함수형 인터페이스를 만들지 않아도 된다. 따라서 앞서 각각 만든 함수형 인터페이스
  2개를 1개로 합칠 수 있다.
- 물론 Object 를 사용하기 때문에 복잡하고 안전하지 않은 캐스팅 과정이 필요하다.
- 실행 결과는 기존과 같다.

코드를 이해하기 쉽게 익명 클래스로 변경해보자.
```
package lambda.lambda3;

public class GenericMain3 {
    public static void main(String[] args) {
        ObjectFunction upperCase = new ObjectFunction() {
            @Override
            public Object apply(Object s) {
                return ((String) s).toUpperCase();
            }
        };
        String result1 = (String) upperCase.apply("hello");
        System.out.println("result1 = " + result1);

        ObjectFunction square = new ObjectFunction() {
            @Override
            public Object apply(Object n) {
                return (Integer) n * (Integer) n;
            }
        };
        Integer result2 = (Integer) square.apply(3);
        System.out.println("result2 = " + result2);
    }

    @FunctionalInterface
    interface ObjectFunction {
        Object apply(Object s);
    }
}
```
실행 결과는 기존과 같다.

#### 정리
Object 와 다형성을 활용한 덕분에 코드의 중복을 제거하고, 재사용성을 늘리게 되었다. 하지만 Object 를 사용하므로   
다운 캐스팅을 해야 하고, 결과적으로 타입 안전성 문제가 발생한다.

지금까지 개발한 프로그램은 코드 재사용과 타입 안전성이라는 2마리 토끼를 한번에 잡을 수 없다. 코드 재사용을 늘리기  
위해 Object 와 다형성을 사용하면 타입 안전성이 떨어지는 문제가 발생한다.
- StringFunction , NumberFunction 각각의 타입별로 함수형 인터페이스를 모두 정의
  - 코드 재사용X
  - 타입 안전성O
- ObjectFunction를 사용해서 Object의 다형성을 활용해서 하나의 함수형 인터페이스만 정의
  - 코드 재사용O
  - 타입 안전성X