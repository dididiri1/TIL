# 섹션 6. 람다 활용

## 필터 만들기1

람다를 처음 사용하면, 대부분 바로바로 람다를 사용하기는 어렵다. 람다에 익숙해지는데 어느정도의 시간이 걸린다.
이번 시간에는 람다를 활용하는 방법들을 알아보고, 또 다양한 문제를 풀어보면서 람다에 익숙해지는 시간을 가져보자.

### 필터1
먼저 람다를 사용하지 않고, 짝수만 거르기, 홀수만 거르기 메서드를 각각 따로 작성해보자.

```
import java.util.ArrayList;
import java.util.List;

public class FilterMainV1 {

    public static void main(String[] args) {
        List<Integer> numbers = List.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

        // 짝수만 거르기
        List<Integer> evenNumbers = filterEvenNumber(numbers);
        System.out.println("evenNumbers = " + evenNumbers);

        // 홀수만 거르기
        List<Integer> oddNumbers = filterOddNumber(numbers);
        System.out.println("oddNumbers = " + oddNumbers);
    }

    static List<Integer> filterEvenNumber(List<Integer> numbers) {
        List<Integer> filtered = new ArrayList<>();
        for (Integer number : numbers) {
            boolean testResult = number % 2 == 0;
            if (testResult) {
                filtered.add(number);
            }
        }
        return filtered;
    }

    static List<Integer> filterOddNumber(List<Integer> numbers) {
        List<Integer> filtered = new ArrayList<>();
        for (Integer number : numbers) {
            boolean testResult = number % 2 == 1;
            if (testResult) {
                filtered.add(number);
            }
        }
        return filtered;
    }
}
```

#### 실행 결과
```
evenNumbers = [2, 4, 6, 8, 10]
oddNumbers = [1, 3, 5, 7, 9]
```
여기서는 filterEvenNumber() , filterOddNumber() 두 메서드를 각각 만들어서 문제를 해결했다.

### 문제
- FilterMainV1 클래스를 복사해서 FilterMainV2 클래스를 만들자.
- 앞서 작성한 filterEvenNumber() , filterOddNumber() 두 메서드 대신에 filter() 라는 하나의 메 서드만 사용해서 중복을 제거하자.
- 람다를 활용하자.

### 힌트
filterEvenNumber() , filterOddNumber() 에서 다른 부분은 다음 코드이다.
```
boolean testResult = number % 2 == 0; // filterEvenNumber()
boolean testResult = number % 2 == 1; // filterOddNumber()
```
- 이 코드 조각을 Predicate 로 전달해서 처리하면 된다.
- 변수가 Integer number 하나이고, 반환 타입이 boolean 이다.
  - Function<Integer, Boolean> 또는 Predicate<Integer> 를 선택하면 된다.
  - 조건이 맞는지 확인( test )하는 용도이므로 Predicate 가 더 적절하다.

## 필터2
```
package lambda.lambda5.filter;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Predicate;

public class FilterMainV2 {

    public static void main(String[] args) {
        List<Integer> numbers = List.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

        // 짝수만 거르기
        Predicate<Integer> evenPredicate = n -> n % 2 == 0;
        List<Integer> evenNumbers = filter(numbers, evenPredicate);
        System.out.println("evenNumbers = " + evenNumbers);

        // 홀수만 거르기
        Predicate<Integer> oddPredicate = n -> n % 2 == 1;
        List<Integer> oddNumbers = filter(numbers, oddPredicate);
        System.out.println("oddNumbers = " + oddNumbers);
    }

    static List<Integer> filter(List<Integer> numbers, Predicate<Integer> predicate) {
        List<Integer> filtered = new ArrayList<>();
        for (Integer number : numbers) {
            if (predicate.test(number)) {
                filtered.add(number);
            }
        }
        return filtered;
    }
}
```
- Predicate<Integer> 를 filter() 에 인자로 넘긴다.
  - 짝수: Predicate<Integer> evenPredicate = n -> n % 2 == 0
  - 홀수: Predicate<Integer> oddPredicate = n -> n % 2 == 1
- boolean testResult = predicate.test(number) 을 사용해서 넘긴 코드 조각을 filter() 안에서 실행한다.
  - for 루프를 통해 리스트 안에 있는 각각의 항목에 람다가 모두 적용된다.
  - 결과가 참이면 새로운 리스트에 담기고 거짓이면 새로운 리스트에 담기지 않는다.

#### 실행 결과
```
evenNumbers = [2, 4, 6, 8, 10]
oddNumbers = [1, 3, 5, 7, 9]
```

### 필터3
코드를 조금 다듬어보자.
```
package lambda.lambda5.filter;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Predicate;

public class FilterMainV3 {
    public static void main(String[] args) {
        List<Integer> numbers = List.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        
        // 짝수만 거르기
        List<Integer> evenNumbers = filter(numbers, n -> n % 2 == 0);
        System.out.println("evenNumbers = " + evenNumbers);
        
        // 홀수만 거르기
        List<Integer> oddNumbers = filter(numbers, n -> n % 2 == 1);
        System.out.println("oddNumbers = " + oddNumbers);
    }

    static List<Integer> filter(List<Integer> numbers, Predicate<Integer> predicate) {
        List<Integer> filtered = new ArrayList<>();
        for (Integer number : numbers) {
            if (predicate.test(number)) {
                filtered.add(number);
            }
        }
        return filtered;
    }
}
```
- evenPredicate , oddPredicate , testResult 변수를 제거했다.  
- 해당 변수들은 학습의 이해를 돕기 위해 만든 것으로 꼭 필요한 변수는 아니다.  
- 특히 람다의 경우 주로 간단한 식을 사용하므로, 복잡할 때를 제외하고는 변수를 잘 만들지 않는다.  
  - evenPredicate, oddPredicate 를 제거하니 가독성이 더 좋아진 것을 확인할 수 있다.  

## 필터 만들기2
앞서 맏든 filter() 메서드는 매개변수가 List<Integer> numbers, Predicate<Integer> predicate이다.  
따라서 숫자 리스트에 있는 값을 필터링 하는 모든 곳에서 사용할 수 있다.  
다양한 곳에서 활용할 수 있으므로, 별도의 유틸리티 클래스로 만들어보자  

### 필터4
```
package lambda.lambda5.filter;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Predicate;

public class IntegerFilter {
    public static List<Integer> filter(List<Integer> list, Predicate<Integer> predicate) {
        List<Integer> filtered = new ArrayList<>();
        for (Integer num : list) {
            if (predicate.test(num)) {
                filtered.add(num);
            }
        }
        return filtered;
    }
}
```
```
package lambda.lambda5.filter;

import java.util.List;

public class FilterMainV4 {
    public static void main(String[] args) {
        List<Integer> numbers = List.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

        // 짝수만 거르는 필터
        List<Integer> evenNumbers = IntegerFilter.filter(numbers, n -> n % 2 == 0);
        System.out.println("evenNumbers = " + evenNumbers);

        // 홀수만 거르는 필터
        List<Integer> oddNumbers = IntegerFilter.filter(numbers, n -> n % 2 == 1);
        System.out.println("oddNumbers = " + oddNumbers);
    }
}
```
#### 실행 결과
```
evenNumbers = [2, 4, 6, 8, 10]
oddNumbers = [1, 3, 5, 7, 9]
```
- 범용성 있게 다양한 곳에서 사용할 수 있는 IntegerFilter 클래스를 만들었다.
- 하지만 Integer 숫자에만 사용할 수 있는 한계가 있다.

### 필터5 - 제네릭 도입
제네릭을 사용하면 클래스 코드의 변경 없이 다양한 타입을 적용할 수 있다.  
앞서 만든 IntegerFilter 에 제네릭을 도입해보자.

```
package lambda.lambda5.filter;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Predicate;

public class GenericFilter {
    public static <T> List<T> filter(List<T> list, Predicate<T> predicate) {
        List<T> result = new ArrayList<>();
        for (T num : list) {
            if (predicate.test(num)) {
                result.add(num);
            }
        }
        return result;
    }
}
```
- 제네릭 <T> 를 선언하고, Integer 로 되어 있는 부분을 T 로 변경하면 된다.
```
package lambda.lambda5.filter;

import java.util.List;

public class FilterMainV5 {
    public static void main(String[] args) {
        // 숫자 사용 필터
        List<Integer> numbers = List.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        List<Integer> numbersResult = GenericFilter.filter(numbers, n -> n % 2 == 0);
        System.out.println("numbersResult = " + numbersResult); // [2, 4, 6, 8, 10]

        // 문자 사용 필터
        List<String> strings = List.of("A", "BB", "CCC");
        List<String> stringsResult = GenericFilter.filter(strings, s -> s.length() >= 2);
        System.out.println("stringsResult = " + stringsResult); // [BB, CCC]
    }
}
```
#### 실행 결과
```
numbersResult = [2, 4, 6, 8, 10]
stringsResult = [BB, CCC]
```
- 제네릭을 도입한 덕분에 Integer , String 같은 다양한 타입의 리스트에 필터링 기능을 사용할 수 있게 되었다.
- GenericFilter 는 제네릭을 사용할 수 있는 모든 타입의 리스트를 람다 조건으로 필터링 할 수 있다. 따라서  
  매우 유연한 필터링 기능을 제공한다.

## 맵 만들기1
맵(map)은 대응, 변환을 의미하는 매핑(mapping)의 줄임말이다.  
매핑은 어떤 것을 다른 것으로 변환하는 과정을 의미한다.  
프로그래밍에서는 각 요소를 다른 값으로 변환하는 작업을 매핑(mapping, map)이라 한다.  
쉽게 이야기해서 어떤 하나의 데이터를 다른 데이터로 변환하는 작업이라고 생각하면 된다.  

리스트에 있는 특정 값을 다른 값으로 매핑(변환)해보자.
### 맵1
```
package lambda.lambda5.map;

import java.util.ArrayList;
import java.util.List;

public class MapMainV1 {

    public static void main(String[] args) {
        List<String> list = List.of("1", "12", "123", "1234");

        // 문자열을 숫자로 변환
        List<Integer> numbers = mapStringToInteger(list);
        System.out.println("numbers = " + numbers);

        // 문자열의 길이
        List<Integer> lengths = mapStringToLength(list);
        System.out.println("lengths = " + lengths);
    }

    static List<Integer> mapStringToInteger(List<String> list) {
        List<Integer> numbers = new ArrayList<>();
        for (String s : list) {
            Integer value = Integer.valueOf(s);
            numbers.add(value);
        }
        return numbers;
    }

    static List<Integer> mapStringToLength(List<String> list) {
        List<Integer> numbers = new ArrayList<>();
        for (String s : list) {
            Integer value = s.length();
            numbers.add(value);
        }
        return numbers;
    }
}
```
#### 실행 결과
```
numbers = [1, 12, 123, 1234]
lengths = [1, 2, 3, 4]
```
- 문자열을 숫자로 변환
  - 리스트에 있는 문자( String ) "1", "12", "123", "1234"를 숫자( Integer ) 1, 12, 123, 1234로 변환했다.
- 문자열을 문자열의 길이로 변환
  - 리스트에 있는 문자( String ) "1", "12", "123", "1234"를 각 문자의 길이( Integer )인 1, 2, 3, 4로 변환했다.

### 문제
- MapMainV1 클래스를 복사해서 MapMainV2 클래스를 만들자.
- 앞서 작성한 mapStringToInteger() , mapStringToLength() 두 메서드 대신에 map() 이라는 하나의 메서드만 사용해서 중복을 제거하자.
- 람다를 활용하자.

### 힌트
mapStringToInteger() , mapStringToLength() 에서 다른 부분은 다음 코드이다.
```
Integer value = Integer.valueOf(s); // mapStringToInteger()
Integer value = s.length(); // mapStringToLength()
```
- 이 코드 조각을 람다로 전달해서 처리하면 된다.
- 변수가 String s 하나이고, 반환 타입이 Integer 이다.
  - Function<String, Integer> 를 선택하면 된다.

### 맵2
```
package lambda.lambda5.map;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Function;

public class MapMainV2 {

    public static void main(String[] args) {
        List<String> list = List.of("1", "12", "123", "1234");

        // 문자열을 숫자로 변환
        Function<String, Integer> toNumber = s -> Integer.valueOf(s);
        List<Integer> numbers = map(list, toNumber);
        System.out.println("numbers = " + numbers);

        // 문자열의 길이
        Function<String, Integer> toLength = s -> s.length();
        List<Integer> lengths = map(list, toLength);
        System.out.println("lengths = " + lengths);
    }

    static List<Integer> map(List<String> list, Function<String, Integer> mapper) {
        List<Integer> numbers = new ArrayList<>();
        for (String s : list) {
            Integer value = mapper.apply(s);
            numbers.add(value);
        }
        return numbers;
    }
}
```
- Function<String, Integer> 를 map() 에 인자로 넘긴다.
  - 문자열을 숫자로: Function<String, Integer> toNumber = s -> Integer.valueOf(s)
  - 문자열을 길이로: Function<String, Integer> toLength = s -> s.length()
- Integer value = mapper.apply(s) 을 사용해서 넘긴 코드 조각을 map() 안에서 실행한다.
  - for 루프를 통해 리스트 안에 있는 각각의 항목에 람다가 모두 적용된다.
  - 여기서 각각의 String 항목이 람다를 통해 Integer 로 변환된다.

### 맵3
```
package lambda.lambda5.map;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Function;

public class MapMainV3 {

    public static void main(String[] args) {
        List<String> list = List.of("1", "12", "123", "1234");

        // 문자열을 숫자로 변환
        List<Integer> numbers = map(list, s -> Integer.valueOf(s));
        System.out.println("numbers = " + numbers);

        // 문자열의 길이
        List<Integer> lengths = map(list, s -> s.length());
        System.out.println("lengths = " + lengths);
    }

    static List<Integer> map(List<String> list, Function<String, Integer> mapper) {
        List<Integer> numbers = new ArrayList<>();
        for (String s : list) {
            numbers.add(mapper.apply(s));
        }
        return numbers;
    }
}
```
- toNumber , toLength , value 변수를 제거했다.

## 맵 만들기2
앞서 만든 map() 메서드는 매개변수가 List<String> list, Function<String, Integer> mapper 이다.  
따라서 문자열 리스트를 숫자 리스트로 변환(매핑)할 때 사용할 수 있다.  
다양한 곳에서 활용할 수 있으므로, 별도의 유틸리티 클래스로 만들어보자.

### 맵4
```
package lambda.lambda5.map;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Function;

public class StringToIntegerMapper {

    public static List<Integer> map(List<String> list, Function<String, Integer> mapper) {
        List<Integer> result = new ArrayList<>();
        for (String s : list) {
            result.add(mapper.apply(s));
        }
        return result;
    }
}
```
```
package lambda.lambda5.map;

import java.util.List;

public class MapMainV4 {
    public static void main(String[] args) {
    
        List<String> list = List.of("1", "12", "123", "1234");

        // 문자열을 숫자로 변환
        List<Integer> numbers = StringToIntegerMapper.map(list, s -> Integer.valueOf(s));
        System.out.println("numbers = " + numbers);

        // 문자열의 길이
        List<Integer> lengths = StringToIntegerMapper.map(list, s -> s.length());
        System.out.println("lengths = " + lengths);
    }
}
```
#### 실행 결과
```
numbers = [1, 12, 123, 1234]
lengths = [1, 2, 3, 4]
```
- 범용성 있게 다양한 곳에서 사용할 수 있는 StringToIntegerMapper 클래스를 만들었다.
- 하지만 String 리스트를 Integer 리스트로 변환할 때만 사용할 수 있는 한계가 있다.

### 맵5 - 제네릭 도입
제네릭을 사용하면 클래스 코드의 변경 없이 다양한 타입을 적용할 수 있다.
앞서 만든 StringToIntegerMapper 에 제네릭을 도입해보자.
```
package lambda.lambda5.map;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Function;

public class GenericMapper {

    public static <T, R> List<R> map(List<T> list, Function<T, R> mapper) {
        List<R> result = new ArrayList<>();
        for (T s : list) {
            result.add(mapper.apply(s));
        }
        return result;
    }
}
```
- 제네릭 <T, R> 을 선언하고, String 부분을 T 로, Integer 로 되어 있는 부분을 R 로 변경하면 된다.
  - T : 입력, R : 출력(반환)
```
package lambda.lambda5.map;

import java.util.List;

public class MapMainV5 {
    public static void main(String[] args) {
    
        List<String> fruits = List.of("apple", "banana", "orange");

        // String -> String
        List<String> upperFruits = GenericMapper.map(fruits, s -> s.toUpperCase());
        System.out.println(upperFruits); // [APPLE, BANANA, ORANGE]

        // String -> Integer
        List<Integer> lengthFruits = GenericMapper.map(fruits, s -> s.length());
        System.out.println(lengthFruits); // [5, 6, 6]

        // Integer -> String
        List<Integer> integers = List.of(1, 2, 3);
        List<String> starList = GenericMapper.map(integers, n -> "*".repeat(n));
        System.out.println(starList); // [*, **, ***]
    }
}
```
- String.repeat(int count) 는 자바 11에 추가된 메서드이다. 같은 문자를 count 수 만큼 붙여서 반환 한다.

#### 실행 결과
```
[APPLE, BANANA, ORANGE]
[5, 6, 6]
[*, **, ***]
```
- 제네릭을 도입한 덕분에 다양한 타입의 리스트의 값을 변환(매핑) 사용할 수 있게 되었다.
- GenericMapper 는 제네릭을 사용할 수 있는 모든 타입의 리스트를 람다 조건으로 변환(매핑) 할 수 있다.
- 따라서 매우 유여한 매핑(변환) 기능을 제공한다.

## 필터와 맵 활용1
이번에는 앞서 만든 필터와 맵을 함께 활용해서 문제를 풀어보자.

### 필터와 맵 활용 - 문제1
- 리스트에 있는 값 중에 짝수만 남기고, 남은 짝수 값의 2배를 반환해라.
- direct() 에 람다, 앞서 작성한 유틸리티를 사용하지 말고, for , if 등으로 코드를 직접 작성해라.
- lambda() 에 앞서 작성한 필터와 맵 유틸리티를 사용해서 코드를 작성해라.

```
package lambda.lambda5.mystream;

import lambda.lambda5.filter.GenericFilter;
import lambda.lambda5.map.GenericMapper;

import java.util.ArrayList;
import java.util.List;

public class Ex1_Number {
    public static void main(String[] args) {
        // 짝수만 남기고, 남은 값의 2배를 반환
        List<Integer> numbers = List.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

        List<Integer> directResult = direct(numbers);
        System.out.println("directResult = " + directResult);

        List<Integer> lambdaResult = lambda(numbers);
        System.out.println("lambdaResult = " + lambdaResult);
    }

    static List<Integer> direct(List<Integer> numbers) {
        // TODO 코드 작성
    }

    static List<Integer> lambda(List<Integer> numbers) {
        // TODO 코드 작성
    }
}
```
#### 실행 결과
```
directResult = [4, 8, 12, 16, 20]
lambdaResult = [4, 8, 12, 16, 20]
```

#### 정답
```
package lambda.lambda5.mystream;

import lambda.lambda5.filter.GenericFilter;
import lambda.lambda5.map.GenericMapper;

import java.util.ArrayList;
import java.util.List;

public class Ex1_Number {
    public static void main(String[] args) {
        // 짝수만 남기고, 남은 값의 2배를 반환
        List<Integer> numbers = List.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

        List<Integer> directResult = direct(numbers);
        System.out.println("directResult = " + directResult);

        List<Integer> lambdaResult = lambda(numbers);
        System.out.println("lambdaResult = " + lambdaResult);
    }

    static List<Integer> direct(List<Integer> numbers) {
        List<Integer> result = new ArrayList<>();
        for (Integer number : numbers) {
            if (number % 2 == 0) { // 짝수 필터링
                int numberX2 = number * 2;
                result.add(numberX2); // 2배로 변환하여 추가
            }
        }
        return result;
    }

    static List<Integer> lambda(List<Integer> numbers) {
        List<Integer> filteredList = GenericFilter.filter(numbers, n -> n % 2 == 0);
        List<Integer> mappedList = GenericMapper.map(filteredList, n -> n * 2);
        return mappedList;
    }
}
```
#### 실행 결과
```
directResult = [4, 8, 12, 16, 20]
lambdaResult = [4, 8, 12, 16, 20]
```
direct() 와 lambda() 는 서로 다른 프로그래밍 스타일을 보여준다.

direct() 는 프로그램을 어떻게 수행해야 하는지 수행 절차를 명시한다.
- 쉽게 이야기해서 개발자가 로직 하나하나를 어떻게 실행해야 하는지 명시한다.
- 이런 프로그래밍 방식을 명령형 프로그래밍이라 한다.
- 명령형 스타일은 익숙하고 직관적이나, 로직이 복잡해질수록 반복 코드가 많아질 수 있다.
- 쉽게 이야기해서 특정 조건으로 필터하고, 변환하라고 선언하면, 구체적인 부분은 내부에서 수행된다.
- 개발자는 필터하고 변환하는 것 즉 무엇을 해야 하는가에 초점을 맞춘다.
  - 예를 들어 실제 어떻게 for문과 if문 등을 사용해서 필터하고 변환할지를 개발자가 크게 신경쓰지 않는다.
- 이런 프로그래밍 방식을 선언적 프로그래밍이라 한다. 
- 선언형 스타일은 무엇을 하고자 하는지가 명확히 드러난다. 따라서 코드 가독성과 유지보수가 쉬워진다.
  - 여기서는 필터하고 변환하는 것에만 초점을 맞춘다. 실제 어떻게 필터하고 변환할지는 해당 기능을 사용하는 입장에서는 신경쓰지 않는다.

### 명령형 vs 선언적 프로그래밍
#### 명령형 프로그래밍 (Imperative Programming)
- **정의:** 프로그램이 **어떻게(How)** 수행되어야 하는지, 즉 **수행 절차**를 명시하는 방식이다.
- **특징:**
  - **단계별 실행:** 프로그램의 각 단계를 명확하게 지정하고 순서대로 실행한다.
  - **상태 변화:** 프로그램의 상태(변수 값 등)가 각 단계별로 어떻게 변화하는지 명시한다.
  - **낮은 추상화:** 내부 구현을 직접 제어해야 하므로 추상화 수준이 낮다.
  - **예시:** 전통적인 for 루프, while 루프 등을 명시적으로 사용하는 방식
  - **장점:** 시스템의 상태와 흐름을 세밀하게 제어할 수 있다.

#### 선언적 프로그래밍 (Declarative Programming)
- 정의: 프로그램이 무엇(What)을 수행해야 하는지, 즉 원하는 결과를 명시하는 방식이다.
- **특징:**
  - **문제 해결에 집중:** 어떻게(how) 문제를 해결할지보다 **무엇**을 원하는지에 초점을 맞춘다.
  - **코드 간결성:** 간결하고 읽기 쉬운 코드를 작성할 수 있다.
  - **높은 추상화:** 내부 구현을 숨기고 원하는 결과에 집중할 수 있도록 추상화 수준을 높인다.
  - **예시:** filter , map 등 람다의 고차 함수를 활용, HTML, SQL 등
- **장점:** 코드가 간결하고, 의도가 명확하며, 유지보수가 쉬운 경우가 많다.

#### 정리
- **명령형 프로그래밍**은 프로그램이 수행해야 할 각 단계와 처리 과정을 상세하게 기술하여, **어떻게** 결과에 도달할지를 명시한다.
- **선언적 프로그래밍**은 원하는 결과나 상태를 기술하며, 그 결과를 얻기 위한 내부 처리 방식은 추상화되어 있어 개발자가 무엇을 원하는지에   
  집중할 수 있게 한다.
- 특히, **람다**와 같은 도구를 사용하면, 코드를 간결하게 작성하여 선언적 스타일로 문제를 해결할 수 있다.