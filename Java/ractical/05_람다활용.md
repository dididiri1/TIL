# 섹션 6. 람다 활용

## 필터 만들기1

람다를 처음 사용하면, 대부분 바로바로 람다를 사용하기는 어렵다. 람다에 익숙해지는데 어느정도의 시간이 걸린다.
이번 시간에는 람다를 활용하는 방법들을 알아보고, 또 다양한 문제를 풀어보면서 람다에 익숙해지는 시간을 가져보자.

### 필터1
먼저 람다를 사용하지 않고, 짝수만 거르기, 홀수만 거르기 메서드를 각각 따로 작성해보자.

```
import java.util.ArrayList;
import java.util.List;

public class FilterMainV1 {

    public static void main(String[] args) {
        List<Integer> numbers = List.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

        // 짝수만 거르기
        List<Integer> evenNumbers = filterEvenNumber(numbers);
        System.out.println("evenNumbers = " + evenNumbers);

        // 홀수만 거르기
        List<Integer> oddNumbers = filterOddNumber(numbers);
        System.out.println("oddNumbers = " + oddNumbers);
    }

    static List<Integer> filterEvenNumber(List<Integer> numbers) {
        List<Integer> filtered = new ArrayList<>();
        for (Integer number : numbers) {
            boolean testResult = number % 2 == 0;
            if (testResult) {
                filtered.add(number);
            }
        }
        return filtered;
    }

    static List<Integer> filterOddNumber(List<Integer> numbers) {
        List<Integer> filtered = new ArrayList<>();
        for (Integer number : numbers) {
            boolean testResult = number % 2 == 1;
            if (testResult) {
                filtered.add(number);
            }
        }
        return filtered;
    }
}
```

#### 실행 결과
```
evenNumbers = [2, 4, 6, 8, 10]
oddNumbers = [1, 3, 5, 7, 9]
```
여기서는 filterEvenNumber() , filterOddNumber() 두 메서드를 각각 만들어서 문제를 해결했다.

### 문제
- FilterMainV1 클래스를 복사해서 FilterMainV2 클래스를 만들자.
- 앞서 작성한 filterEvenNumber() , filterOddNumber() 두 메서드 대신에 filter() 라는 하나의 메 서드만 사용해서 중복을 제거하자.
- 람다를 활용하자.

### 힌트
filterEvenNumber() , filterOddNumber() 에서 다른 부분은 다음 코드이다.
```
boolean testResult = number % 2 == 0; // filterEvenNumber()
boolean testResult = number % 2 == 1; // filterOddNumber()
```
- 이 코드 조각을 Predicate 로 전달해서 처리하면 된다.
- 변수가 Integer number 하나이고, 반환 타입이 boolean 이다.
  - Function<Integer, Boolean> 또는 Predicate<Integer> 를 선택하면 된다.
  - 조건이 맞는지 확인( test )하는 용도이므로 Predicate 가 더 적절하다.

## 필터2
```
package lambda.lambda5.filter;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Predicate;

public class FilterMainV2 {

    public static void main(String[] args) {
        List<Integer> numbers = List.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

        // 짝수만 거르기
        Predicate<Integer> evenPredicate = n -> n % 2 == 0;
        List<Integer> evenNumbers = filter(numbers, evenPredicate);
        System.out.println("evenNumbers = " + evenNumbers);

        // 홀수만 거르기
        Predicate<Integer> oddPredicate = n -> n % 2 == 1;
        List<Integer> oddNumbers = filter(numbers, oddPredicate);
        System.out.println("oddNumbers = " + oddNumbers);
    }

    static List<Integer> filter(List<Integer> numbers, Predicate<Integer> predicate) {
        List<Integer> filtered = new ArrayList<>();
        for (Integer number : numbers) {
            if (predicate.test(number)) {
                filtered.add(number);
            }
        }
        return filtered;
    }
}
```
- Predicate<Integer> 를 filter() 에 인자로 넘긴다.
  - 짝수: Predicate<Integer> evenPredicate = n -> n % 2 == 0
  - 홀수: Predicate<Integer> oddPredicate = n -> n % 2 == 1
- boolean testResult = predicate.test(number) 을 사용해서 넘긴 코드 조각을 filter() 안에서 실행한다.
  - for 루프를 통해 리스트 안에 있는 각각의 항목에 람다가 모두 적용된다.
  - 결과가 참이면 새로운 리스트에 담기고 거짓이면 새로운 리스트에 담기지 않는다.

#### 실행 결과
```
evenNumbers = [2, 4, 6, 8, 10]
oddNumbers = [1, 3, 5, 7, 9]
```

### 필터3
코드를 조금 다듬어보자.
```
package lambda.lambda5.filter;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Predicate;

public class FilterMainV3 {
    public static void main(String[] args) {
        List<Integer> numbers = List.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        
        // 짝수만 거르기
        List<Integer> evenNumbers = filter(numbers, n -> n % 2 == 0);
        System.out.println("evenNumbers = " + evenNumbers);
        
        // 홀수만 거르기
        List<Integer> oddNumbers = filter(numbers, n -> n % 2 == 1);
        System.out.println("oddNumbers = " + oddNumbers);
    }

    static List<Integer> filter(List<Integer> numbers, Predicate<Integer> predicate) {
        List<Integer> filtered = new ArrayList<>();
        for (Integer number : numbers) {
            if (predicate.test(number)) {
                filtered.add(number);
            }
        }
        return filtered;
    }
}
```
- evenPredicate , oddPredicate , testResult 변수를 제거했다.  
- 해당 변수들은 학습의 이해를 돕기 위해 만든 것으로 꼭 필요한 변수는 아니다.  
- 특히 람다의 경우 주로 간단한 식을 사용하므로, 복잡할 때를 제외하고는 변수를 잘 만들지 않는다.  
  - evenPredicate, oddPredicate 를 제거하니 가독성이 더 좋아진 것을 확인할 수 있다.  

## 필터 만들기2
앞서 맏든 filter() 메서드는 매개변수가 List<Integer> numbers, Predicate<Integer> predicate이다.  
따라서 숫자 리스트에 있는 값을 필터링 하는 모든 곳에서 사용할 수 있다.  
다양한 곳에서 활용할 수 있으므로, 별도의 유틸리티 클래스로 만들어보자  

### 필터4
```
package lambda.lambda5.filter;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Predicate;

public class IntegerFilter {
    public static List<Integer> filter(List<Integer> list, Predicate<Integer> predicate) {
        List<Integer> filtered = new ArrayList<>();
        for (Integer num : list) {
            if (predicate.test(num)) {
                filtered.add(num);
            }
        }
        return filtered;
    }
}
```
```
package lambda.lambda5.filter;

import java.util.List;

public class FilterMainV4 {
    public static void main(String[] args) {
        List<Integer> numbers = List.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

        // 짝수만 거르는 필터
        List<Integer> evenNumbers = IntegerFilter.filter(numbers, n -> n % 2 == 0);
        System.out.println("evenNumbers = " + evenNumbers);

        // 홀수만 거르는 필터
        List<Integer> oddNumbers = IntegerFilter.filter(numbers, n -> n % 2 == 1);
        System.out.println("oddNumbers = " + oddNumbers);
    }
}
```
#### 실행 결과
```
evenNumbers = [2, 4, 6, 8, 10]
oddNumbers = [1, 3, 5, 7, 9]
```
- 범용성 있게 다양한 곳에서 사용할 수 있는 IntegerFilter 클래스를 만들었다.
- 하지만 Integer 숫자에만 사용할 수 있는 한계가 있다.

### 필터5 - 제네릭 도입
제네릭을 사용하면 클래스 코드의 변경 없이 다양한 타입을 적용할 수 있다.  
앞서 만든 IntegerFilter 에 제네릭을 도입해보자.

```
package lambda.lambda5.filter;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Predicate;

public class GenericFilter {
    public static <T> List<T> filter(List<T> list, Predicate<T> predicate) {
        List<T> result = new ArrayList<>();
        for (T num : list) {
            if (predicate.test(num)) {
                result.add(num);
            }
        }
        return result;
    }
}
```
- 제네릭 <T> 를 선언하고, Integer 로 되어 있는 부분을 T 로 변경하면 된다.
```
package lambda.lambda5.filter;

import java.util.List;

public class FilterMainV5 {
    public static void main(String[] args) {
        // 숫자 사용 필터
        List<Integer> numbers = List.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        List<Integer> numbersResult = GenericFilter.filter(numbers, n -> n % 2 == 0);
        System.out.println("numbersResult = " + numbersResult); // [2, 4, 6, 8, 10]

        // 문자 사용 필터
        List<String> strings = List.of("A", "BB", "CCC");
        List<String> stringsResult = GenericFilter.filter(strings, s -> s.length() >= 2);
        System.out.println("stringsResult = " + stringsResult); // [BB, CCC]
    }
}
```
#### 실행 결과
```
numbersResult = [2, 4, 6, 8, 10]
stringsResult = [BB, CCC]
```
- 제네릭을 도입한 덕분에 Integer , String 같은 다양한 타입의 리스트에 필터링 기능을 사용할 수 있게 되었다.
- GenericFilter 는 제네릭을 사용할 수 있는 모든 타입의 리스트를 람다 조건으로 필터링 할 수 있다. 따라서  
  매우 유연한 필터링 기능을 제공한다.

## 맵 만들기1
맵(map)은 대응, 변환을 의미하는 매핑(mapping)의 줄임말이다.  
매핑은 어떤 것을 다른 것으로 변환하는 과정을 의미한다.  
프로그래밍에서는 각 요소를 다른 값으로 변환하는 작업을 매핑(mapping, map)이라 한다.  
쉽게 이야기해서 어떤 하나의 데이터를 다른 데이터로 변환하는 작업이라고 생각하면 된다.  

리스트에 있는 특정 값을 다른 값으로 매핑(변환)해보자.
### 맵1
```
package lambda.lambda5.map;

import java.util.ArrayList;
import java.util.List;

public class MapMainV1 {
    public static void main(String[] args) {
        List<String> list = List.of("1", "12", "123", "1234");

        // 문자열을 숫자로 변환
        List<Integer> numbers = mapStringToInteger(list);
        System.out.println("numbers = " + numbers);

        // 문자열의 길이
        List<Integer> lengths = mapStringToLength(list);
        System.out.println("lengths = " + lengths);
    }

    static List<Integer> mapStringToInteger(List<String> list) {
        List<Integer> numbers = new ArrayList<>();
        for (String s : list) {
            Integer value = Integer.valueOf(s);
            numbers.add(value);
        }
        return numbers;
    }

    static List<Integer> mapStringToLength(List<String> list) {
        List<Integer> numbers = new ArrayList<>();
        for (String s : list) {
            Integer value = s.length();
            numbers.add(value);
        }
        return numbers;
    }
}
```
#### 실행 결과
```
numbers = [1, 12, 123, 1234]
lengths = [1, 2, 3, 4]
```
- 문자열을 숫자로 변환
  - 리스트에 있는 문자( String ) "1", "12", "123", "1234"를 숫자( Integer ) 1, 12, 123, 1234로 변환했다.
- 문자열을 문자열의 길이로 변환
  - 리스트에 있는 문자( String ) "1", "12", "123", "1234"를 각 문자의 길이( Integer )인 1, 2, 3, 4로 변환했다.

### 문제
- MapMainV1 클래스를 복사해서 MapMainV2 클래스를 만들자.
- 앞서 작성한 mapStringToInteger() , mapStringToLength() 두 메서드 대신에 map() 이라는 하나의 메서드만 사용해서 중복을 제거하자.
- 람다를 활용하자.

### 힌트
mapStringToInteger() , mapStringToLength() 에서 다른 부분은 다음 코드이다.
```
Integer value = Integer.valueOf(s); // mapStringToInteger()
Integer value = s.length(); // mapStringToLength()
```
- 이 코드 조각을 람다로 전달해서 처리하면 된다.
- 변수가 String s 하나이고, 반환 타입이 Integer 이다.
  - Function<String, Integer> 를 선택하면 된다.

### 맵2
```