# ì„¹ì…˜1. ëŒë‹¤


## í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤
**í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤**ëŠ” ì •í™•íˆ í•˜ë‚˜ì˜ ì¶”ìƒ ë©”ì„œë“œë¥¼ ê°€ì§€ëŠ” ì¸í„°í˜ì´ìŠ¤ë¥¼ ë§í•œë‹¤.
ëŒë‹¤ëŠ” ì¶”ìƒ ë©”ì„œë“œê°€ í•˜ë‚˜ì¸ **í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤**ì—ë§Œ í• ë‹¹í•  ìˆ˜ ìˆë‹¤.
ë‹¨ì¼ ì¶”ìƒ ë©”ì„œë“œë¥¼ ì¤„ì—¬ì„œ **SAM**(Single Abstract Method)ì´ë¼ í•œë‹¤.
ì°¸ê³ ë¡œ ëŒë‹¤ëŠ” í´ë˜ìŠ¤, ì¶”ìƒ í´ë˜ìŠ¤ì—ëŠ” í• ë‹¹í•  ìˆ˜ ì—†ë‹¤. ì˜¤ì§ ë‹¨ì¼ ì¶”ìƒ ë©”ì„œë“œë¥¼ ê°€ì§€ëŠ” ì¸í„°í˜ì´ìŠ¤ì—ë§Œ í• ë‹¹í•  ìˆ˜ ìˆë‹¤.

#### ì—¬ëŸ¬ ì¶”ìƒ ë©”ì„œë“œ
```
package lambda.lambda1;

public interface NotSamInterface {
      void run();
      void go(); 
}
```
- ì¸í„°í˜ì´ìŠ¤ì˜ ë©”ì„œë“œ ì•ì—ëŠ” abstract (ì¶”ìƒ)ì´ ìƒëµë˜ì–´ ìˆë‹¤. (ìë°” ê¸°ë³¸!)
- ì—¬ê¸°ì—ëŠ” run() , go() ë‘ ê°œì˜ ì¶”ìƒ ë©”ì„œë“œê°€ ì„ ì–¸ë˜ì–´ ìˆë‹¤.
- ë‹¨ì¼ ì¶”ìƒ ë©”ì„œë“œ(SAM)ê°€ ì•„ë‹ˆë‹¤. ì´ ì¸í„°í˜ì´ìŠ¤ì—ëŠ” ëŒë‹¤ë¥¼ í• ë‹¹í•  ìˆ˜ ì—†ë‹¤.

#### ë‹¨ì¼ ì¶”ìƒ ë©”ì„œë“œ
```
package lambda.lambda1;
public interface SamInterface {
    void run();
}
```
- ì—¬ê¸°ì—ëŠ” run() í•œ ê°œì˜ ì¶”ìƒ ë©”ì„œë“œë§Œ ì„ ì–¸ë˜ì–´ ìˆë‹¤.
- ë‹¨ì¼ ì¶”ìƒ ë©”ì„œë“œ(SAM)ì´ë‹¤. ì´ ì¸í„°í˜ì´ìŠ¤ì—ëŠ” ëŒë‹¤ë¥¼ í• ë‹¹í•  ìˆ˜ ìˆë‹¤.
```
package lambda.lambda1;

public class SamMain {

    public static void main(String[] args) {
        SamInterface samInterface = () -> {
            System.out.println("sam");
        };

        samInterface.run();

        // ì»´íŒŒì¼ ì˜¤ë¥˜
        NotSamInterface notSamInterface = () -> {
            System.out.println("sam");
        };

        notSamInterface.go();
        notSamInterface.run();
    }
}
```
#### ì»´íŒŒì¼ ì˜¤ë¥˜ - ì‹¤í–‰ ê²°ê³¼
```
java: incompatible types: lambda.lambda1.NotSamInterface is not a functional 
interface
    multiple non-overriding abstract methods found in interface 
lambda.lambda1.NotSamInterface
```
- NotSamInterface ì´ í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ê°€ ì•„ë‹ˆë¼ëŠ” ì»´íŒŒì¼ ì˜¤ë¥˜ ë©”ì‹œì§€ê°€ ë‚˜ì˜¨ë‹¤.
- ì˜¤ë¥˜ë¥¼ í™•ì¸í–ˆìœ¼ë©´ ì»´íŒŒì¼ ì˜¤ë¥˜ ë¶€ë¶„ì„ ë‹¤ì‹œ ì£¼ì„ ì²˜ë¦¬í•˜ì.

#### ìë°”ëŠ” ì™œ ë‹¤ìŒ ì½”ë“œë¥¼ í—ˆìš©í•˜ì§€ ì•Šì„ê¹Œ?
```
NotSamInterface notSamInterface = () -> {
    System.out.println("not sam");
};

notSamInterface.go();
notSamInterface.run();
```
- ëŒë‹¤ëŠ” í•˜ë‚˜ì˜ í•¨ìˆ˜ì´ë‹¤. ë”°ë¼ì„œ ëŒë‹¤ë¥¼ ì¸í„°í˜ì´ìŠ¤ì— ë‹´ìœ¼ë ¤ë©´ í•˜ë‚˜ì˜ ë©”ì„œë“œ(í•¨ìˆ˜) ì„ ì–¸ë§Œ ì¡´ì¬í•´ì•¼ í•œë‹¤.
- ì¸í„°í˜ì´ìŠ¤ëŠ” ì—¬ëŸ¬ ë©”ì„œë“œ(í•¨ìˆ˜)ë¥¼ ì„ ì–¸í•  ìˆ˜ ìˆë‹¤. ì—¬ê¸°ì„œëŠ” run(), go() ë‘ ë©”ì„œë“œê°€ ì¡´ì¬í•œë‹¤.
- ì´ í•¨ìˆ˜ë¥¼ NoSamInterfaceì— ìˆëŠ” run() ë˜ëŠ” go() ë‘˜ ì¤‘ í•˜ë‚˜ì— í• ë‹¹í•´ì•¼ í•˜ëŠ” ë¬¸ì œê°€ ë°œìƒí•œë‹¤.

ìë°”ëŠ” ì´ëŸ¬í•œ ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´, ë‹¨ í•˜ë‚˜ì˜ ì¶”ìƒ ë©”ì„œë“œ(SAM: Single Abstract Method)ë§Œì„ í¬í•¨í•˜ëŠ” 
**í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ì—ë§Œ ëŒë‹¤ë¥¼ í• ë‹¹í•  ìˆ˜ ìˆë„ë¡ ì œí•œ**í–ˆë‹¤.
SamInterface ì€ run() ì´ë¼ëŠ” ë‹¨ í•˜ë‚˜ì˜ ì¶”ìƒ ë©”ì„œë“œë§Œì„ í¬í•¨í•œë‹¤. ë”°ë¼ì„œ ë¬¸ì œ ì—†ì´ ëŒë‹¤ë¥¼ í• ë‹¹í•˜ê³  ì‹¤í–‰í• 
ìˆ˜ ìˆë‹¤.

### @FunctionalInterface
```
public class Car {
    public void move() {
        System.out.println("ì°¨ë¥¼ ì´ë™í•©ë‹ˆë‹¤.");
    }
}
```

```
public class ElectricCar extends Car{

    @Override
    public void move() {
        System.out.println("ì „ê¸°ì°¨ë¥¼ ë¹ ë¥´ê²Œ ì´ë™í•©ë‹ˆë‹¤.");
    }

}
```
ë©”ì„œë“œë¥¼ ì¬ì •ì˜í•  ë•Œ ì‹¤ìˆ˜ë¡œ ì¬ì •ì˜í•  ë©”ì„œë“œ ì´ë¦„ì„ ë‹¤ë¥´ê²Œ ì ìœ¼ë©´ ì¬ì •ì˜ê°€ ë˜ì§€ ì•ŠëŠ”ë‹¤. ì´ ì˜ˆì œì—ì„œ ë¶€ëª¨ëŠ”
move() ì¸ë° ìì‹ì€ movee() ë¼ê³  e ë¥¼ í•˜ë‚˜ ë” ì˜ëª» ì ì—ˆë‹¤. ì´ëŸ° ë¬¸ì œë¥¼ ì»´íŒŒì¼ ë‹¨ê³„ì—ì„œ ì›ì²œì ìœ¼ë¡œ ë§‰ê¸° ìœ„í•´
@Override ì• ë…¸í…Œì´ì…˜ì„ ì‚¬ìš©í•œë‹¤. ì´ ì• ë…¸í…Œì´ì…˜ ë•ë¶„ì— ê°œë°œìê°€ í•  ìˆ˜ ìˆëŠ” ì‹¤ìˆ˜ë¥¼ ì»´íŒŒì¼ ë‹¨ê³„ì—ì„œ ë§‰ì„ ìˆ˜ ìˆ
ê³ , ë˜ ê°œë°œìëŠ” ì´ ë©”ì„œë“œê°€ ì¬ì •ì˜ ë©”ì„œë“œì¸ì§€ ëª…í™•í•˜ê²Œ ì¸ì§€í•  ìˆ˜ ìˆë‹¤.

í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ëŠ” ë‹¨ í•˜ë‚˜ì˜ ì¶”ìƒ ë©”ì„œë“œ(SAM: Single Abstract Method)ë§Œì„ í¬í•¨í•˜ëŠ” ì¸í„°í˜ì´ìŠ¤ì´ë‹¤.
ê·¸ë¦¬ê³  ëŒë‹¤ëŠ” í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ì—ë§Œ í• ë‹¹í•  ìˆ˜ ìˆë‹¤.
ê·¸ëŸ°ë° ë‹¨ í•˜ë‚˜ì˜ ì¶”ìƒ ë©”ì„œë“œë§Œì„ í¬í•¨í•œë‹¤ëŠ” ê²ƒì„ ì–´ë–»ê²Œ ë³´ì¥í•  ìˆ˜ ìˆì„ê¹Œ?
@FunctionalInterface ì• ë…¸í…Œì´ì…˜ì„ ë¶™ì—¬ì£¼ë©´ ëœë‹¤. ì´ ì• ë…¸í…Œì´ì…˜ì´ ìˆìœ¼ë©´ ë‹¨ í•˜ë‚˜ì˜ ì¶”ìƒ ë©”ì„œë“œê°€ ì•„ë‹ˆë©´
ì»´íŒŒì¼ ë‹¨ê³„ì—ì„œ ì˜¤ë¥˜ê°€ ë°œìƒí•œë‹¤. ë”°ë¼ì„œ í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ì„ì„ ë³´ì¥í•  ìˆ˜ ìˆë‹¤.

```
@FunctionalInterface // ì• ë…¸í…Œì´ì…˜ ì¶”ê°€
public interface SamInterface {
    void run();
}
```
- @FunctionalInterface ì„ í†µí•´ í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ì„ì„ ì„ ì–¸í•´ë‘ë©´, ì´í›„ì— ëˆ„êµ°ê°€ ì‹¤ìˆ˜ë¡œ 
  ì¶”ìƒ ë©”ì„œë“œë¥¼ ì¶”ê°€í•  ë•Œ ì»´íŒŒì¼ ì˜¤ë¥˜ê°€ ë°œìƒí•œë‹¤
```
@FunctionalInterface // ì• ë…¸í…Œì´ì…˜ ì¶”ê°€
public interface SamInterface {
    void run();
    void gogo(); // ì‹¤ìˆ˜ë¡œ ëˆ„êµ°ê°€ ì¶”ê°€ì‹œ ì»´íŒŒì¼ ì˜¤ë¥˜ ë°œìƒ
}
```
```
java: Unexpected @FunctionalInterface annotation
 lambda.lambda1.SamInterface is not a functional interface
 multiple non-overriding abstract methods found in interface 
lambda.lambda1.SamInterface
```
- í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ê°€ ì•„ë‹ˆë¼ëŠ” ì»´íŒŒì¼ ì˜¤ë¥˜ ë©”ì‹œì§€
- ì˜¤ë¥˜ë¥¼ í™•ì¸í–ˆìœ¼ë©´ gogo() ë©”ì„œë“œëŠ” ì‚­ì œí•˜ì

ë”°ë¼ì„œ ëŒë‹¤ë¥¼ ì‚¬ìš©í•  í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ë¼ë©´ @FunctionalInterface ë¥¼ í•„ìˆ˜ë¡œ ì¶”ê°€í•˜ëŠ” ê²ƒì„ ê¶Œì¥í•œë‹¤.

## ëŒë‹¤ì™€ ì‹œê·¸ë‹ˆì²˜
ëŒë‹¤ë¥¼ í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ì— í• ë‹¹í•  ë–„ëŠ” ë©”ì„œë“œì˜ í˜•íƒœë¥¼ ì •ì˜í•˜ëŠ” ìš”ì†Œì¸ ë©”ì„œë“œ ì‹œê·¸ë‹ˆì²˜ê°€ ë§ì•„ì•¼ í•œë‹¤.
ë©”ì„œë“œ ì‹œê·¸ë‹ˆì²˜ì˜ ì£¼ìš” êµ¬ì„± ìš”ì†ŒëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤.
1. ë©”ì„œë“œ ì´ë¦„
2. ë§¤ê°œë³€ìˆ˜ì˜ ìˆ˜ì™€ íƒ€ì…(ìˆœì„œ í¬í•¨)
3. ë°˜í™˜ íƒ€ì…

#### MyFucntion ì˜ˆì‹œ
ì˜ˆë¥¼ ë“¤ì–´ MyFucntionì˜ apply ë©”ì„œë“œë¥¼ ì‚´í´ë³´ì
```
@FunctionalInterface
public interface MyFunction {
    int apply(int a, int b);
}
```
ì´ ë©”ì„œë“œì˜ ì‹œê·¸ë‹ˆì²˜
- ì´ë¦„: apply
- ë§¤ê°œë³€ìˆ˜: int , int
- ë°˜í™˜ íƒ€ì…: int
```
MyFunction myFunction = (int a, int b) -> {
     return a + b;
};
```
ëŒë‹¤ëŠ” ìµëª… í•¨ìˆ˜ì´ë¯€ë¡œ ì‹œê·¸ë‹ˆì²˜ì—ì„œ ì´ë¦„ì€ ì œì™¸í•˜ê³ , **ë§¤ê°œë³€ìˆ˜, ë°˜í™˜ íƒ€ì…ì´ í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ì— ì„ ì–¸í•œ ë©”ì„œë“œì™€
ë§ì•„ì•¼ í•œë‹¤.**
ì´ ëŒë‹¤ëŠ” ë§¤ê°œë³€ìˆ˜ë¡œ int a , int b , ê·¸ë¦¬ê³  ë°˜í™˜ ê°’ìœ¼ë¡œ a + b ì¸ int íƒ€ì…ì„ ë°˜í™˜í•˜ë¯€ë¡œ ì‹œê·¸ë‹ˆì²˜ê°€ ë§ë‹¤. ë”°
ë¼ì„œ ëŒë‹¤ë¥¼ í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ì— í• ë‹¹í•  ìˆ˜ ìˆë‹¤.

ì°¸ê³ ë¡œ ëŒë‹¤ì˜ ë§¤ê°œë³€ìˆ˜ ì´ë¦„ì€ í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ì— ìˆëŠ” ë©”ì„œë“œ ë§¤ê°œë³€ìˆ˜ì˜ ì´ë¦„ê³¼ ìƒê´€ì—†ì´ ììœ ë¡­ê²Œ ì‘ì„±í•´ë„ ëœ
ë‹¤. íƒ€ì…ê³¼ ìˆœì„œë§Œ ë§ìœ¼ë©´ ëœë‹¤.
```
MyFunction myFunction = (int xxx, int yyy) -> {return xxx + yyy;};
```
#### Procedure ì˜ˆì‹œ
```
@FunctionalInterface
public interface Procedure {
    void run();
}
```
ì´ ë©”ì„œë“œì˜ ì‹œê·¸ë‹ˆì²˜
- ì´ë¦„: run
- ë§¤ê°œë³€ìˆ˜: ì—†ìŒ
- ë°˜í™˜ íƒ€ì…: ì—†ìŒ
```
Procedure procedure = () -> {
    System.out.println("hello! lambda");
};
```
ì´ ëŒë‹¤ëŠ” ë§¤ê°œë³€ìˆ˜ê°€ ì—†ê³ , ë°˜í™˜ íƒ€ì…ì´ ì—†ìœ¼ë¯€ë¡œ ì‹œê·¸ë‹ˆì²˜ê°€ ë§ë‹¤.   
ë”°ë¼ì„œ ëŒë‹¤ë¥¼ í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ì— í• ë‹¹í•  ìˆ˜ ìˆë‹¤.

## ëŒë‹¤ì™€ ìƒëµ
ëŒë‹¤ëŠ” ê°„ê²°í•œ ì½”ë“œ ì‘ì„±ì„ ìœ„í•´ ë‹¤ì–‘í•œ ë¬¸ë²• ìƒëµì„ ì§€ì›í•œë‹¤
#### ë‹¨ì¼ í‘œí˜„ì‹1
```
package lambda.lambda1;

import lambda.MyFunction;

public class LambdaSimple1 {
    public static void main(String[] args) {
        // ê¸°ë³¸
        MyFunction function1 = (int a, int b) -> {
            return a + b;
        };
        System.out.println("function1: " + function1.apply(1, 2));

        // ë‹¨ì¼ í‘œí˜„ì‹ì¸ ê²½ìš° ì¤‘ê´„í˜¸ì™€ ë¦¬í„´ ìƒëµ ê°€ëŠ¥
        MyFunction function2 = (int a, int b) -> a + b;
        System.out.println("function2: " + function2.apply(1, 2));

        // ë‹¨ì¼ í‘œí˜„ì‹ì´ ì•„ë‹ ê²½ìš° ì¤‘ê´„í˜¸ì™€ ë¦¬í„´ ëª¨ë‘ í•„ìˆ˜
        MyFunction function3 = (int a, int b) -> {
            System.out.println("ëŒë‹¤ ì‹¤í–‰");
            return a + b;
        };
        System.out.println("function3: " + function3.apply(1, 2));
    }
}
```
#### ì‹¤í–‰ ê²°ê³¼
```
function1: 3
function2: 3
ëŒë‹¤ ì‹¤í–‰
function3: 3
```

#### ìƒëµ ì „
```
(int a, int b) -> {return a + b;};
```
- a + b ì™€ ê°™ì´ ê°„ë‹¨í•œ ë‹¨ì¼ í‘œí˜„ì‹ì€ ì¤‘ê´„í˜¸( {} )ì™€ return ì„ í•¨ê»˜ ìƒëµí•  ìˆ˜ ìˆë‹¤.

#### ìƒëµ í›„
```
(int a, int b) -> a + b;
```
- ìƒëµí•œ ì½”ë“œëŠ” ìƒëµ ì „ ì½”ë“œì™€ ê°™ì€ ì½”ë“œì´ë‹¤. retrun ë¬¸ì´ ë³´ì´ì§€ ì•Šì§€ë§Œ ê²°ê³¼ë¥¼ ë°˜í™˜í•œë‹¤.

### í‘œí˜„ì‹(expression)ì´ë€?
- í•˜ë‚˜ì˜ ê°’ìœ¼ë¡œ í‰ê°€ë˜ëŠ” ì½”ë“œ ì¡°ê°ì„ ì˜ë¯¸í•œë‹¤.
- í‘œí˜„ì‹ì€ ì‚°ìˆ  ë…¼ë¦¬ í‘œí˜„ì‹, ë©”ì„œë“œ í˜¸ì¶œ, ê°ì²´ ìƒì„±ë“±ì´ ìˆë‹¤. 
  - ì˜ˆ) x + y , price * quantity , calculateTotal() , age >= 18
- í‘œí˜„ì‹ì´ ì•„ë‹Œê²ƒì€ ì œì–´ë¬¸, ë©”ì„œë“œ ì„ ì–¸ ê°™ì€ ê²ƒì´ ìˆë‹¤.
  - ì˜ˆ) if (condition) { }

### ëŒë‹¤ - ë‹¨ì¼ í‘œí˜„ì‹(single expression)ì¸ ê²½ìš°
- ì¤‘ê´„í˜¸ {}ì™€ return í‚¤ì›Œë“œë¥¼ í•¨ê»˜ ìƒëµí•  ìˆ˜ ìˆìŒ
  - í‘œí˜„ì‹ì˜ ê²°ê³¼ê°€ ìë™ìœ¼ë¡œ ë°˜í™˜ê°’ì´ ë¨
- ì¤‘ê´„í˜¸ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²½ìš°ì—ëŠ” ë°˜ë“œì‹œ retrun ë¬¸ì„ í¬í•¨í•´ì•¼ í•œë‹¤.
  - return ë¬¸ì„ ëª…ì‹œì ìœ¼ë¡œ í¬í•¨í•˜ëŠ” ê²½ìš° ì¤‘ê´„í˜¸ë¥¼ ì‚¬ìš©í•´ì•¼ í•œë‹¤.
  - ë°˜í™˜ íƒ€ì…ì´ void ì¸ ê²½ìš° return ìƒëµ ê°€ëŠ¥
#### ë‹¨ì¼ í‘œí˜„ì‹ì´ ì•„ë‹Œ ê²½ìš°
```
(int a, int b) -> {
    System.out.println("ëŒë‹¤ ì‹¤í–‰");
    return a + b;
};
```
- ë‹¨ì¼ í‘œí˜„ì‹ì´ ì•„ë‹Œ ê²½ìš° ì¤‘ê´„í˜¸( {} )ë¥¼ ìƒëµí•  ìˆ˜ ì—†ë‹¤. ì´ ê²½ìš° ë°˜í™˜ ê°’ì´ ìˆìœ¼ë©´ return ë¬¸ë„ í¬í•¨í•´ì•¼ í•œë‹¤.


### ë‹¨ì¼ í‘œí˜„ì‹2
ì´ë²ˆì—ëŠ” ë§¤ê°œë³€ìˆ˜ì™€ ë°˜í™˜ ê°’ì´ ì—†ëŠ” ê²½ìš°ë¥¼ ì‚´í´ë³´ì
```
package lambda.lambda1;

import lambda.Procedure;

public class LambdaSimple2 {
    public static void main(String[] args) {
        // ë§¤ê°œë³€ìˆ˜, ë°˜í™˜ ê°’ì´ ì—†ëŠ” ê²½ìš°
        Procedure procedure1 = () -> {
            System.out.println("hello! lambda");
        };
        procedure1.run();

        // ë‹¨ì¼ í‘œí˜„ì‹ì€ ì¤‘ê´„í˜¸ ìƒëµ ê°€ëŠ¥
        Procedure procedure2 = () -> System.out.println("hello! lambda");
        procedure2.run();
    }
}
```
#### ì‹¤í–‰ ê²°ê³¼
```
hello! lambda
hello! lambda
```

ë§¤ê°œë³€ìˆ˜ì™€ ë°˜í™˜ ê°’ì´ ì—†ëŠ” ê²½ìš°ë„ ë™ì¼í•˜ë‹¤.  
Procedure.run() ì˜ ê²½ìš° ë°˜í™˜ íƒ€ì…ì´ void ì´ê¸° ë•Œë¬¸ì— ì¤‘ê´„í˜¸ë¥¼ ì‚¬ìš©í•´ë„ return ì€ ìƒëµí•  ìˆ˜ ìˆë‹¤.

### íƒ€ì… ì¶”ë¡ 
ë‹¤ìŒê³¼ ê°™ì€ ëŒë‹¤ ì½”ë“œë¥¼ ì‘ì„±í•œë‹¤ê³  ìƒê°í•´ë³´ì.
```
MyFcuntion function1 = (int a, int b) -> a + b;
```
- ì—¬ê¸°ì„œ ë§¤ê°œë³€ìˆ˜ì— í•´ë‹¹í•˜ëŠ” (int a, int b) ë¶€ë¶„ì„ ì§‘ì¤‘í•´ë³´ì.
- í•¨ìˆ˜í˜• ì¸í„°íŒ¨ì´ìŠ¤ì¸ MyFcuntionì˜ apply() ë©”ì„œë“œë¥¼ ë³´ë©´ ì´ë¯¸ int a, int bë¡œ ë§¤ê°œë³€ìˆ˜ì˜ íƒ€ì…ì´
  ì •ì˜ë˜ì–´ ìˆë‹¤.
- ë”°ë¼ì„œ ì´ ì •ë³´ë¥¼ ì‚¬ìš©í•˜ë©´ ëŒë‹¤ì˜ (int a, int b) ì—ì„œ íƒ€ì… ì •ë³´ë¥¼ ìƒëµí•  ìˆ˜ ìˆë‹¤.
```
@FunctionalInterface
public interface MyFunction {
    int apply(int a, int b);
}
```
ë‹¤ìŒ ì˜ˆì œ ì½”ë“œë¡œ í™•ì¸í•´ë³´ì.
```
package lambda.lambda1;

import lambda.MyFunction;

public class LambdaSimple3 {
    public static void main(String[] args) {
        // íƒ€ì… ìƒëµ ì „
        MyFunction function1 = (int a, int b) -> a + b;

        // MyFunction íƒ€ì…ì„ í†µí•´ íƒ€ì… ì¶”ë¡  ê°€ëŠ¥, ëŒë‹¤ëŠ” íƒ€ì… ìƒëµ ê°€ëŠ¥
        MyFunction function2 = (a, b) -> a + b;

        int result = function2.apply(1, 2);
        System.out.println("result = " + result);
    }
}
```

#### ì‹¤í–‰ ê²°ê³¼
```
result = 3
```

#### íƒ€ì… ìƒëµ ì „í›„
```
MyFunction function1 = (int a, int b) -> a + b; // íƒ€ì… ì§ì ‘ ì…ë ¥
MyFunction function2 = (a, b) -> a + b; // íƒ€ì… ì¶”ë¡  ì‚¬ìš©
```
- ìë°” ì»´íŒŒì¼ëŸ¬ëŠ” ëŒë‹¤ê°€ ì‚¬ìš©ë˜ëŠ” í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ì˜ ë©”ì„œë“œ íƒ€ì…ì„ ê¸°ë°˜ìœ¼ë¡œ ëŒë‹¤ì˜ ë§¤ê°œë³€ìˆ˜ì™€ ë°˜í™˜ê°’ì˜  
  íƒ€ì…ì„ ì¶”ë¡ í•œë‹¤. ë”°ë¼ì„œ ëŒë‹¤ëŠ” íƒ€ì…ì„ ìƒëµí•  ìˆ˜ ìˆë‹¤.
- ë°˜í™˜ íƒ€ì…ì€ ë¬¸ë²•ì ìœ¼ë¡œ ëª…ì‹œí•  ìˆ˜ ì—†ë‹¤. ëŒ€ì‹ ì— ì»´íŒŒì¼ëŸ¬ê°€ ìë™ìœ¼ë¡œ ì¶”ë¡ í•œë‹¤.

### ë§¤ê°œë³€ìˆ˜ì˜ ê´„í˜¸ ìƒëµ
```
package lambda.lambda1;

public class LambdaSimple4 {
    public static void main(String[] args) {
        MyCall call1 = (int value) -> value * 2;    // ê¸°ë³¸
        MyCall call2 = (value) -> value * 2;        // íƒ€ì… ì¶”ë¡ 
        MyCall call3 = value -> value * 2;          // ë§¤ê°œë³€ìˆ˜ 1ê°œ, () ìƒëµ ê°€ëŠ¥

        System.out.println("call3 = " + call3.call(10));
    }

    interface MyCall {
        int call(int value);
    }
}
```
- ë§¤ê°œë³€ìˆ˜ê°€ ì •í™•íˆ í•˜ë‚˜ì´ë©´ì„œ, íƒ€ì…ì„ ìƒëµí•˜ê³ , ì´ë¦„ë§Œ ìˆëŠ” ê²½ìš° ì†Œê´„í˜¸ () ë¥¼ ìƒëµí•  ìˆ˜ ìˆë‹¤.
- ë§¤ê°œë³€ìˆ˜ê°€ ì—†ëŠ” ê²½ìš°ì—ëŠ” () ê°€ í•„ìˆ˜ì´ë‹¤.
- ë§¤ê°œë³€ìˆ˜ê°€ ë‘˜ ì´ìƒì´ë©´ () ê°€ í•„ìˆ˜ì´ë‹¤.

#### ì •ë¦¬
- **ë§¤ê°œë³€ìˆ˜ íƒ€ì…**: ìƒëµ ê°€ëŠ¥í•˜ì§€ë§Œ í•„ìš”í•˜ë‹¤ë©´ ëª…ì‹œì ìœ¼ë¡œ ì‘ì„±í•  ìˆ˜ ìˆë‹¤.
- **ë°˜í™˜ íƒ€ì…**: ë¬¸ë²•ì ìœ¼ë¡œ ëª…ì‹œí•  ìˆ˜ ì—†ê³ , ì‹ì˜ ê²°ê³¼ë¥¼ ë³´ê³  ì»´íŒŒì¼ëŸ¬ê°€ í•­ìƒ ì¶”ë¡ í•œë‹¤.
- ëŒë‹¤ëŠ” ë³´í†µ ê°„ëµí•˜ê²Œ ì‚¬ìš©í•˜ëŠ” ê²ƒì„ ê¶Œì¥í•œë‹¤.
  - ë‹¨ì¼ í‘œí˜„ì‹ì´ë©´ ì¤‘ê´„í˜¸ì™€ ë¦¬í„´ì„ ìƒëµí•˜ì.
  - íƒ€ì… ì¶”ë¡ ì„ í†µí•´ ë§¤ê°œë³€ìˆ˜ì˜ íƒ€ì…ì„ ìƒëµí•˜ì. (ì»´íŒŒì¼ëŸ¬ê°€ ì¶”ë¡ í•  ìˆ˜ ìˆë‹¤ë©´, ìƒëµí•˜ì)

## ëŒë‹¤ì˜ ì „ë‹¬
ëŒë‹¤ëŠ” í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ë¥¼ í†µí•´ ë³€ìˆ˜ì— ëŒ€ì…í•˜ê±°ë‚˜, ë©”ì„œë“œì— ì „ë‹¬í•˜ê±°ë‚˜ ë°˜í™˜í•  ìˆ˜ ìˆë‹¤.

### ëŒë‹¤ë¥¼ ë³€ìˆ˜ì— ëŒ€ì…í•˜ê¸°
```
package lambda.lambda2;

import lambda.MyFunction;

// 1. ëŒë‹¤ë¥¼ ë³€ìˆ˜ì— ëŒ€ì…í•˜ê¸°
public class LambdaPassMain1 {
    public static void main(String[] args) {
        MyFunction add = (a, b) -> a + b;
        MyFunction sub = (a, b) -> a - b;

        System.out.println("add.apply(1, 2) = " + add.apply(1, 2));
        System.out.println("sub.apply(1, 2) = " + sub.apply(1, 2));

        MyFunction cal = add;
        System.out.println("cal(add).apply(1, 2) = " + cal.apply(1, 2));

        cal = sub;
        System.out.println("cal(sub).apply(1, 2) = " + cal.apply(1, 2));
    }
}
```
#### ì‹¤í–‰ ê²°ê³¼
```
add.apply(1, 2) = 3
sub.apply(1, 2) = -1
cal(add).apply(1, 2) = 3
cal(sub).apply(1, 2) = -1
```
```
MyFunction add = (a, b) -> a + b;
```
- ì´ ëŒ€ì…ì‹ì—ì„œ ë³€ìˆ˜ addì˜ íƒ€ì…ì€ MyFunction í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ì´ë‹¤. ë”°ë¼ì„œ MyFunction í˜•ì‹ì— ë§ëŠ”  
  ëŒë‹¤ë¥¼ ëŒ€ì…í•  ìˆ˜ ìˆë‹¤.(ë©”ì„œë“œ ì‹œê·¸ë‹ˆì²˜ê°€ ì¼ì¹˜í•œë‹¤)

ìë°”ì—ì„œ ê¸°ë³¸í˜•ê³¼ ì°¸ì¡°í˜•ì€ ë‹¤ìŒê³¼ ê°™ì€ ë³€ìˆ˜ì— ê°’ì„ ëŒ€ì…í•  ìˆ˜ ìˆë‹¤.
#### ê¸°ë³¸í˜•ì˜ ê°’ ëŒ€ì…
```
int a = 10;
int c;
c = a;
```

#### ì°¸ì¡°í˜•ì˜ ê°’ ëŒ€ì…
```
Member newMember = new Member();
Member target;
target = newMember;
```
í´ë˜ìŠ¤ë‚˜ ì¸í„°í˜ì´ìŠ¤ë¡œ ì„ ì–¸í•œ ë³€ìˆ˜ì— ê°’ì„ ëŒ€ì…í•˜ëŠ” ê²ƒì€ ì¸ìŠ¤í„´ìŠ¤ì˜ ì°¸ì¡°ê°’ì„ ëŒ€ì…í•˜ëŠ” ê²ƒì´ë‹¤.

#### ëŒë‹¤ì˜ ëŒ€ì…
```
MyFunction add = (a, b) -> a + b;
MyFunction cal = add;
```
```
// ëŒë‹¤ì˜ ëŒ€ì… ë¶„ì„
MyFunction add = (a, b) -> a + b; // 1. ëŒë‹¤ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
MyFunction add = x001; // 2. ì°¸ì¡°ê°’ ë°˜í™˜, addì— x001 ëŒ€ì…
MyFunction cal = add;
MyFunction cal = x001; // 3. calì— ì°¸ì¡°ê°’ ëŒ€ì…
```
ëŒë‹¤ë„ ë§ˆì°¬ê°€ì§€ë‹¤. í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ë¡œ ì„ ì–¸í•œ ë³€ìˆ˜ì— ëŒë‹¤ë¥¼ ëŒ€ì…í•˜ëŠ” ê²ƒì€ ëŒë‹¤ ì¸ìŠ¤í„´ìŠ¤ì˜ ì°¸ì¡°ê°’ì„ ëŒ€ì…í•˜ëŠ” ê²ƒ
ì´ë‹¤.
ì´í•´ê°€ ì˜ ì•ˆëœë‹¤ë©´ ìµëª… í´ë˜ìŠ¤ì˜ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•˜ê³  ëŒ€ì…í•œë‹¤ê³  ìƒê°í•´ë³´ì.
ì°¸ê³ ë¡œ í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ë„ ì¸í„°í˜ì´ìŠ¤ì´ë‹¤.

ëŒë‹¤ë„ ì¸í„°í˜ì´ìŠ¤(í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤)ë¥¼ ì‚¬ìš©í•˜ë¯€ë¡œ, ëŒë‹¤ ì¸ìŠ¤í„´ìŠ¤ì˜ ì°¸ì¡°ê°’ì„ ë³€ìˆ˜ì— ì „ë‹¬í•  ìˆ˜ ìˆë‹¤.
ë³€ìˆ˜ì— ì°¸ì¡°ê°’ì„ ì „ë‹¬í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ ë‹¤ìŒê³¼ ê°™ì´ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.
- ë§¤ê°œë³€ìˆ˜ë¥¼ í†µí•´ ë©”ì„œë“œ(í•¨ìˆ˜)ì— ëŒë‹¤ë¥¼ ì „ë‹¬í•  ìˆ˜ ìˆë‹¤. (ì •í™•íˆëŠ” ëŒë‹¤ ì¸ìŠ¤í„´ìŠ¤ì˜ ì°¸ì¡°ê°’ì„ ì „ë‹¬)
- ë©”ì„œë“œê°€ ëŒë‹¤ë¥¼ ë°˜í™˜í•  ìˆ˜ ìˆë‹¤. (ì •í™•íˆëŠ” ëŒë‹¤ ì¸ìŠ¤í„´ìŠ¤ì˜ ì°¸ì¡°ê°’ì„ ë°˜í™˜)

### ëŒë‹¤ë¥¼ ë©”ì„œë“œ(í•¨ìˆ˜)ì— ì „ë‹¬í•˜ê¸°
ì•ì„œ ë³¸ ê²ƒê³¼ ê°™ì´ ëŒë‹¤ëŠ” ë³€ìˆ˜ì— ì „ë‹¬í•  ìˆ˜ ìˆë‹¤.  
ê°™ì€ ì›ë¦¬ë¡œ ëŒë‹¤ë¥¼ ë§¤ê°œë³€ìˆ˜ë¥¼ í†µí•´ ë©”ì„œë“œ(í•¨ìˆ˜)ì— ì „ë‹¬í•  ìˆ˜ ìˆë‹¤.
```
import lambda.MyFunction;

// 2. ëŒë‹¤ë¥¼ ë©”ì„œë“œ(í•¨ìˆ˜)ì— ì „ë‹¬í•˜ê¸°
public class LambdaPassMain2 {
    public static void main(String[] args) {
        MyFunction add = (a, b) -> a + b;
        MyFunction sub = (a, b) -> a - b;

        System.out.println("ë³€ìˆ˜ë¥¼ í†µí•´ ì „ë‹¬");
        calculate(add);
        calculate(sub);

        System.out.println("ëŒë‹¤ë¥¼ ì§ì ‘ ì „ë‹¬");
        calculate((a, b) -> a + b);
        calculate((a, b) -> a - b);
    }

    static void calculate(MyFunction function) {
        int a = 1;
        int b = 2;
        System.out.println("ê³„ì‚° ì‹œì‘");
        int result = function.apply(a, b);
        System.out.println("ê³„ì‚° ê²°ê³¼: " + result);
    }
}
```
#### ì‹¤í–‰ ê²°ê³¼
```
ë³€ìˆ˜ë¥¼ í†µí•´ ì „ë‹¬
ê³„ì‚° ì‹œì‘
ê³„ì‚° ê²°ê³¼: 3
ê³„ì‚° ì‹œì‘
ê³„ì‚° ê²°ê³¼: -1
ëŒë‹¤ë¥¼ ì§ì ‘ ì „ë‹¬
ê³„ì‚° ì‹œì‘
ê³„ì‚° ê²°ê³¼: 3
ê³„ì‚° ì‹œì‘
ê³„ì‚° ê²°ê³¼: -1
```
```

```
- calcualte() ë©”ì„œë“œì˜ ë§¤ê°œë³€ìˆ˜ëŠ” MyFucntion í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ì´ë‹¤. ë”°ë¼ì„œ ëŒë‹¤ë¥¼ ì „ë‹¬í•  ìˆ˜ ìˆë‹¤.
#### ëŒë‹¤ë¥¼ ë³€ìˆ˜ì— ë‹´ì€ í›„ì— ë§¤ê°œë³€ìˆ˜ì— ì „ë‹¬
```
MyFunction add = (a, b) -> a + b;
calculate(add);
```
```
// ëŒë‹¤ë¥¼ ë³€ìˆ˜ì— ë‹´ì€ í›„ì— ë§¤ê°œë³€ìˆ˜ì— ì „ë‹¬ ë¶„ì„
MyFunction add = (a, b) -> a + b; // 1. ëŒë‹¤ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
MyFunction add = x001; // 2. ì°¸ì¡°ê°’ ë°˜í™˜
add = x001; // 3. ì°¸ì¡°ê°’ ëŒ€ì…

calculate(add);
calculate(x001);

// ë©”ì„œë“œ í˜¸ì¶œ, ë§¤ê°œë³€ìˆ˜ì— ì°¸ì¡°ê°’ ëŒ€ì…
void calculate(MyFunction function = x001)
```

#### ëŒë‹¤ë¥¼ ì§ì ‘ ì „ë‹¬
```
calculate((a, b) -> a + b);
```
```
// ëŒë‹¤ë¥¼ ì§ì ‘ ì „ë‹¬ ë¶„ì„
calculate((a, b) -> a + b); // 1. ëŒë‹¤ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
calculate(x001); // 2. ì°¸ì¡°ê°’ ë°˜í™˜ ë° ë§¤ê°œë³€ìˆ˜ì— ì „ë‹¬

// ë©”ì„œë“œ í˜¸ì¶œ, ë§¤ê°œë³€ìˆ˜ì— ì°¸ì¡°ê°’ ëŒ€ì…
void calculate(MyFunction function = x001)
```
- ëŒë‹¤ ì¸ìŠ¤í„´ìŠ¤ì˜ ì°¸ì¡°ë¥¼ ë§¤ê°œë³€ìˆ˜ì— ì „ë‹¬í•˜ëŠ” ê²ƒì´ê¸° ë•Œë¬¸ì— ì´í•´í•˜ëŠ”ë° ì–´ë ¤ì›€ì€ ì—†ì„ ê²ƒì´ë‹¤.
- ì¼ë°˜ì ì¸ ì°¸ì¡°ë¥¼ ë§¤ê°œë³€ìˆ˜ì— ì „ë‹¬í•˜ëŠ” ê²ƒê³¼ ê°™ë‹¤.

#### ëŒë‹¤ë¡œ ë°”ê¾¸ê¸° ì „(ìµëª… í´ë˜ìŠ¤ ë²„ì „)
```
package lambda.lambda2;

import lambda.MyFunction;

public class LambdaPassMain3 {
    public static void main(String[] args) {
        MyFunction add = getOperation("add");
        System.out.println("add.apply(1, 2) = " + add.apply(1, 2));

        MyFunction sub = getOperation("sub");
        System.out.println("sub.apply(1, 2) = " + sub.apply(1, 2));

        MyFunction xxx = getOperation("xxx");
        System.out.println("xxx.apply(1, 2) = " + xxx.apply(1, 2));
    }

    // ëŒë‹¤ë¥¼ ë°˜í™˜í•˜ëŠ” ë©”ì„œë“œ
    static MyFunction getOperation(String operator) {
        switch (operator) {
            case "add":
                return new MyFunction() {
                    @Override
                    public int apply(int a, int b) {
                        return a + b;
                    }
                };
            case "sub":
                return new MyFunction() {
                    @Override
                    public int apply(int a, int b) {
                        return a - b;
                    }
                };
            default:
                return new MyFunction() {
                    @Override
                    public int apply(int a, int b) {
                        return 0;
                    }
                };
        }
    }
}
```


#### ëŒë‹¤ë¥¼ ë°˜í™˜í•˜ê¸°
```
package lambda.lambda2;

import lambda.MyFunction;

// 3. ëŒë‹¤ë¥¼ ë°˜í™˜í•˜ê¸°
public class LambdaPassMain3 {
    public static void main(String[] args) {
        MyFunction add = getOperation("add");
        System.out.println("add.apply(1, 2) = " + add.apply(1, 2));

        MyFunction sub = getOperation("sub");
        System.out.println("sub.apply(1, 2) = " + sub.apply(1, 2));

        MyFunction xxx = getOperation("xxx");
        System.out.println("xxx.apply(1, 2) = " + xxx.apply(1, 2));
    }

    // ëŒë‹¤ë¥¼ ë°˜í™˜í•˜ëŠ” ë©”ì„œë“œ
    static MyFunction getOperation(String operator) {
        switch (operator) {
            case "add":
                return (a, b) -> a + b;
            case "sub":
                return (a, b) -> a - b;
            default:
                return (a, b) -> 0;
        }
    }
}
```

#### ì‹¤í–‰ ê²°ê³¼
```
add.apply(1, 2) = 3
sub.apply(1, 2) = -1
xxx.apply(1, 2) = 0
```
```
MyFunction getOperation(String operator){}
```
- getOperation ë©”ì„œë“œëŠ” ë°˜í™˜ íƒ€ì…ì´ MyFunction í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ì´ë‹¤. ë”°ë¼ì„œ ëŒë‹¤ë¥¼ ë°˜í™˜í•  ìˆ˜ ìˆë‹¤.

#### ë¶„ì„
```
// 1. ë©”ì„œë“œë¥¼ í˜¸ì¶œí•œë‹¤.
MyFunction add = getOperation("add");

// 2. getOperation() ë©”ì„œë“œ ì•ˆì—ì„œ ë‹¤ìŒ ì½”ë“œê°€ í˜¸ì¶œëœë‹¤.
MyFunction getOperation(String operator) {} // ë°˜í™˜ íƒ€ì…ì´ MyFunction í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ì´ë‹¤.

return (a, b) -> a + b; // 2-1. ëŒë‹¤ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•œë‹¤.
return x001; // 2-2. ëŒë‹¤ ì¸ìŠ¤í„´ìŠ¤ì˜ ì°¸ì¡°ê°’ì„ ë°˜í™˜í•œë‹¤.

// 3. main ë©”ì„œë“œë¡œ ëŒë‹¤ ì¸ìŠ¤í„´ìŠ¤ì˜ ì°¸ì¡°ê°’ì´ ë°˜í™˜ëœë‹¤.
MyFunction add = x001; // 3-1. ëŒë‹¤ ì¸ìŠ¤í„´ìŠ¤ì˜ ì°¸ì¡°ê°’ì„ addì— ëŒ€ì…í•œë‹¤.
```

## ê³ ì°¨ í•¨ìˆ˜
ëŒë‹¤ì˜ ì „ë‹¬ ì •ë¦¬
ì•ì„œ ë°°ìš´ ë‚´ìš©ì„ ë‹¤ì‹œ í•œë²ˆ ì •ë¦¬í•´ë³´ì.
ëŒë‹¤ëŠ” í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„í•œ ìµëª… í´ë˜ìŠ¤ ì¸ìŠ¤í„´ìŠ¤ì™€ ê°™ì€ ê°œë…ìœ¼ë¡œ ì´í•´í•˜ë©´ ëœë‹¤. ì¦‰, ëŒë‹¤ë¥¼ ë³€ìˆ˜ì— ëŒ€ì…í•œë‹¤.
ëŠ” ê²ƒì€ ëŒë‹¤ ì¸ìŠ¤í„´ìŠ¤ì˜ ì°¸ì¡°ê°’ì„ ëŒ€ì…í•˜ëŠ” ê²ƒì´ê³ , ëŒë‹¤ë¥¼ ë©”ì„œë“œ(í•¨ìˆ˜)ì˜ ë§¤ê°œë³€ìˆ˜ë‚˜ ë°˜í™˜ê°’ìœ¼ë¡œ ë„˜ê¸´ë‹¤ëŠ” ê²ƒ ì—­ì‹œ  
**ëŒë‹¤ ì¸ìŠ¤í„´ìŠ¤ì˜ ì°¸ì¡°ê°’ì„ ì „ë‹¬, ë°˜í™˜**í•˜ëŠ” ê²ƒì´ë‹¤.

- **ëŒë‹¤ë¥¼ ë³€ìˆ˜ì— ëŒ€ì…**: MyFunction add = (a, b) -> a + b; ì²˜ëŸ¼ í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ íƒ€ì…ì˜ ë³€ìˆ˜ì— ëŒë‹¤   
  ì¸ìŠ¤í„´ìŠ¤ì˜ ì°¸ì¡°ë¥¼ ëŒ€ì…í•œë‹¤.
- **ëŒë‹¤ë¥¼ ë©”ì„œë“œ ë§¤ê°œë³€ìˆ˜ì— ì „ë‹¬**: ë©”ì„œë“œ í˜¸ì¶œ ì‹œ ëŒë‹¤ ì¸ìŠ¤í„´ìŠ¤ì˜ ì°¸ì¡°ë¥¼ ì§ì ‘ ë„˜ê¸°ê±°ë‚˜, ì´ë¯¸ ëŒë‹¤ ì¸ìŠ¤í„´ìŠ¤ë¥¼   
  ë‹´ê³  ìˆëŠ” ë³€ìˆ˜ë¥¼ ì „ë‹¬í•œë‹¤.

```
// ë³€ìˆ˜ì— ë‹´ì€ í›„ ì „ë‹¬
MyFunction add = (a, b) -> a + b;
calculate(add);

// ì§ì ‘ ì „ë‹¬
calculate((a, b) -> a + b);
```
- **ëŒë‹¤ë¥¼ ë©”ì„œë“œì—ì„œ ë°˜í™˜**: return (a, b) -> a + b; ì²˜ëŸ¼ í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ íƒ€ì…ì„ ë°˜í™˜ê°’ìœ¼ë¡œ ì§€ì •í•´  
  ëŒë‹¤ ì¸ìŠ¤í„´ìŠ¤ì˜ ì°¸ì¡°ë¥¼ ëŒë ¤ì¤„ ìˆ˜ ìˆë‹¤.

ì´ëŸ° ë°©ì‹ìœ¼ë¡œ ëŒë‹¤ë¥¼ ììœ ë¡­ê²Œ ì „ë‹¬í•˜ê±°ë‚˜ ë°˜í™˜í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì—, ì½”ë“œì˜ ê°„ê²°ì„±ê³¼ ìœ ì—°ì„±ì´ ë†’ì•„ì§„ë‹¤. ë§Œì•½ ìµëª…   
í´ë˜ìŠ¤ë¥¼ ì‘ì„±í•˜ê³  ì „ë‹¬í–ˆë‹¤ë©´ ë§¤ìš° ë²ˆì¡í–ˆì„ ê²ƒì´ë‹¤.

### ê³ ì°¨ í•¨ìˆ˜(Higher-Order Function)
ê³ ì°¨ í•¨ìˆ˜ëŠ” í•¨ìˆ˜ë¥¼ ê°’ì²˜ëŸ¼ ë‹¤ë£¨ëŠ” í•¨ìˆ˜ë¥¼ ëœ»í•œë‹¤.
ì¼ë°˜ì ìœ¼ë¡œ ë‹¤ìŒ ë‘ ê°€ì§€ ì¤‘ í•˜ë‚˜ë¥¼ ë§Œì¡±í•˜ë©´ ê³ ì°¨ í•¨ìˆ˜ë¼ í•œë‹¤.
- í•¨ìˆ˜ë¥¼ ì¸ìë¡œ ë°›ëŠ” í•¨ìˆ˜(ë©”ì„œë“œ)
- í•¨ìˆ˜ë¥¼ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜(ë©”ì„œë“œ)

#### í•¨ìˆ˜ë¥¼ ì¸ìë¡œ ë°›ëŠ” ê²½ìš°
```
// í•¨ìˆ˜(ëŒë‹¤)ë¥¼ ë§¤ê°œë³€ìˆ˜ë¡œ ë°›ìŒ
static void calculate(MyFunction function) {
    // ...
}
```

#### í•¨ìˆ˜ë¥¼ ë°˜í™˜í•˜ëŠ” ê²½ìš°
```
// í•¨ìˆ˜(ëŒë‹¤)ë¥¼ ë°˜í™˜
static MyFunction getOperation(String operator) {
    // ...
    return (a, b) -> a + b;
}
```
- ì¦‰, ë§¤ê°œë³€ìˆ˜ë‚˜ ë°˜í™˜ê°’ì— í•¨ìˆ˜(ë˜ëŠ” ëŒë‹¤)ë¥¼ í™œìš©í•˜ëŠ” í•¨ìˆ˜ê°€ ê³ ì°¨ í•¨ìˆ˜ì— í•´ë‹¹í•œë‹¤.
- ìë°”ì—ì„œ ëŒë‹¤(ìµëª… í•¨ìˆ˜)ëŠ” í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ë¥¼ í†µí•´ì„œë§Œ ì „ë‹¬í•  ìˆ˜ ìˆë‹¤.
- **ìë°”ì—ì„œ í•¨ìˆ˜ë¥¼ ì£¼ê³ ë°›ëŠ”ë‹¤ëŠ” ê²ƒ**ì€ "í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„í•œ ì–´ë–¤ ê°ì²´(ëŒë‹¤ë“  ìµëª… í´ë˜ìŠ¤ë“ )ë¥¼ ì£¼ê³ ë°›ëŠ”  
  ê²ƒ"ê³¼ ë™ì˜ì–´ì´ë‹¤. (í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ëŠ” ì¸í„°í˜ì´ìŠ¤ì´ë¯€ë¡œ ìµëª… í´ë˜ìŠ¤, ëŒë‹¤ ë‘˜ë‹¤ ëŒ€ì…í•  ìˆ˜ ìˆë‹¤. í•˜ì§€ë§Œ ì‹¤ì§ˆ  
  ì ìœ¼ë¡œ í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ì—ëŠ” ëŒë‹¤ë¥¼ ì£¼ë¡œ ì‚¬ìš©í•œë‹¤.)

### ìš©ì–´ - ê³ ì°¨ í•¨ìˆ˜
***ê³ ì°¨ í•¨ìˆ˜(Higher-Order Function)*** ë¼ëŠ” ì´ë¦„ì€ **í•¨ìˆ˜ë¥¼ ë‹¤ë£¨ëŠ” ì¶”ìƒí™” ìˆ˜ì¤€**ì´ ë” ë†’ë‹¤ëŠ” ë°ì—ì„œ ìœ ë˜í–ˆë‹¤.
- ë³´í†µì˜ (ì¼ë°˜ì ì¸) í•¨ìˆ˜ëŠ” **ë°ì´í„°(ê°’)**ë¥¼ ì…ë ¥ìœ¼ë¡œ ë°›ê³ , ê°’ì„ ë°˜í™˜í•œë‹¤.
- ì´ì— ë°˜í•´, ê³ ì°¨ í•¨ìˆ˜ëŠ” **í•¨ìˆ˜ë¥¼ ì¸ìë¡œ ë°›ê±°ë‚˜ í•¨ìˆ˜ë¥¼ ë°˜í™˜**í•œë‹¤.
- ì‰½ê²Œ ì´ì•¼ê¸°í•˜ë©´ ì¼ë°˜ í•¨ìˆ˜ëŠ” ê°’ì„ ë‹¤ë£¨ì§€ë§Œ, ê³ ì°¨ í•¨ìˆ˜ëŠ” í•¨ìˆ˜ ìì²´ë¥¼ ë‹¤ë£¬ë‹¤.

ì¦‰, "ê°’"ì„ ë‹¤ë£¨ëŠ” ê²ƒì„ ë„˜ì–´, "í•¨ìˆ˜"ë¼ëŠ” ê°œë… ìì²´ë¥¼ ê°’ì²˜ëŸ¼ ë‹¤ë£¬ë‹¤ëŠ” ì ì—ì„œ ì¶”ìƒí™”ì˜ ìˆ˜ì¤€(ê³„ì¸µ, order)ì´ í•œ ë‹¨ê³„
ë†’ì•„ì§„ë‹¤ê³  í•´ì„œ Higher-Order(ë” ë†’ì€ ì°¨ì›ì˜) í•¨ìˆ˜ë¼ê³  ë¶€ë¥¸ë‹¤.

## ë¬¸ì œì™€ í’€ì´1
### ë¬¸ì œ 1. ì¤‘ë³µë˜ëŠ” ë©”ì‹œì§€ ì¶œë ¥ ë¡œì§ ë¦¬íŒ©í† ë§
#### ë¬¸ì œ ì„¤ëª…

ë‹¤ìŒ ì½”ë“œëŠ” í™”ë©´ì— ì—¬ëŸ¬ ì¢…ë¥˜ì˜ ì¸ì‚¿ë§ ë©”ì‹œì§€ë¥¼ ì¶œë ¥í•˜ì§€ë§Œ, ëª¨ë“  ë©”ì„œë“œë§ˆë‹¤ === ì‹œì‘ === ê³¼ === ë === ì„ ì¶œë ¥í•˜ëŠ”   
ë¡œì§ì´ ì¤‘ë³µë˜ì–´ ìˆë‹¤. ì¤‘ë³µë˜ëŠ” ì½”ë“œë¥¼ ì œê±°í•˜ê³ , **ë³€í•˜ëŠ” ë¶€ë¶„(ì¸ì‚¿ë§ ë©”ì‹œì§€)** ë§Œ ë§¤ê°œë³€ìˆ˜ë¡œ ë°›ë„ë¡ ë¦¬íŒ©í† ë§ í•´ë¼.

#### ì˜ˆì‹œ ì½”ë“œ
```
package lambda.ex1;

public class M1Before {
    public static void greetMorning() {
        System.out.println("=== ì‹œì‘ ===");
        System.out.println("Good Morning!");
        System.out.println("=== ë ===");
    }

    public static void greetAfternoon() {
        System.out.println("=== ì‹œì‘ ===");
        System.out.println("Good Afternoon!");
        System.out.println("=== ë ===");
    }

    public static void greetEvening() {
        System.out.println("=== ì‹œì‘ ===");
        System.out.println("Good Evening!");
        System.out.println("=== ë ===");
    }

    public static void main(String[] args) {
        greetMorning();
        greetAfternoon();
        greetEvening();
    }
}
```
```
=== ì‹œì‘ ===
Good Morning!
=== ë ===
=== ì‹œì‘ ===
Good Afternoon!
=== ë ===
=== ì‹œì‘ ===
Good Evening!
=== ë ===
```

#### ì •ë‹µ
```
package lambda.ex1;

public class M1After {
    
    public static void greet(String message) {
        System.out.println("=== ì‹œì‘ ===");
        System.out.println(message);
        System.out.println("=== ë ===");
    }
    public static void main(String[] args) {
        greet("Good Morning!");
        greet("Good Afternoon!");
        greet("Good Evening!");
    }
}
```

### ë¬¸ì œ 2. ê°’ ë§¤ê°œë³€ìˆ˜í™” - ë‹¤ì–‘í•œ ë‹¨ìœ„ë¥¼ ë§¤ê°œë³€ìˆ˜ë¡œ ë°›ê¸°
#### ë¬¸ì œ ì„¤ëª…
ë‹¤ìŒ ì½”ë“œëŠ”, ì£¼ì–´ì§„ ìˆ«ì(ì˜ˆ: 10)ë¥¼ íŠ¹ì • ë‹¨ìœ„(ì˜ˆ: "kg")ë¡œ ì¶œë ¥í•˜ëŠ” ê°„ë‹¨í•œ ë©”ì„œë“œë¥¼ ì‘ì„±í•œ ì˜ˆì‹œì´ë‹¤.
ìˆ«ìì™€ ë‹¨ìœ„ë¥¼ ë‚˜ëˆ„ê³  ì¬ì‚¬ìš© ê°€ëŠ¥í•œ ë©”ì„œë“œë¥¼ ì‚¬ìš©í•˜ë„ë¡ ì½”ë“œë¥¼ ìˆ˜ì •í•´ë¼.

#### ì˜ˆì‹œ ì½”ë“œ
```
public class M2Before {
    public static void print1() {
        System.out.println("ë¬´ê²Œ: 10kg");
    }

    public static void print2() {
        System.out.println("ë¬´ê²Œ: 50kg");
    }

    public static void print3() {
        System.out.println("ë¬´ê²Œ: 200g");
    }

    public static void print4() {
        System.out.println("ë¬´ê²Œ: 40g");
    }

    public static void main(String[] args) {
        print1();
        print2();
        print3();
        print4();
    }
}
```
```
ë¬´ê²Œ: 10kg
ë¬´ê²Œ: 50kg
ë¬´ê²Œ: 200g
ë¬´ê²Œ: 40g
```
#### ì •ë‹µ
```
package lambda.ex1;

public class M2After {

    public static void print(int weight, String unit) {
        System.out.println("ë¬´ê²Œ: " + weight + unit);
    }
    public static void main(String[] args) {
        print(10, "kg");
        print(50, "kg");
        print(200, "g");
        print(40, "g");
    }
}
```

### ë¬¸ì œ 3. ë™ì‘ ë§¤ê°œë³€ìˆ˜í™” - ìµëª… í´ë˜ìŠ¤ë¡œ ë‹¤ë¥¸ ë¡œì§ ì „ë‹¬
#### ë¬¸ì œ ì„¤ëª…
1ë¶€í„° Nê¹Œì§€ ë”í•˜ëŠ” ë¡œì§ê³¼, ë°°ì—´ì„ ì •ë ¬í•˜ëŠ”( Arrays.sort() ) ë¡œì§ì„ ê°ê° ì‹¤í–‰í•˜ê³ , ì´ ë‘ ê°€ì§€ ë¡œì§ ëª¨ë‘   
"ì‹¤í–‰ì— ê±¸ë¦° ì‹œê°„ì„ ì¸¡ì •"í•˜ê³  ì‹¶ë‹¤.

- "ì‹¤í–‰ ì‹œê°„ ì¸¡ì •" ë¡œì§ì€ ë³€í•˜ì§€ ì•ŠëŠ” ë¶€ë¶„
- "ì‹¤í–‰í•  ë¡œì§"ì€ ë°”ë€ŒëŠ” ë¶€ë¶„(1ë¶€í„° N í•© êµ¬í•˜ê¸° vs ë°°ì—´ ì •ë ¬)

**ì´ ë¬¸ì œëŠ” ëŒë‹¤ë¥¼ ì‚¬ìš©í•˜ì§€ ë§ê³  ìµëª… í´ë˜ìŠ¤ë¥¼ ì‚¬ìš©í•´ì„œ í’€ì–´ë¼**

#### ë¬¸ì œ
1. ì•ì„œ ì •ì˜í•œ `Procedure` (ì¶”ìƒ ë©”ì„œë“œ `run()` ) í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ë¥¼ ì‚¬ìš©í•´ë¼.

2. `measure(Procedure p)` ë©”ì„œë“œ ì•ˆì—ì„œ
  - ì‹¤í–‰ ì „ ì‹œê°„ ê¸°ë¡
  - `p.run()` ì‹¤í–‰
  - ì‹¤í–‰ í›„ ì‹œê°„ ê¸°ë¡
  - ê±¸ë¦° ì‹œê°„ ì¶œë ¥
3. `main()` ì—ì„œ ìµëª… í´ë˜ìŠ¤ ë‘ ê°€ì§€ë¥¼ ë§Œë“¤ì–´ ê°ê° ì‹¤í–‰ ì‹œê°„ì„ ì¸¡ì •í•´ë¼.
  - (1) 1ë¶€í„° Nê¹Œì§€ í•©ì„ êµ¬í•˜ëŠ” ë¡œì§ ( `measure` ë©”ì„œë“œ í˜¸ì¶œ)
  - (2) ë°°ì—´ì„ ì •ë ¬í•˜ëŠ” ë¡œì§ ( `measure` ë©”ì„œë“œ í˜¸ì¶œ)
  - `measure` ë©”ì„œë“œëŠ” ì´ **2ë²ˆ** í˜¸ì¶œëœë‹¤.

#### (1) 1ë¶€í„° Nê¹Œì§€ í•©ì„ êµ¬í•˜ëŠ” ë¡œì§ ( measure ë©”ì„œë“œ í˜¸ì¶œ)
```
int N = 100;
long sum = 0;
for (int i = 1; i <= N; i++) {
   sum += i;
}
```
#### (2) ë°°ì—´ì„ ì •ë ¬í•˜ëŠ” ë¡œì§ ( measure ë©”ì„œë“œ í˜¸ì¶œ)
```
int[] arr = { 4, 3, 2, 1 };
System.out.println("ì›ë³¸ ë°°ì—´: " + Arrays.toString(arr));
Arrays.sort(arr);
System.out.println("ë°°ì—´ ì •ë ¬: " + Arrays.toString(arr));
```

#### ì˜ˆì‹œ ì¶œë ¥
```
[1ë¶€í„° 100ê¹Œì§€ í•©] ê²°ê³¼: 5050
ì‹¤í–‰ ì‹œê°„: 4592542ns
ì›ë³¸ ë°°ì—´: [4, 3, 2, 1]
ë°°ì—´ ì •ë ¬: [1, 2, 3, 4]
ì‹¤í–‰ ì‹œê°„: 301083ns
```

#### ì •ë‹µ
ì˜ˆì‹œ í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤
```
package lambda.ex1;

import lambda.Procedure;

import java.util.Arrays;

public class M3MeasureTime {

    // ê³µí†µ: ì‹¤í–‰ ì‹œê°„ ì¸¡ì • ë©”ì„œë“œ
    public static void measure(Procedure procedure) {
        long startNs = System.nanoTime();
        procedure.run();
        long endNs = System.nanoTime();
        System.out.println("ì‹¤í–‰ ì‹œê°„: " + (endNs - startNs) + "ns");
    }

    public static void main(String[] args) {
        // 1. ìµëª… í´ë˜ìŠ¤ë¡œ 1ë¶€í„° Nê¹Œì§€ í•©
        measure(new Procedure() {
            @Override
            public void run() {
                int N = 100;
                long sum = 0;
                for (int i = 0; i < N; i++) {
                    sum += i;

                }
                System.out.println("1[ë¶€í„° " + N + " ê¹Œì§€ í•©] ê²°ê³¼: "+ sum);
            }
        });

        // 2. ìµëª… í´ë˜ìŠ¤ë¡œ ë°°ì—´ ì •ë ¬
        measure(new Procedure() {
            @Override
            public void run() {
                int[] arr = {4, 3, 2, 1};
                System.out.println("ì›ë³¸ ë°°ì—´: " + Arrays.toString(arr));
                Arrays.sort(arr);
                System.out.println("ì›ë³¸ ë°°ì—´: " + Arrays.toString(arr));
            }
        });
    }
}
```

### ë¬¸ì œ 4. ëŒë‹¤ë¡œ ë³€ê²½ - ê°„ê²°í•˜ê²Œ ì½”ë“œ ì‘ì„±í•˜ê¸°
#### ë¬¸ì œ ì„¤ëª…
ì´ì „ ë¬¸ì œì—ì„œ ìµëª… í´ë˜ìŠ¤ë¡œ ì‘ì„±í•œ ë¶€ë¶„ì„ ëŒë‹¤ë¡œ ë³€ê²½í•´ë¼.
- measure() ë©”ì„œë“œì™€ Procedure ì¸í„°í˜ì´ìŠ¤ëŠ” ê·¸ëŒ€ë¡œ ë‘”ë‹¤.
- main() ì—ì„œ ìµëª… í´ë˜ìŠ¤ë¥¼ ì‚¬ìš©í•˜ì§€ ë§ê³ , ëŒë‹¤ë¥¼ ì´ìš©í•˜ì—¬ ë”ìš± ê°„ê²°í•˜ê²Œ ì½”ë“œë¥¼ ì‘ì„±í•´ë¼.

#### ì •ë‹µ
```
package lambda.ex1;

import lambda.Procedure;

import java.util.Arrays;

public class M4MeasureTime {

    // ê³µí†µ: ì‹¤í–‰ ì‹œê°„ ì¸¡ì • ë©”ì„œë“œ
    public static void measure(Procedure procedure) {
        long startNs = System.nanoTime();
        procedure.run();
        long endNs = System.nanoTime();
        System.out.println("ì‹¤í–‰ ì‹œê°„: " + (endNs - startNs) + "ns");
    }

    public static void main(String[] args) {
        // 1. ìµëª… í´ë˜ìŠ¤ë¡œ 1ë¶€í„° Nê¹Œì§€ í•©
        measure(() -> {
            int N = 100;
            long sum = 0;
            for (int i = 0; i < N; i++) {
                sum += i;

            }
            System.out.println("1[ë¶€í„° " + N + " ê¹Œì§€ í•©] ê²°ê³¼: " + sum);
        });

        // 2. ìµëª… í´ë˜ìŠ¤ë¡œ ë°°ì—´ ì •ë ¬
        measure(() -> {
            int[] arr = {4, 3, 2, 1};
            System.out.println("ì›ë³¸ ë°°ì—´: " + Arrays.toString(arr));
            Arrays.sort(arr);
            System.out.println("ì›ë³¸ ë°°ì—´: " + Arrays.toString(arr));

        });
    }
}
```

### ë¬¸ì œ 5. ê³ ì°¨ í•¨ìˆ˜(High-Order Function) - í•¨ìˆ˜ë¥¼ ë°˜í™˜í•˜ê¸°
#### ë¬¸ì œ ì„¤ëª…
"í•¨ìˆ˜ë¥¼ ë°˜í™˜"í•˜ëŠ” ë°©ì‹ë„ ì—°ìŠµí•´ë³´ì. ë‘ ì •ìˆ˜ë¥¼ ë°›ì•„ì„œ ì—°ì‚°í•˜ëŠ” MyFunction ì¸í„°í˜ì´ìŠ¤ë¥¼ ì‚¬ìš©í•´ë³´ì.
```
package lambda;

@FunctionalInterface
public interface MyFunction {
     int apply(int a, int b);
}
```
- static MyFunction getOperation(String operator) ë¼ëŠ” ì •ì  ë©”ì„œë“œë¥¼ ë§Œë“¤ì–´ë¼.
- ë§¤ê°œë³€ìˆ˜ì¸ operator ì— ë”°ë¼ ë‹¤ìŒê³¼ ê°™ì€ ë‚´ìš©ì„ ì „ë‹¬í•˜ê³  ë°˜í™˜í•´ë¼.
  - operator ê°€ "add"ë©´, (a, b) ë¥¼ ë°›ì•„ a + b ë¥¼ ë¦¬í„´í•˜ëŠ” ëŒë‹¤ë¥¼ ë°˜í™˜í•´ë¼.
  - "sub"ë©´, a - b ë¥¼ ë¦¬í„´í•˜ëŠ” ëŒë‹¤ë¥¼ ë°˜í™˜í•´ë¼.
  - ê·¸ ì™¸ì˜ ê²½ìš°ëŠ” í•­ìƒ 0ì„ ë¦¬í„´í•˜ëŠ” ëŒë‹¤ë¥¼ ë°˜í™˜í•´ë¼.
- main() ë©”ì„œë“œì—ì„œ getOperation("add") , getOperation("sub") , getOperation("xxx") ë¥¼
  ê°ê° í˜¸ì¶œí•´ì„œ ë°˜í™˜ëœ ëŒë‹¤ë¥¼ ì‹¤í–‰í•´ë¼.

#### ì˜ˆì‹œ ì¶œë ¥
```
add(1, 2) = 3
sub(1, 2) = -1
xxx(1, 2) = 0 // ê·¸ ì™¸ì˜ ê²½ìš°
```

#### ì •ë‹µ ì˜ˆì‹œ
```
package lambda.ex1;

import lambda.MyFunction;

public class M5Return {

    public static void main(String[] args) {
        MyFunction add = getOperation("add");
        System.out.println("add(1, 2) = " + add.apply(1, 2));

        MyFunction sub = getOperation("sub");
        System.out.println("sub.apply(1, 2) = " + sub.apply(1, 2));

        MyFunction xxx = getOperation("xxx");
        System.out.println("xxx.apply(1,2) = " + xxx.apply(1, 2));
    }

    public static MyFunction getOperation(String operator) {
        switch (operator) {
            case "add":
                return (a, b) -> a + b;
            case "sub":
                return (a, b) -> a - b;
            default:
                return (a, b) -> 0;  // ì˜ëª»ëœ ì—°ì‚°ìì¼ ê²½ìš° 0 ë°˜í™˜
        }
    }
}
```

> ğŸ’¡[ì´ê²ƒë§Œì€ ê¸°ì–µí•´ë‘ì!]
> sub.apply(1, 2).soutv ëª…ë ¹ì–´ì‹œ
> System.out.println("sub.apply(1, 2) = " + sub.apply(1, 2)); ìë™ì™„ì„±


## ë¬¸ì œì™€ í’€ì´2
ì´ë²ˆ ë¬¸ì œë“¤ì€ ì´í›„ì— ì„¤ëª…í•  ìŠ¤íŠ¸ë¦¼ì€ ë¬¼ë¡ ì´ê³ , í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì˜ ê°œë…ì„ ì´í•´í•˜ê¸° ìœ„í•´ **ë°˜ë“œì‹œ ë°˜ë³µí•´ì„œ 
í’€ì–´ë³´ê³ , ë˜ ì´í•´í•´ì•¼ í•œë‹¤.**
ì´ë²ˆ ë¬¸ì œë“¤ì€ ê³ ì°¨ í•¨ìˆ˜(Higher-Order Function) ê°œë…ì„ ì§ì ‘ ì‹¤ìŠµí•´ë³¼ ìˆ˜ ìˆë„ë¡ êµ¬ì„±í–ˆë‹¤. ê° ë¬¸ì œì—ì„œ ìš”êµ¬í•˜ëŠ”
í•µì‹¬ ì‚¬í•­ì€ "í•¨ìˆ˜ë¥¼ ë§¤ê°œë³€ìˆ˜ë¡œ ë°›ê±°ë‚˜, í•¨ìˆ˜ë¥¼ ë°˜í™˜" í•˜ëŠ” êµ¬ì¡°ë¥¼ êµ¬í˜„í•˜ëŠ” ê²ƒì´ë‹¤. ëŒë‹¤ê°€ ì•„ì§ ìµìˆ™í•˜ì§€ ì•Šì„ ê²ƒì´
ë‹ˆ ë¨¼ì € ìµëª… í´ë˜ìŠ¤ë¡œ êµ¬í˜„í•´ë³´ê³  ê·¸ ë‹¤ìŒì— ëŒë‹¤ë¡œ êµ¬í˜„í•´ë³´ì.

ì°¸ê³ : ê³ ì°¨ í•¨ìˆ˜(Higher-Order Function)ë€?
- í•¨ìˆ˜ë¥¼ ì¸ìë¡œ ë°›ê±°ë‚˜, í•¨ìˆ˜ë¥¼ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜
- ìë°”ì—ì„œëŠ” **í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤**ì— ìµëª… í´ë˜ìŠ¤ë‚˜ ëŒë‹¤ë¥¼ ë‹´ì•„ì„œ ì£¼ê³ ë°›ìŒìœ¼ë¡œì¨ ê³ ì°¨ í•¨ìˆ˜ë¥¼ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤.


### ë¬¸ì œ 1. filter í•¨ìˆ˜ êµ¬í˜„í•˜ê¸°
#### ìš”êµ¬ì‚¬í•­
1. ì •ìˆ˜ ë¦¬ìŠ¤íŠ¸ê°€ ì£¼ì–´ì¡Œì„ ë•Œ, íŠ¹ì • ì¡°ê±´ì— ë§ëŠ” ìš”ì†Œë“¤ë§Œ ë½‘ì•„ë‚´ëŠ” filter í•¨ìˆ˜ë¥¼ ì§ì ‘ ë§Œë“¤ì–´ë³´ì.
2. filter(List<Integer> list, MyPredicate predicate) í˜•ì‹ì˜ ì •ì  ë©”ì„œë“œë¥¼ í•˜ë‚˜ ì‘ì„±í•œë‹¤.
   MyPredicate ëŠ” í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ì´ë©°, boolean test(int value); ê°™ì€ ë©”ì„œë“œë¥¼ ê°€ì§„ë‹¤.
3. main() ì—ì„œ ì˜ˆì‹œë¡œ ë‹¤ìŒê³¼ ê°™ì€ ìƒí™©ì„ ì‹¤ìŠµí•´ë³´ì.
   ë¦¬ìŠ¤íŠ¸: [-3, -2, -1, 1, 2, 3, 5]
   ì¡°ê±´ 1: ìŒìˆ˜(negative)ë§Œ ê³¨ë¼ë‚´ê¸°
   ì¡°ê±´ 2: ì§ìˆ˜(even)ë§Œ ê³¨ë¼ë‚´ê¸°

#### ì—ì‹œ ì‹¤í–‰
```
ì›ë³¸ ë¦¬ìŠ¤íŠ¸: [-3, -2, -1, 1, 2, 3, 5]
ìŒìˆ˜ë§Œ: [-3, -2, -1]
ì§ìˆ˜ë§Œ: [-2, 2]
```
#### í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ ì˜ˆì‹œ
```
package lambda.ex2;

@FunctionalInterface
public interface MyPredicate {
    boolean test(int value);
}
```
#### ê¸°ë³¸ ì½”ë“œ ì˜ˆì‹œ
```
package lambda.ex2;

import java.util.ArrayList;
import java.util.List;

public class FilterExample {
    // ê³ ì°¨ í•¨ìˆ˜, í•¨ìˆ˜ë¥¼ ì¸ìë¡œ ë°›ì•„ì„œ ì¡°ê±´ì— ë§ëŠ” ìš”ì†Œë§Œ ë½‘ì•„ë‚´ëŠ” filter
    public static List<Integer> filter(List<Integer> list, MyPredicate predicate) {
        List<Integer> result = new ArrayList<>();
        for (int val : list) {
            if (predicate.test(val)) {
                result.add(val);
            }
        }
        return result;
    }

    public static void main(String[] args) {
        List<Integer> numbers = List.of(-3, -2, -1, 1, 2, 3, 5);
        System.out.println("ì›ë³¸ ë¦¬ìŠ¤íŠ¸: " + numbers);

        // 1. ìŒìˆ˜(negative)ë§Œ ë½‘ì•„ë‚´ê¸°
        // ì½”ë“œ ì‘ì„±

        // 2. ì§ìˆ˜(even)ë§Œ ë½‘ì•„ë‚´ê¸°
        // ì½”ë“œ ì‘ì„±
    }
}
```

#### ì •ë‹µ - ìµëª… í´ë˜ìŠ¤
```
package lambda.ex2;

import java.util.ArrayList;
import java.util.List;

public class FilterExampleEx1 {
    // ê³ ì°¨ í•¨ìˆ˜, í•¨ìˆ˜ë¥¼ ì¸ìë¡œ ë°›ì•„ì„œ ì¡°ê±´ì— ë§ëŠ” ìš”ì†Œë§Œ ë½‘ì•„ë‚´ëŠ” filter
    public static List<Integer> filter(List<Integer> list, MyPredicate predicate) {
        List<Integer> result = new ArrayList<>();
        for (int val : list) {
            if (predicate.test(val)) {
                result.add(val);
            }
        }
        return result;
    }

    public static void main(String[] args) {
        List<Integer> numbers = List.of(-3, -2, -1, 1, 2, 3, 5);
        System.out.println("ì›ë³¸ ë¦¬ìŠ¤íŠ¸: " + numbers);

        // 1. ìŒìˆ˜(negative)ë§Œ ë½‘ì•„ë‚´ê¸°
        List<Integer> negatives = filter(numbers, new MyPredicate() {
            @Override
            public boolean test(int value) {
                return value < 0;
            }
        });
        System.out.println("ìŒìˆ˜ë§Œ: " + negatives);

        // 2. ì§ìˆ˜(even)ë§Œ ë½‘ì•„ë‚´ê¸°
        List<Integer> evens = filter(numbers, new MyPredicate() {
            @Override
            public boolean test(int value) {
                return value % 2 == 0;
            }
        });
        System.out.println("ì§ìˆ˜ë§Œ: " + evens);
    }
}

```
#### ì •ë‹µ - ëŒë‹¤
```
package lambda.ex2;

import java.util.ArrayList;
import java.util.List;

public class FilterExampleEx2 {
    // ê³ ì°¨ í•¨ìˆ˜, í•¨ìˆ˜ë¥¼ ì¸ìë¡œ ë°›ì•„ì„œ ì¡°ê±´ì— ë§ëŠ” ìš”ì†Œë§Œ ë½‘ì•„ë‚´ëŠ” filter
    public static List<Integer> filter(List<Integer> list, MyPredicate predicate) {
        List<Integer> result = new ArrayList<>();
        for (int val : list) {
            if (predicate.test(val)) {
                result.add(val);
            }
        }
        return result;
    }

    public static void main(String[] args) {
        List<Integer> numbers = List.of(-3, -2, -1, 1, 2, 3, 5);
        System.out.println("ì›ë³¸ ë¦¬ìŠ¤íŠ¸: " + numbers);

        // 1. ìŒìˆ˜(negative)ë§Œ ë½‘ì•„ë‚´ê¸°
        // ì½”ë“œ ì‘ì„±
        List<Integer> negative = filter(numbers, value -> value < 0);
        System.out.println("ìŒìˆ˜ë§Œ = " + negative);

        // 2. ì§ìˆ˜(even)ë§Œ ë½‘ì•„ë‚´ê¸°
        // ì½”ë“œ ì‘ì„±
        List<Integer> even = filter(numbers, value -> value % 2 == 0);
        System.out.println("ì§ìˆ˜ë§Œ = " + even);
    }
}
```
