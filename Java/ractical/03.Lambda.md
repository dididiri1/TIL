# 섹션1. 람다


## 함수형 인터페이스
**함수형 인터페이스**는 정확히 하나의 추상 메서드를 가지는 인터페이스를 말한다.
람다는 추상 메서드가 하나인 **함수형 인터페이스**에만 할당할 수 있다.
단일 추상 메서드를 줄여서 **SAM**(Single Abstract Method)이라 한다.
참고로 람다는 클래스, 추상 클래스에는 할당할 수 없다. 오직 단일 추상 메서드를 가지는 인터페이스에만 할당할 수 있다.

#### 여러 추상 메서드
```
package lambda.lambda1;

public interface NotSamInterface {
      void run();
      void go(); 
}
```
- 인터페이스의 메서드 앞에는 abstract (추상)이 생략되어 있다. (자바 기본!)
- 여기에는 run() , go() 두 개의 추상 메서드가 선언되어 있다.
- 단일 추상 메서드(SAM)가 아니다. 이 인터페이스에는 람다를 할당할 수 없다.

#### 단일 추상 메서드
```
package lambda.lambda1;
public interface SamInterface {
    void run();
}
```
- 여기에는 run() 한 개의 추상 메서드만 선언되어 있다.
- 단일 추상 메서드(SAM)이다. 이 인터페이스에는 람다를 할당할 수 있다.
```
package lambda.lambda1;

public class SamMain {

    public static void main(String[] args) {
        SamInterface samInterface = () -> {
            System.out.println("sam");
        };

        samInterface.run();

        // 컴파일 오류
        NotSamInterface notSamInterface = () -> {
            System.out.println("sam");
        };

        notSamInterface.go();
        notSamInterface.run();
    }
}
```
#### 컴파일 오류 - 실행 결과
```
java: incompatible types: lambda.lambda1.NotSamInterface is not a functional 
interface
    multiple non-overriding abstract methods found in interface 
lambda.lambda1.NotSamInterface
```
- NotSamInterface 이 함수형 인터페이스가 아니라는 컴파일 오류 메시지가 나온다.
- 오류를 확인했으면 컴파일 오류 부분을 다시 주석 처리하자.

#### 자바는 왜 다음 코드를 허용하지 않을까?
```
NotSamInterface notSamInterface = () -> {
    System.out.println("not sam");
};

notSamInterface.go();
notSamInterface.run();
```
- 람다는 하나의 함수이다. 따라서 람다를 인터페이스에 담으려면 하나의 메서드(함수) 선언만 존재해야 한다.
- 인터페이스는 여러 메서드(함수)를 선언할 수 있다. 여기서는 run(), go() 두 메서드가 존재한다.
- 이 함수를 NoSamInterface에 있는 run() 또는 go() 둘 중 하나에 할당해야 하는 문제가 발생한다.

자바는 이러한 문제를 해결하기 위해, 단 하나의 추상 메서드(SAM: Single Abstract Method)만을 포함하는 
**함수형 인터페이스에만 람다를 할당할 수 있도록 제한**했다.
SamInterface 은 run() 이라는 단 하나의 추상 메서드만을 포함한다. 따라서 문제 없이 람다를 할당하고 실행할
수 있다.

### @FunctionalInterface
```
public class Car {
    public void move() {
        System.out.println("차를 이동합니다.");
    }
}
```

```
public class ElectricCar extends Car{

    @Override
    public void move() {
        System.out.println("전기차를 빠르게 이동합니다.");
    }

}
```
메서드를 재정의할 때 실수로 재정의할 메서드 이름을 다르게 적으면 재정의가 되지 않는다. 이 예제에서 부모는
move() 인데 자식은 movee() 라고 e 를 하나 더 잘못 적었다. 이런 문제를 컴파일 단계에서 원천적으로 막기 위해
@Override 애노테이션을 사용한다. 이 애노테이션 덕분에 개발자가 할 수 있는 실수를 컴파일 단계에서 막을 수 있
고, 또 개발자는 이 메서드가 재정의 메서드인지 명확하게 인지할 수 있다.

함수형 인터페이스는 단 하나의 추상 메서드(SAM: Single Abstract Method)만을 포함하는 인터페이스이다.
그리고 람다는 함수형 인터페이스에만 할당할 수 있다.
그런데 단 하나의 추상 메서드만을 포함한다는 것을 어떻게 보장할 수 있을까?
@FunctionalInterface 애노테이션을 붙여주면 된다. 이 애노테이션이 있으면 단 하나의 추상 메서드가 아니면
컴파일 단계에서 오류가 발생한다. 따라서 함수형 인터페이스임을 보장할 수 있다.

```
@FunctionalInterface // 애노테이션 추가
public interface SamInterface {
    void run();
}
```
- @FunctionalInterface 을 통해 함수형 인터페이스임을 선언해두면, 이후에 누군가 실수로 
  추상 메서드를 추가할 때 컴파일 오류가 발생한다
```
@FunctionalInterface // 애노테이션 추가
public interface SamInterface {
    void run();
    void gogo(); // 실수로 누군가 추가시 컴파일 오류 발생
}
```
```
java: Unexpected @FunctionalInterface annotation
 lambda.lambda1.SamInterface is not a functional interface
 multiple non-overriding abstract methods found in interface 
lambda.lambda1.SamInterface
```
- 함수형 인터페이스가 아니라는 컴파일 오류 메시지
- 오류를 확인했으면 gogo() 메서드는 삭제하자

따라서 람다를 사용할 함수형 인터페이스라면 @FunctionalInterface 를 필수로 추가하는 것을 권장한다.

## 람다와 시그니처
람다를 함수형 인터페이스에 할당할 떄는 메서드의 형태를 정의하는 요소인 메서드 시그니처가 맞아야 한다.
메서드 시그니처의 주요 구성 요소는 다음과 같다.
1. 메서드 이름
2. 매개변수의 수와 타입(순서 포함)
3. 반환 타입

#### MyFucntion 예시
예를 들어 MyFucntion의 apply 메서드를 살펴보자
```
@FunctionalInterface
public interface MyFunction {
    int apply(int a, int b);
}
```
이 메서드의 시그니처
- 이름: apply
- 매개변수: int , int
- 반환 타입: int
```
MyFunction myFunction = (int a, int b) -> {
     return a + b;
};
```
람다는 익명 함수이므로 시그니처에서 이름은 제외하고, **매개변수, 반환 타입이 함수형 인터페이스에 선언한 메서드와
맞아야 한다.**
이 람다는 매개변수로 int a , int b , 그리고 반환 값으로 a + b 인 int 타입을 반환하므로 시그니처가 맞다. 따
라서 람다를 함수형 인터페이스에 할당할 수 있다.

참고로 람다의 매개변수 이름은 함수형 인터페이스에 있는 메서드 매개변수의 이름과 상관없이 자유롭게 작성해도 된
다. 타입과 순서만 맞으면 된다.
```
MyFunction myFunction = (int xxx, int yyy) -> {return xxx + yyy;};
```
#### Procedure 예시
```
@FunctionalInterface
public interface Procedure {
    void run();
}
```
이 메서드의 시그니처
- 이름: run
- 매개변수: 없음
- 반환 타입: 없음
```
Procedure procedure = () -> {
    System.out.println("hello! lambda");
};
```
이 람다는 매개변수가 없고, 반환 타입이 없으므로 시그니처가 맞다.   
따라서 람다를 함수형 인터페이스에 할당할 수 있다.

## 람다와 생략
람다는 간결한 코드 작성을 위해 다양한 문법 생략을 지원한다
#### 단일 표현식1
```
package lambda.lambda1;

import lambda.MyFunction;

public class LambdaSimple1 {
    public static void main(String[] args) {
        // 기본
        MyFunction function1 = (int a, int b) -> {
            return a + b;
        };
        System.out.println("function1: " + function1.apply(1, 2));

        // 단일 표현식인 경우 중괄호와 리턴 생략 가능
        MyFunction function2 = (int a, int b) -> a + b;
        System.out.println("function2: " + function2.apply(1, 2));

        // 단일 표현식이 아닐 경우 중괄호와 리턴 모두 필수
        MyFunction function3 = (int a, int b) -> {
            System.out.println("람다 실행");
            return a + b;
        };
        System.out.println("function3: " + function3.apply(1, 2));
    }
}
```
#### 실행 결과
```
function1: 3
function2: 3
람다 실행
function3: 3
```

#### 생략 전
```
(int a, int b) -> {return a + b;};
```
- a + b 와 같이 간단한 단일 표현식은 중괄호( {} )와 return 을 함께 생략할 수 있다.

#### 생략 후
```
(int a, int b) -> a + b;
```
- 생략한 코드는 생략 전 코드와 같은 코드이다. retrun 문이 보이지 않지만 결과를 반환한다.

### 표현식(expression)이란?
- 하나의 값으로 평가되는 코드 조각을 의미한다.
- 표현식은 산술 논리 표현식, 메서드 호출, 객체 생성등이 있다. 
  - 예) x + y , price * quantity , calculateTotal() , age >= 18
- 표현식이 아닌것은 제어문, 메서드 선언 같은 것이 있다.
  - 예) if (condition) { }

### 람다 - 단일 표현식(single expression)인 경우
- 중괄호 {}와 return 키워드를 함께 생략할 수 있음
  - 표현식의 결과가 자동으로 반환값이 됨
- 중괄호를 사용하는 경우에는 반드시 retrun 문을 포함해야 한다.
  - return 문을 명시적으로 포함하는 경우 중괄호를 사용해야 한다.
  - 반환 타입이 void 인 경우 return 생략 가능
#### 단일 표현식이 아닌 경우
```
(int a, int b) -> {
    System.out.println("람다 실행");
    return a + b;
};
```
- 단일 표현식이 아닌 경우 중괄호( {} )를 생략할 수 없다. 이 경우 반환 값이 있으면 return 문도 포함해야 한다.


### 단일 표현식2
이번에는 매개변수와 반환 값이 없는 경우를 살펴보자
```
package lambda.lambda1;

import lambda.Procedure;

public class LambdaSimple2 {
    public static void main(String[] args) {
        // 매개변수, 반환 값이 없는 경우
        Procedure procedure1 = () -> {
            System.out.println("hello! lambda");
        };
        procedure1.run();

        // 단일 표현식은 중괄호 생략 가능
        Procedure procedure2 = () -> System.out.println("hello! lambda");
        procedure2.run();
    }
}
```
#### 실행 결과
```
hello! lambda
hello! lambda
```

매개변수와 반환 값이 없는 경우도 동일하다.  
Procedure.run() 의 경우 반환 타입이 void 이기 때문에 중괄호를 사용해도 return 은 생략할 수 있다.

### 타입 추론
다음과 같은 람다 코드를 작성한다고 생각해보자.
```
MyFcuntion function1 = (int a, int b) -> a + b;
```
- 여기서 매개변수에 해당하는 (int a, int b) 부분을 집중해보자.
- 함수형 인터패이스인 MyFcuntion의 apply() 메서드를 보면 이미 int a, int b로 매개변수의 타입이
  정의되어 있다.
- 따라서 이 정보를 사용하면 람다의 (int a, int b) 에서 타입 정보를 생략할 수 있다.
```
@FunctionalInterface
public interface MyFunction {
    int apply(int a, int b);
}
```
다음 예제 코드로 확인해보자.
```
package lambda.lambda1;

import lambda.MyFunction;

public class LambdaSimple3 {
    public static void main(String[] args) {
        // 타입 생략 전
        MyFunction function1 = (int a, int b) -> a + b;

        // MyFunction 타입을 통해 타입 추론 가능, 람다는 타입 생략 가능
        MyFunction function2 = (a, b) -> a + b;

        int result = function2.apply(1, 2);
        System.out.println("result = " + result);
    }
}
```

#### 실행 결과
```
result = 3
```

#### 타입 생략 전후
```
MyFunction function1 = (int a, int b) -> a + b; // 타입 직접 입력
MyFunction function2 = (a, b) -> a + b; // 타입 추론 사용
```
- 자바 컴파일러는 람다가 사용되는 함수형 인터페이스의 메서드 타입을 기반으로 람다의 매개변수와 반환값의  
  타입을 추론한다. 따라서 람다는 타입을 생략할 수 있다.
- 반환 타입은 문법적으로 명시할 수 없다. 대신에 컴파일러가 자동으로 추론한다.

### 매개변수의 괄호 생략
```
package lambda.lambda1;

public class LambdaSimple4 {
    public static void main(String[] args) {
        MyCall call1 = (int value) -> value * 2;    // 기본
        MyCall call2 = (value) -> value * 2;        // 타입 추론
        MyCall call3 = value -> value * 2;          // 매개변수 1개, () 생략 가능

        System.out.println("call3 = " + call3.call(10));
    }

    interface MyCall {
        int call(int value);
    }
}
```
- 매개변수가 정확히 하나이면서, 타입을 생략하고, 이름만 있는 경우 소괄호 () 를 생략할 수 있다.
- 매개변수가 없는 경우에는 () 가 필수이다.
- 매개변수가 둘 이상이면 () 가 필수이다.

#### 정리
- **매개변수 타입**: 생략 가능하지만 필요하다면 명시적으로 작성할 수 있다.
- **반환 타입**: 문법적으로 명시할 수 없고, 식의 결과를 보고 컴파일러가 항상 추론한다.
- 람다는 보통 간략하게 사용하는 것을 권장한다.
  - 단일 표현식이면 중괄호와 리턴을 생략하자.
  - 타입 추론을 통해 매개변수의 타입을 생략하자. (컴파일러가 추론할 수 있다면, 생략하자)

## 람다의 전달
람다는 함수형 인터페이스를 통해 변수에 대입하거나, 메서드에 전달하거나 반환할 수 있다.

### 람다를 변수에 대입하기
```
package lambda.lambda2;

import lambda.MyFunction;

// 1. 람다를 변수에 대입하기
public class LambdaPassMain1 {
    public static void main(String[] args) {
        MyFunction add = (a, b) -> a + b;
        MyFunction sub = (a, b) -> a - b;

        System.out.println("add.apply(1, 2) = " + add.apply(1, 2));
        System.out.println("sub.apply(1, 2) = " + sub.apply(1, 2));

        MyFunction cal = add;
        System.out.println("cal(add).apply(1, 2) = " + cal.apply(1, 2));

        cal = sub;
        System.out.println("cal(sub).apply(1, 2) = " + cal.apply(1, 2));
    }
}
```
#### 실행 결과
```
add.apply(1, 2) = 3
sub.apply(1, 2) = -1
cal(add).apply(1, 2) = 3
cal(sub).apply(1, 2) = -1
```
```
MyFunction add = (a, b) -> a + b;
```
- 이 대입식에서 변수 add의 타입은 MyFunction 함수형 인터페이스이다. 따라서 MyFunction 형식에 맞는  
  람다를 대입할 수 있다.(메서드 시그니처가 일치한다)

자바에서 기본형과 참조형은 다음과 같은 변수에 값을 대입할 수 있다.
#### 기본형의 값 대입
```
int a = 10;
int c;
c = a;
```

#### 참조형의 값 대입
```
Member newMember = new Member();
Member target;
target = newMember;
```
클래스나 인터페이스로 선언한 변수에 값을 대입하는 것은 인스턴스의 참조값을 대입하는 것이다.

#### 람다의 대입
```
MyFunction add = (a, b) -> a + b;
MyFunction cal = add;
```
```
// 람다의 대입 분석
MyFunction add = (a, b) -> a + b; // 1. 람다 인스턴스 생성
MyFunction add = x001; // 2. 참조값 반환, add에 x001 대입
MyFunction cal = add;
MyFunction cal = x001; // 3. cal에 참조값 대입
```
람다도 마찬가지다. 함수형 인터페이스로 선언한 변수에 람다를 대입하는 것은 람다 인스턴스의 참조값을 대입하는 것
이다.
이해가 잘 안된다면 익명 클래스의 인스턴스를 생성하고 대입한다고 생각해보자.
참고로 함수형 인터페이스도 인터페이스이다.

람다도 인터페이스(함수형 인터페이스)를 사용하므로, 람다 인스턴스의 참조값을 변수에 전달할 수 있다.
변수에 참조값을 전달할 수 있으므로 다음과 같이 사용할 수 있다.
- 매개변수를 통해 메서드(함수)에 람다를 전달할 수 있다. (정확히는 람다 인스턴스의 참조값을 전달)
- 메서드가 람다를 반환할 수 있다. (정확히는 람다 인스턴스의 참조값을 반환)

### 람다를 메서드(함수)에 전달하기
앞서 본 것과 같이 람다는 변수에 전달할 수 있다.  
같은 원리로 람다를 매개변수를 통해 메서드(함수)에 전달할 수 있다.
```
import lambda.MyFunction;

// 2. 람다를 메서드(함수)에 전달하기
public class LambdaPassMain2 {
    public static void main(String[] args) {
        MyFunction add = (a, b) -> a + b;
        MyFunction sub = (a, b) -> a - b;

        System.out.println("변수를 통해 전달");
        calculate(add);
        calculate(sub);

        System.out.println("람다를 직접 전달");
        calculate((a, b) -> a + b);
        calculate((a, b) -> a - b);
    }

    static void calculate(MyFunction function) {
        int a = 1;
        int b = 2;
        System.out.println("계산 시작");
        int result = function.apply(a, b);
        System.out.println("계산 결과: " + result);
    }
}
```
#### 실행 결과
```
변수를 통해 전달
계산 시작
계산 결과: 3
계산 시작
계산 결과: -1
람다를 직접 전달
계산 시작
계산 결과: 3
계산 시작
계산 결과: -1
```
```

```
- calcualte() 메서드의 매개변수는 MyFucntion 함수형 인터페이스이다. 따라서 람다를 전달할 수 있다.
#### 람다를 변수에 담은 후에 매개변수에 전달
```
MyFunction add = (a, b) -> a + b;
calculate(add);
```
```
// 람다를 변수에 담은 후에 매개변수에 전달 분석
MyFunction add = (a, b) -> a + b; // 1. 람다 인스턴스 생성
MyFunction add = x001; // 2. 참조값 반환
add = x001; // 3. 참조값 대입

calculate(add);
calculate(x001);

// 메서드 호출, 매개변수에 참조값 대입
void calculate(MyFunction function = x001)
```

#### 람다를 직접 전달
```
calculate((a, b) -> a + b);
```
```
// 람다를 직접 전달 분석
calculate((a, b) -> a + b); // 1. 람다 인스턴스 생성
calculate(x001); // 2. 참조값 반환 및 매개변수에 전달

// 메서드 호출, 매개변수에 참조값 대입
void calculate(MyFunction function = x001)
```
- 람다 인스턴스의 참조를 매개변수에 전달하는 것이기 때문에 이해하는데 어려움은 없을 것이다.
- 일반적인 참조를 매개변수에 전달하는 것과 같다.

#### 람다로 바꾸기 전(익명 클래스 버전)
```
package lambda.lambda2;

import lambda.MyFunction;

public class LambdaPassMain3 {
    public static void main(String[] args) {
        MyFunction add = getOperation("add");
        System.out.println("add.apply(1, 2) = " + add.apply(1, 2));

        MyFunction sub = getOperation("sub");
        System.out.println("sub.apply(1, 2) = " + sub.apply(1, 2));

        MyFunction xxx = getOperation("xxx");
        System.out.println("xxx.apply(1, 2) = " + xxx.apply(1, 2));
    }

    // 람다를 반환하는 메서드
    static MyFunction getOperation(String operator) {
        switch (operator) {
            case "add":
                return new MyFunction() {
                    @Override
                    public int apply(int a, int b) {
                        return a + b;
                    }
                };
            case "sub":
                return new MyFunction() {
                    @Override
                    public int apply(int a, int b) {
                        return a - b;
                    }
                };
            default:
                return new MyFunction() {
                    @Override
                    public int apply(int a, int b) {
                        return 0;
                    }
                };
        }
    }
}
```


#### 람다를 반환하기
```
package lambda.lambda2;

import lambda.MyFunction;

// 3. 람다를 반환하기
public class LambdaPassMain3 {
    public static void main(String[] args) {
        MyFunction add = getOperation("add");
        System.out.println("add.apply(1, 2) = " + add.apply(1, 2));

        MyFunction sub = getOperation("sub");
        System.out.println("sub.apply(1, 2) = " + sub.apply(1, 2));

        MyFunction xxx = getOperation("xxx");
        System.out.println("xxx.apply(1, 2) = " + xxx.apply(1, 2));
    }

    // 람다를 반환하는 메서드
    static MyFunction getOperation(String operator) {
        switch (operator) {
            case "add":
                return (a, b) -> a + b;
            case "sub":
                return (a, b) -> a - b;
            default:
                return (a, b) -> 0;
        }
    }
}
```

#### 실행 결과
```
add.apply(1, 2) = 3
sub.apply(1, 2) = -1
xxx.apply(1, 2) = 0
```
```
MyFunction getOperation(String operator){}
```
- getOperation 메서드는 반환 타입이 MyFunction 함수형 인터페이스이다. 따라서 람다를 반환할 수 있다.

#### 분석
```
// 1. 메서드를 호출한다.
MyFunction add = getOperation("add");

// 2. getOperation() 메서드 안에서 다음 코드가 호출된다.
MyFunction getOperation(String operator) {} // 반환 타입이 MyFunction 함수형 인터페이스이다.

return (a, b) -> a + b; // 2-1. 람다 인스턴스를 생성한다.
return x001; // 2-2. 람다 인스턴스의 참조값을 반환한다.

// 3. main 메서드로 람다 인스턴스의 참조값이 반환된다.
MyFunction add = x001; // 3-1. 람다 인스턴스의 참조값을 add에 대입한다.
```

## 고차 함수
람다의 전달 정리
앞서 배운 내용을 다시 한번 정리해보자.
람다는 함수형 인터페이스를 구현한 익명 클래스 인스턴스와 같은 개념으로 이해하면 된다. 즉, 람다를 변수에 대입한다.
는 것은 람다 인스턴스의 참조값을 대입하는 것이고, 람다를 메서드(함수)의 매개변수나 반환값으로 넘긴다는 것 역시  
**람다 인스턴스의 참조값을 전달, 반환**하는 것이다.

- **람다를 변수에 대입**: MyFunction add = (a, b) -> a + b; 처럼 함수형 인터페이스 타입의 변수에 람다   
  인스턴스의 참조를 대입한다.
- **람다를 메서드 매개변수에 전달**: 메서드 호출 시 람다 인스턴스의 참조를 직접 넘기거나, 이미 람다 인스턴스를   
  담고 있는 변수를 전달한다.

```
// 변수에 담은 후 전달
MyFunction add = (a, b) -> a + b;
calculate(add);

// 직접 전달
calculate((a, b) -> a + b);
```
- **람다를 메서드에서 반환**: return (a, b) -> a + b; 처럼 함수형 인터페이스 타입을 반환값으로 지정해  
  람다 인스턴스의 참조를 돌려줄 수 있다.

이런 방식으로 람다를 자유롭게 전달하거나 반환할 수 있기 때문에, 코드의 간결성과 유연성이 높아진다. 만약 익명   
클래스를 작성하고 전달했다면 매우 번잡했을 것이다.

### 고차 함수(Higher-Order Function)
고차 함수는 함수를 값처럼 다루는 함수를 뜻한다.
일반적으로 다음 두 가지 중 하나를 만족하면 고차 함수라 한다.
- 함수를 인자로 받는 함수(메서드)
- 함수를 반환하는 함수(메서드)

#### 함수를 인자로 받는 경우
```
// 함수(람다)를 매개변수로 받음
static void calculate(MyFunction function) {
    // ...
}
```

#### 함수를 반환하는 경우
```
// 함수(람다)를 반환
static MyFunction getOperation(String operator) {
    // ...
    return (a, b) -> a + b;
}
```
- 즉, 매개변수나 반환값에 함수(또는 람다)를 활용하는 함수가 고차 함수에 해당한다.
- 자바에서 람다(익명 함수)는 함수형 인터페이스를 통해서만 전달할 수 있다.
- **자바에서 함수를 주고받는다는 것**은 "함수형 인터페이스를 구현한 어떤 객체(람다든 익명 클래스든)를 주고받는  
  것"과 동의어이다. (함수형 인터페이스는 인터페이스이므로 익명 클래스, 람다 둘다 대입할 수 있다. 하지만 실질  
  적으로 함수형 인터페이스에는 람다를 주로 사용한다.)

### 용어 - 고차 함수
***고차 함수(Higher-Order Function)*** 라는 이름은 **함수를 다루는 추상화 수준**이 더 높다는 데에서 유래했다.
- 보통의 (일반적인) 함수는 **데이터(값)**를 입력으로 받고, 값을 반환한다.
- 이에 반해, 고차 함수는 **함수를 인자로 받거나 함수를 반환**한다.
- 쉽게 이야기하면 일반 함수는 값을 다루지만, 고차 함수는 함수 자체를 다룬다.

즉, "값"을 다루는 것을 넘어, "함수"라는 개념 자체를 값처럼 다룬다는 점에서 추상화의 수준(계층, order)이 한 단계
높아진다고 해서 Higher-Order(더 높은 차원의) 함수라고 부른다.

## 문제와 풀이1
### 문제 1. 중복되는 메시지 출력 로직 리팩토링
#### 문제 설명

다음 코드는 화면에 여러 종류의 인삿말 메시지를 출력하지만, 모든 메서드마다 === 시작 === 과 === 끝 === 을 출력하는   
로직이 중복되어 있다. 중복되는 코드를 제거하고, **변하는 부분(인삿말 메시지)** 만 매개변수로 받도록 리팩토링 해라.

#### 예시 코드
```
package lambda.ex1;

public class M1Before {
    public static void greetMorning() {
        System.out.println("=== 시작 ===");
        System.out.println("Good Morning!");
        System.out.println("=== 끝 ===");
    }

    public static void greetAfternoon() {
        System.out.println("=== 시작 ===");
        System.out.println("Good Afternoon!");
        System.out.println("=== 끝 ===");
    }

    public static void greetEvening() {
        System.out.println("=== 시작 ===");
        System.out.println("Good Evening!");
        System.out.println("=== 끝 ===");
    }

    public static void main(String[] args) {
        greetMorning();
        greetAfternoon();
        greetEvening();
    }
}
```
```
=== 시작 ===
Good Morning!
=== 끝 ===
=== 시작 ===
Good Afternoon!
=== 끝 ===
=== 시작 ===
Good Evening!
=== 끝 ===
```

#### 정답
```
package lambda.ex1;

public class M1After {
    
    public static void greet(String message) {
        System.out.println("=== 시작 ===");
        System.out.println(message);
        System.out.println("=== 끝 ===");
    }
    public static void main(String[] args) {
        greet("Good Morning!");
        greet("Good Afternoon!");
        greet("Good Evening!");
    }
}
```

### 문제 2. 값 매개변수화 - 다양한 단위를 매개변수로 받기
#### 문제 설명
다음 코드는, 주어진 숫자(예: 10)를 특정 단위(예: "kg")로 출력하는 간단한 메서드를 작성한 예시이다.
숫자와 단위를 나누고 재사용 가능한 메서드를 사용하도록 코드를 수정해라.

#### 예시 코드
```
public class M2Before {
    public static void print1() {
        System.out.println("무게: 10kg");
    }

    public static void print2() {
        System.out.println("무게: 50kg");
    }

    public static void print3() {
        System.out.println("무게: 200g");
    }

    public static void print4() {
        System.out.println("무게: 40g");
    }

    public static void main(String[] args) {
        print1();
        print2();
        print3();
        print4();
    }
}
```
```
무게: 10kg
무게: 50kg
무게: 200g
무게: 40g
```
#### 정답
```
package lambda.ex1;

public class M2After {

    public static void print(int weight, String unit) {
        System.out.println("무게: " + weight + unit);
    }
    public static void main(String[] args) {
        print(10, "kg");
        print(50, "kg");
        print(200, "g");
        print(40, "g");
    }
}
```

### 문제 3. 동작 매개변수화 - 익명 클래스로 다른 로직 전달
#### 문제 설명
1부터 N까지 더하는 로직과, 배열을 정렬하는( Arrays.sort() ) 로직을 각각 실행하고, 이 두 가지 로직 모두   
"실행에 걸린 시간을 측정"하고 싶다.

- "실행 시간 측정" 로직은 변하지 않는 부분
- "실행할 로직"은 바뀌는 부분(1부터 N 합 구하기 vs 배열 정렬)

**이 문제는 람다를 사용하지 말고 익명 클래스를 사용해서 풀어라**

#### 문제
1. 앞서 정의한 `Procedure` (추상 메서드 `run()` ) 함수형 인터페이스를 사용해라.

2. `measure(Procedure p)` 메서드 안에서
  - 실행 전 시간 기록
  - `p.run()` 실행
  - 실행 후 시간 기록
  - 걸린 시간 출력
3. `main()` 에서 익명 클래스 두 가지를 만들어 각각 실행 시간을 측정해라.
  - (1) 1부터 N까지 합을 구하는 로직 ( `measure` 메서드 호출)
  - (2) 배열을 정렬하는 로직 ( `measure` 메서드 호출)
  - `measure` 메서드는 총 **2번** 호출된다.

#### (1) 1부터 N까지 합을 구하는 로직 ( measure 메서드 호출)
```
int N = 100;
long sum = 0;
for (int i = 1; i <= N; i++) {
   sum += i;
}
```
#### (2) 배열을 정렬하는 로직 ( measure 메서드 호출)
```
int[] arr = { 4, 3, 2, 1 };
System.out.println("원본 배열: " + Arrays.toString(arr));
Arrays.sort(arr);
System.out.println("배열 정렬: " + Arrays.toString(arr));
```

#### 예시 출력
```
[1부터 100까지 합] 결과: 5050
실행 시간: 4592542ns
원본 배열: [4, 3, 2, 1]
배열 정렬: [1, 2, 3, 4]
실행 시간: 301083ns
```

#### 정답
예시 함수형 인터페이스
```
package lambda.ex1;

import lambda.Procedure;

import java.util.Arrays;

public class M3MeasureTime {

    // 공통: 실행 시간 측정 메서드
    public static void measure(Procedure procedure) {
        long startNs = System.nanoTime();
        procedure.run();
        long endNs = System.nanoTime();
        System.out.println("실행 시간: " + (endNs - startNs) + "ns");
    }

    public static void main(String[] args) {
        // 1. 익명 클래스로 1부터 N까지 합
        measure(new Procedure() {
            @Override
            public void run() {
                int N = 100;
                long sum = 0;
                for (int i = 0; i < N; i++) {
                    sum += i;

                }
                System.out.println("1[부터 " + N + " 까지 합] 결과: "+ sum);
            }
        });

        // 2. 익명 클래스로 배열 정렬
        measure(new Procedure() {
            @Override
            public void run() {
                int[] arr = {4, 3, 2, 1};
                System.out.println("원본 배열: " + Arrays.toString(arr));
                Arrays.sort(arr);
                System.out.println("원본 배열: " + Arrays.toString(arr));
            }
        });
    }
}
```

### 문제 4. 람다로 변경 - 간결하게 코드 작성하기
#### 문제 설명
이전 문제에서 익명 클래스로 작성한 부분을 람다로 변경해라.
- measure() 메서드와 Procedure 인터페이스는 그대로 둔다.
- main() 에서 익명 클래스를 사용하지 말고, 람다를 이용하여 더욱 간결하게 코드를 작성해라.

#### 정답
```
package lambda.ex1;

import lambda.Procedure;

import java.util.Arrays;

public class M4MeasureTime {

    // 공통: 실행 시간 측정 메서드
    public static void measure(Procedure procedure) {
        long startNs = System.nanoTime();
        procedure.run();
        long endNs = System.nanoTime();
        System.out.println("실행 시간: " + (endNs - startNs) + "ns");
    }

    public static void main(String[] args) {
        // 1. 익명 클래스로 1부터 N까지 합
        measure(() -> {
            int N = 100;
            long sum = 0;
            for (int i = 0; i < N; i++) {
                sum += i;

            }
            System.out.println("1[부터 " + N + " 까지 합] 결과: " + sum);
        });

        // 2. 익명 클래스로 배열 정렬
        measure(() -> {
            int[] arr = {4, 3, 2, 1};
            System.out.println("원본 배열: " + Arrays.toString(arr));
            Arrays.sort(arr);
            System.out.println("원본 배열: " + Arrays.toString(arr));

        });
    }
}
```

### 문제 5. 고차 함수(High-Order Function) - 함수를 반환하기
#### 문제 설명
"함수를 반환"하는 방식도 연습해보자. 두 정수를 받아서 연산하는 MyFunction 인터페이스를 사용해보자.
```
package lambda;

@FunctionalInterface
public interface MyFunction {
     int apply(int a, int b);
}
```
- static MyFunction getOperation(String operator) 라는 정적 메서드를 만들어라.
- 매개변수인 operator 에 따라 다음과 같은 내용을 전달하고 반환해라.
  - operator 가 "add"면, (a, b) 를 받아 a + b 를 리턴하는 람다를 반환해라.
  - "sub"면, a - b 를 리턴하는 람다를 반환해라.
  - 그 외의 경우는 항상 0을 리턴하는 람다를 반환해라.
- main() 메서드에서 getOperation("add") , getOperation("sub") , getOperation("xxx") 를
  각각 호출해서 반환된 람다를 실행해라.

#### 예시 출력
```
add(1, 2) = 3
sub(1, 2) = -1
xxx(1, 2) = 0 // 그 외의 경우
```

#### 정답 예시
```
package lambda.ex1;

import lambda.MyFunction;

public class M5Return {

    public static void main(String[] args) {
        MyFunction add = getOperation("add");
        System.out.println("add(1, 2) = " + add.apply(1, 2));

        MyFunction sub = getOperation("sub");
        System.out.println("sub.apply(1, 2) = " + sub.apply(1, 2));

        MyFunction xxx = getOperation("xxx");
        System.out.println("xxx.apply(1,2) = " + xxx.apply(1, 2));
    }

    public static MyFunction getOperation(String operator) {
        switch (operator) {
            case "add":
                return (a, b) -> a + b;
            case "sub":
                return (a, b) -> a - b;
            default:
                return (a, b) -> 0;  // 잘못된 연산자일 경우 0 반환
        }
    }
}
```

> 💡[이것만은 기억해두자!]
> sub.apply(1, 2).soutv 명령어시
> System.out.println("sub.apply(1, 2) = " + sub.apply(1, 2)); 자동완성


## 문제와 풀이2
이번 문제들은 이후에 설명할 스트림은 물론이고, 함수형 프로그래밍의 개념을 이해하기 위해 **반드시 반복해서 
풀어보고, 또 이해해야 한다.**
이번 문제들은 고차 함수(Higher-Order Function) 개념을 직접 실습해볼 수 있도록 구성했다. 각 문제에서 요구하는
핵심 사항은 "함수를 매개변수로 받거나, 함수를 반환" 하는 구조를 구현하는 것이다. 람다가 아직 익숙하지 않을 것이
니 먼저 익명 클래스로 구현해보고 그 다음에 람다로 구현해보자.

참고: 고차 함수(Higher-Order Function)란?
- 함수를 인자로 받거나, 함수를 반환하는 함수
- 자바에서는 **함수형 인터페이스**에 익명 클래스나 람다를 담아서 주고받음으로써 고차 함수를 구현할 수 있다.


### 문제 1. filter 함수 구현하기
#### 요구사항
1. 정수 리스트가 주어졌을 때, 특정 조건에 맞는 요소들만 뽑아내는 filter 함수를 직접 만들어보자.
2. filter(List<Integer> list, MyPredicate predicate) 형식의 정적 메서드를 하나 작성한다.
   MyPredicate 는 함수형 인터페이스이며, boolean test(int value); 같은 메서드를 가진다.
3. main() 에서 예시로 다음과 같은 상황을 실습해보자.
   리스트: [-3, -2, -1, 1, 2, 3, 5]
   조건 1: 음수(negative)만 골라내기
   조건 2: 짝수(even)만 골라내기

#### 에시 실행
```
원본 리스트: [-3, -2, -1, 1, 2, 3, 5]
음수만: [-3, -2, -1]
짝수만: [-2, 2]
```
#### 함수형 인터페이스 예시
```
package lambda.ex2;

@FunctionalInterface
public interface MyPredicate {
    boolean test(int value);
}
```
#### 기본 코드 예시
```
package lambda.ex2;

import java.util.ArrayList;
import java.util.List;

public class FilterExample {
    // 고차 함수, 함수를 인자로 받아서 조건에 맞는 요소만 뽑아내는 filter
    public static List<Integer> filter(List<Integer> list, MyPredicate predicate) {
        List<Integer> result = new ArrayList<>();
        for (int val : list) {
            if (predicate.test(val)) {
                result.add(val);
            }
        }
        return result;
    }

    public static void main(String[] args) {
        List<Integer> numbers = List.of(-3, -2, -1, 1, 2, 3, 5);
        System.out.println("원본 리스트: " + numbers);

        // 1. 음수(negative)만 뽑아내기
        // 코드 작성

        // 2. 짝수(even)만 뽑아내기
        // 코드 작성
    }
}
```

#### 정답 - 익명 클래스
```
package lambda.ex2;

import java.util.ArrayList;
import java.util.List;

public class FilterExampleEx1 {
    // 고차 함수, 함수를 인자로 받아서 조건에 맞는 요소만 뽑아내는 filter
    public static List<Integer> filter(List<Integer> list, MyPredicate predicate) {
        List<Integer> result = new ArrayList<>();
        for (int val : list) {
            if (predicate.test(val)) {
                result.add(val);
            }
        }
        return result;
    }

    public static void main(String[] args) {
        List<Integer> numbers = List.of(-3, -2, -1, 1, 2, 3, 5);
        System.out.println("원본 리스트: " + numbers);

        // 1. 음수(negative)만 뽑아내기
        List<Integer> negatives = filter(numbers, new MyPredicate() {
            @Override
            public boolean test(int value) {
                return value < 0;
            }
        });
        System.out.println("음수만: " + negatives);

        // 2. 짝수(even)만 뽑아내기
        List<Integer> evens = filter(numbers, new MyPredicate() {
            @Override
            public boolean test(int value) {
                return value % 2 == 0;
            }
        });
        System.out.println("짝수만: " + evens);
    }
}

```
#### 정답 - 람다
```
package lambda.ex2;

import java.util.ArrayList;
import java.util.List;

public class FilterExampleEx2 {
    // 고차 함수, 함수를 인자로 받아서 조건에 맞는 요소만 뽑아내는 filter
    public static List<Integer> filter(List<Integer> list, MyPredicate predicate) {
        List<Integer> result = new ArrayList<>();
        for (int val : list) {
            if (predicate.test(val)) {
                result.add(val);
            }
        }
        return result;
    }

    public static void main(String[] args) {
        List<Integer> numbers = List.of(-3, -2, -1, 1, 2, 3, 5);
        System.out.println("원본 리스트: " + numbers);

        // 1. 음수(negative)만 뽑아내기
        // 코드 작성
        List<Integer> negative = filter(numbers, value -> value < 0);
        System.out.println("음수만 = " + negative);

        // 2. 짝수(even)만 뽑아내기
        // 코드 작성
        List<Integer> even = filter(numbers, value -> value % 2 == 0);
        System.out.println("짝수만 = " + even);
    }
}
```
