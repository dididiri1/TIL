# 섹션1. 람다


## 함수형 인터페이스
**함수형 인터페이스**는 정확히 하나의 추상 메서드를 가지는 인터페이스를 말한다.
람다는 추상 메서드가 하나인 **함수형 인터페이스**에만 할당할 수 있다.
단일 추상 메서드를 줄여서 **SAM**(Single Abstract Method)이라 한다.
참고로 람다는 클래스, 추상 클래스에는 할당할 수 없다. 오직 단일 추상 메서드를 가지는 인터페이스에만 할당할 수 있다.

#### 여러 추상 메서드
```
package lambda.lambda1;

public interface NotSamInterface {
      void run();
      void go(); 
}
```
- 인터페이스의 메서드 앞에는 abstract (추상)이 생략되어 있다. (자바 기본!)
- 여기에는 run() , go() 두 개의 추상 메서드가 선언되어 있다.
- 단일 추상 메서드(SAM)가 아니다. 이 인터페이스에는 람다를 할당할 수 없다.

#### 단일 추상 메서드
```
package lambda.lambda1;
public interface SamInterface {
    void run();
}
```
- 여기에는 run() 한 개의 추상 메서드만 선언되어 있다.
- 단일 추상 메서드(SAM)이다. 이 인터페이스에는 람다를 할당할 수 있다.
```
package lambda.lambda1;

public class SamMain {

    public static void main(String[] args) {
        SamInterface samInterface = () -> {
            System.out.println("sam");
        };

        samInterface.run();

        // 컴파일 오류
        NotSamInterface notSamInterface = () -> {
            System.out.println("sam");
        };

        notSamInterface.go();
        notSamInterface.run();
    }
}
```
#### 컴파일 오류 - 실행 결과
```
java: incompatible types: lambda.lambda1.NotSamInterface is not a functional 
interface
    multiple non-overriding abstract methods found in interface 
lambda.lambda1.NotSamInterface
```
- NotSamInterface 이 함수형 인터페이스가 아니라는 컴파일 오류 메시지가 나온다.
- 오류를 확인했으면 컴파일 오류 부분을 다시 주석 처리하자.

#### 자바는 왜 다음 코드를 허용하지 않을까?
```
NotSamInterface notSamInterface = () -> {
    System.out.println("not sam");
};

notSamInterface.go();
notSamInterface.run();
```
- 람다는 하나의 함수이다. 따라서 람다를 인터페이스에 담으려면 하나의 메서드(함수) 선언만 존재해야 한다.
- 인터페이스는 여러 메서드(함수)를 선언할 수 있다. 여기서는 run(), go() 두 메서드가 존재한다.
- 이 함수를 NoSamInterface에 있는 run() 또는 go() 둘 중 하나에 할당해야 하는 문제가 발생한다.

자바는 이러한 문제를 해결하기 위해, 단 하나의 추상 메서드(SAM: Single Abstract Method)만을 포함하는 
**함수형 인터페이스에만 람다를 할당할 수 있도록 제한**했다.
SamInterface 은 run() 이라는 단 하나의 추상 메서드만을 포함한다. 따라서 문제 없이 람다를 할당하고 실행할
수 있다.

### @FunctionalInterface
```
public class Car {
    public void move() {
        System.out.println("차를 이동합니다.");
    }
}
```

```
public class ElectricCar extends Car{

    @Override
    public void move() {
        System.out.println("전기차를 빠르게 이동합니다.");
    }

}
```
메서드를 재정의할 때 실수로 재정의할 메서드 이름을 다르게 적으면 재정의가 되지 않는다. 이 예제에서 부모는
move() 인데 자식은 movee() 라고 e 를 하나 더 잘못 적었다. 이런 문제를 컴파일 단계에서 원천적으로 막기 위해
@Override 애노테이션을 사용한다. 이 애노테이션 덕분에 개발자가 할 수 있는 실수를 컴파일 단계에서 막을 수 있
고, 또 개발자는 이 메서드가 재정의 메서드인지 명확하게 인지할 수 있다.

함수형 인터페이스는 단 하나의 추상 메서드(SAM: Single Abstract Method)만을 포함하는 인터페이스이다.
그리고 람다는 함수형 인터페이스에만 할당할 수 있다.
그런데 단 하나의 추상 메서드만을 포함한다는 것을 어떻게 보장할 수 있을까?
@FunctionalInterface 애노테이션을 붙여주면 된다. 이 애노테이션이 있으면 단 하나의 추상 메서드가 아니면
컴파일 단계에서 오류가 발생한다. 따라서 함수형 인터페이스임을 보장할 수 있다.

```
@FunctionalInterface // 애노테이션 추가
public interface SamInterface {
    void run();
}
```
- @FunctionalInterface 을 통해 함수형 인터페이스임을 선언해두면, 이후에 누군가 실수로 
  추상 메서드를 추가할 때 컴파일 오류가 발생한다
```
@FunctionalInterface // 애노테이션 추가
public interface SamInterface {
    void run();
    void gogo(); // 실수로 누군가 추가시 컴파일 오류 발생
}
```
```
java: Unexpected @FunctionalInterface annotation
 lambda.lambda1.SamInterface is not a functional interface
 multiple non-overriding abstract methods found in interface 
lambda.lambda1.SamInterface
```
- 함수형 인터페이스가 아니라는 컴파일 오류 메시지
- 오류를 확인했으면 gogo() 메서드는 삭제하자

따라서 람다를 사용할 함수형 인터페이스라면 @FunctionalInterface 를 필수로 추가하는 것을 권장한다.

## 람다와 시그니처
람다를 함수형 인터페이스에 할당할 떄는 메서드의 형태를 정의하는 요소인 메서드 시그니처가 맞아야 한다.
메서드 시그니처의 주요 구성 요소는 다음과 같다.
1. 메서드 이름
2. 매개변수의 수와 타입(순서 포함)
3. 반환 타입

#### MyFucntion 예시
예를 들어 MyFucntion의 apply 메서드를 살펴보자
```
@FunctionalInterface
public interface MyFunction {
    int apply(int a, int b);
}
```
이 메서드의 시그니처
- 이름: apply
- 매개변수: int , int
- 반환 타입: int
```
MyFunction myFunction = (int a, int b) -> {
     return a + b;
};
```
람다는 익명 함수이므로 시그니처에서 이름은 제외하고, **매개변수, 반환 타입이 함수형 인터페이스에 선언한 메서드와
맞아야 한다.**
이 람다는 매개변수로 int a , int b , 그리고 반환 값으로 a + b 인 int 타입을 반환하므로 시그니처가 맞다. 따
라서 람다를 함수형 인터페이스에 할당할 수 있다.

참고로 람다의 매개변수 이름은 함수형 인터페이스에 있는 메서드 매개변수의 이름과 상관없이 자유롭게 작성해도 된
다. 타입과 순서만 맞으면 된다.
```
MyFunction myFunction = (int xxx, int yyy) -> {return xxx + yyy;};
```
#### Procedure 예시
```
@FunctionalInterface
public interface Procedure {
    void run();
}
```
이 메서드의 시그니처
- 이름: run
- 매개변수: 없음
- 반환 타입: 없음
```
Procedure procedure = () -> {
    System.out.println("hello! lambda");
};
```
이 람다는 매개변수가 없고, 반환 타입이 없으므로 시그니처가 맞다.   
따라서 람다를 함수형 인터페이스에 할당할 수 있다.

## 람다와 생략
람다는 간결한 코드 작성을 위해 다양한 문법 생략을 지원한다
#### 단일 표현식1
```
package lambda.lambda1;

import lambda.MyFunction;

public class LambdaSimple1 {
    public static void main(String[] args) {
        // 기본
        MyFunction function1 = (int a, int b) -> {
            return a + b;
        };
        System.out.println("function1: " + function1.apply(1, 2));

        // 단일 표현식인 경우 중괄호와 리턴 생략 가능
        MyFunction function2 = (int a, int b) -> a + b;
        System.out.println("function2: " + function2.apply(1, 2));

        // 단일 표현식이 아닐 경우 중괄호와 리턴 모두 필수
        MyFunction function3 = (int a, int b) -> {
            System.out.println("람다 실행");
            return a + b;
        };
        System.out.println("function3: " + function3.apply(1, 2));
    }
}
```
#### 실행 결과
```
function1: 3
function2: 3
람다 실행
function3: 3
```

#### 생략 전
```
(int a, int b) -> {return a + b;};
```
- a + b 와 같이 간단한 단일 표현식은 중괄호( {} )와 return 을 함께 생략할 수 있다.

#### 생략 후
```
(int a, int b) -> a + b;
```
- 생략한 코드는 생략 전 코드와 같은 코드이다. retrun 문이 보이지 않지만 결과를 반환한다.

### 표현식(expression)이란?
- 하나의 값으로 평가되는 코드 조각을 의미한다.
- 표현식은 산술 논리 표현식, 메서드 호출, 객체 생성등이 있다. 
  - 예) x + y , price * quantity , calculateTotal() , age >= 18
- 표현식이 아닌것은 제어문, 메서드 선언 같은 것이 있다.
  - 예) if (condition) { }

### 람다 - 단일 표현식(single expression)인 경우
- 중괄호 {}와 return 키워드를 함께 생략할 수 있음
  - 표현식의 결과가 자동으로 반환값이 됨
- 중괄호를 사용하는 경우에는 반드시 retrun 문을 포함해야 한다.
  - return 문을 명시적으로 포함하는 경우 중괄호를 사용해야 한다.
  - 반환 타입이 void 인 경우 return 생략 가능
#### 단일 표현식이 아닌 경우
```
(int a, int b) -> {
    System.out.println("람다 실행");
    return a + b;
};
```
- 단일 표현식이 아닌 경우 중괄호( {} )를 생략할 수 없다. 이 경우 반환 값이 있으면 return 문도 포함해야 한다.


### 단일 표현식2
이번에는 매개변수와 반환 값이 없는 경우를 살펴보자
```
package lambda.lambda1;

import lambda.Procedure;

public class LambdaSimple2 {
    public static void main(String[] args) {
        // 매개변수, 반환 값이 없는 경우
        Procedure procedure1 = () -> {
            System.out.println("hello! lambda");
        };
        procedure1.run();

        // 단일 표현식은 중괄호 생략 가능
        Procedure procedure2 = () -> System.out.println("hello! lambda");
        procedure2.run();
    }
}
```
#### 실행 결과
```
hello! lambda
hello! lambda
```

매개변수와 반환 값이 없는 경우도 동일하다.  
Procedure.run() 의 경우 반환 타입이 void 이기 때문에 중괄호를 사용해도 return 은 생략할 수 있다.

### 타입 추론
다음과 같은 람다 코드를 작성한다고 생각해보자.
```
MyFcuntion function1 = (int a, int b) -> a + b;
```
- 여기서 매개변수에 해당하는 (int a, int b) 부분을 집중해보자.
- 함수형 인터패이스인 MyFcuntion의 apply() 메서드를 보면 이미 int a, int b로 매개변수의 타입이
  정의되어 있다.
- 따라서 이 정보를 사용하면 람다의 (int a, int b) 에서 타입 정보를 생략할 수 있다.
```
@FunctionalInterface
public interface MyFunction {
    int apply(int a, int b);
}
```
다음 예제 코드로 확인해보자.
```
package lambda.lambda1;

import lambda.MyFunction;

public class LambdaSimple3 {
    public static void main(String[] args) {
        // 타입 생략 전
        MyFunction function1 = (int a, int b) -> a + b;

        // MyFunction 타입을 통해 타입 추론 가능, 람다는 타입 생략 가능
        MyFunction function2 = (a, b) -> a + b;

        int result = function2.apply(1, 2);
        System.out.println("result = " + result);
    }
}
```

#### 실행 결과
```
result = 3
```

#### 타입 생략 전후
```
MyFunction function1 = (int a, int b) -> a + b; // 타입 직접 입력
MyFunction function2 = (a, b) -> a + b; // 타입 추론 사용
```
- 자바 컴파일러는 람다가 사용되는 함수형 인터페이스의 메서드 타입을 기반으로 람다의 매개변수와 반환값의  
  타입을 추론한다. 따라서 람다는 타입을 생략할 수 있다.
- 반환 타입은 문법적으로 명시할 수 없다. 대신에 컴파일러가 자동으로 추론한다.

### 매개변수의 괄호 생략
```
package lambda.lambda1;

public class LambdaSimple4 {
    public static void main(String[] args) {
        MyCall call1 = (int value) -> value * 2;    // 기본
        MyCall call2 = (value) -> value * 2;        // 타입 추론
        MyCall call3 = value -> value * 2;          // 매개변수 1개, () 생략 가능

        System.out.println("call3 = " + call3.call(10));
    }

    interface MyCall {
        int call(int value);
    }
}
```
- 매개변수가 정확히 하나이면서, 타입을 생략하고, 이름만 있는 경우 소괄호 () 를 생략할 수 있다.
- 매개변수가 없는 경우에는 () 가 필수이다.
- 매개변수가 둘 이상이면 () 가 필수이다.

#### 정리
- **매개변수 타입**: 생략 가능하지만 필요하다면 명시적으로 작성할 수 있다.
- **반환 타입**: 문법적으로 명시할 수 없고, 식의 결과를 보고 컴파일러가 항상 추론한다.
- 람다는 보통 간략하게 사용하는 것을 권장한다.
  - 단일 표현식이면 중괄호와 리턴을 생략하자.
  - 타입 추론을 통해 매개변수의 타입을 생략하자. (컴파일러가 추론할 수 있다면, 생략하자)

## 람다의 전달
람다는 함수형 인터페이스를 통해 변수에 대입하거나, 메서드에 전달하거나 반환할 수 있다.

### 람다를 변수에 대입하기
```
package lambda.lambda2;

import lambda.MyFunction;

// 1. 람다를 변수에 대입하기
public class LambdaPassMain1 {
    public static void main(String[] args) {
        MyFunction add = (a, b) -> a + b;
        MyFunction sub = (a, b) -> a - b;

        System.out.println("add.apply(1, 2) = " + add.apply(1, 2));
        System.out.println("sub.apply(1, 2) = " + sub.apply(1, 2));

        MyFunction cal = add;
        System.out.println("cal(add).apply(1, 2) = " + cal.apply(1, 2));

        cal = sub;
        System.out.println("cal(sub).apply(1, 2) = " + cal.apply(1, 2));
    }
}
```
#### 실행 결과
```
add.apply(1, 2) = 3
sub.apply(1, 2) = -1
cal(add).apply(1, 2) = 3
cal(sub).apply(1, 2) = -1
```
```
MyFunction add = (a, b) -> a + b;
```
- 이 대입식에서 변수 add의 타입은 MyFunction 함수형 인터페이스이다. 따라서 MyFunction 형식에 맞는  
  람다를 대입할 수 있다.(메서드 시그니처가 일치한다)

자바에서 기본형과 참조형은 다음과 같은 변수에 값을 대입할 수 있다.
#### 기본형의 값 대입
```
int a = 10;
int c;
c = a;
```

#### 참조형의 값 대입
```
Member newMember = new Member();
Member target;
target = newMember;
```
클래스나 인터페이스로 선언한 변수에 값을 대입하는 것은 인스턴스의 참조값을 대입하는 것이다.

#### 람다의 대입
```
MyFunction add = (a, b) -> a + b;
MyFunction cal = add;
```
```
// 람다의 대입 분석
MyFunction add = (a, b) -> a + b; // 1. 람다 인스턴스 생성
MyFunction add = x001; // 2. 참조값 반환, add에 x001 대입
MyFunction cal = add;
MyFunction cal = x001; // 3. cal에 참조값 대입
```
람다도 마찬가지다. 함수형 인터페이스로 선언한 변수에 람다를 대입하는 것은 람다 인스턴스의 참조값을 대입하는 것
이다.
이해가 잘 안된다면 익명 클래스의 인스턴스를 생성하고 대입한다고 생각해보자.
참고로 함수형 인터페이스도 인터페이스이다.

람다도 인터페이스(함수형 인터페이스)를 사용하므로, 람다 인스턴스의 참조값을 변수에 전달할 수 있다.
변수에 참조값을 전달할 수 있으므로 다음과 같이 사용할 수 있다.
- 매개변수를 통해 메서드(함수)에 람다를 전달할 수 있다. (정확히는 람다 인스턴스의 참조값을 전달)
- 메서드가 람다를 반환할 수 있다. (정확히는 람다 인스턴스의 참조값을 반환)

### 람다를 메서드(함수)에 전달하기
앞서 본 것과 같이 람다는 변수에 전달할 수 있다.  
같은 원리로 람다를 매개변수를 통해 메서드(함수)에 전달할 수 있다.
```
import lambda.MyFunction;

// 2. 람다를 메서드(함수)에 전달하기
public class LambdaPassMain2 {
    public static void main(String[] args) {
        MyFunction add = (a, b) -> a + b;
        MyFunction sub = (a, b) -> a - b;

        System.out.println("변수를 통해 전달");
        calculate(add);
        calculate(sub);

        System.out.println("람다를 직접 전달");
        calculate((a, b) -> a + b);
        calculate((a, b) -> a - b);
    }

    static void calculate(MyFunction function) {
        int a = 1;
        int b = 2;
        System.out.println("계산 시작");
        int result = function.apply(a, b);
        System.out.println("계산 결과: " + result);
    }
}
```
#### 실행 결과
```
변수를 통해 전달
계산 시작
계산 결과: 3
계산 시작
계산 결과: -1
람다를 직접 전달
계산 시작
계산 결과: 3
계산 시작
계산 결과: -1
```
```

```
- calcualte() 메서드의 매개변수는 MyFucntion 함수형 인터페이스이다. 따라서 람다를 전달할 수 있다.
#### 람다를 변수에 담은 후에 매개변수에 전달
```
MyFunction add = (a, b) -> a + b;
calculate(add);
```
```
// 람다를 변수에 담은 후에 매개변수에 전달 분석
MyFunction add = (a, b) -> a + b; // 1. 람다 인스턴스 생성
MyFunction add = x001; // 2. 참조값 반환
add = x001; // 3. 참조값 대입

calculate(add);
calculate(x001);

// 메서드 호출, 매개변수에 참조값 대입
void calculate(MyFunction function = x001)
```

#### 람다를 직접 전달
```
calculate((a, b) -> a + b);
```
```
// 람다를 직접 전달 분석
calculate((a, b) -> a + b); // 1. 람다 인스턴스 생성
calculate(x001); // 2. 참조값 반환 및 매개변수에 전달

// 메서드 호출, 매개변수에 참조값 대입
void calculate(MyFunction function = x001)
```
- 람다 인스턴스의 참조를 매개변수에 전달하는 것이기 때문에 이해하는데 어려움은 없을 것이다.
- 일반적인 참조를 매개변수에 전달하는 것과 같다.

### 람다를 반환하기
```
package lambda.lambda2;

import lambda.MyFunction;

// 3. 람다를 반환하기
public class LambdaPassMain3 {
    public static void main(String[] args) {
        MyFunction add = getOperation("add");
        System.out.println("add.apply(1, 2) = " + add.apply(1, 2));

        MyFunction sub = getOperation("sub");
        System.out.println("sub.apply(1, 2) = " + sub.apply(1, 2));

        MyFunction xxx = getOperation("xxx");
        System.out.println("xxx.apply(1, 2) = " + xxx.apply(1, 2));
    }

    // 람다를 반환하는 메서드
    static MyFunction getOperation(String operator) {
        switch (operator) {
            case "add":
                return (a, b) -> a + b;
            case "sub":
                return (a, b) -> a - b;
            default:
                return (a, b) -> 0;
        }
    }
}
```

#### 실행 결과
```
add.apply(1, 2) = 3
sub.apply(1, 2) = -1
xxx.apply(1, 2) = 0
```
```
MyFunction getOperation(String operator){}
```
- getOperation 메서드는 반환 타입이 MyFunction 함수형 인터페이스이다. 따라서 람다를 반환할 수 있다.

#### 분석
```
// 1. 메서드를 호출한다.
MyFunction add = getOperation("add");

// 2. getOperation() 메서드 안에서 다음 코드가 호출된다.
MyFunction getOperation(String operator) {} // 반환 타입이 MyFunction 함수형 인터페이스이다.

return (a, b) -> a + b; // 2-1. 람다 인스턴스를 생성한다.
return x001; // 2-2. 람다 인스턴스의 참조값을 반환한다.

// 3. main 메서드로 람다 인스턴스의 참조값이 반환된다.
MyFunction add = x001; // 3-1. 람다 인스턴스의 참조값을 add에 대입한다.
```
