# 📌 자바 함수형 인터페이스: Predicate, Consumer, Supplier, Function

### 함수형 인터페이스 Descriptor Method
| Function Interface |  Descriptor  | Method   | 주요 사용처     |  
|:-------------------|:------------:|:---------|:-----------|
| Predicate<T>       | T -> boolean | test()   | 조건 검사, 필터링 |
| Consumer<T>        |  T -> void   | accept() | 출력, 콜백     |
| Supplier<T>        |    T -> T    | get()    | 데이터 공급, 생성 |
| Function<T>        |    T -> R    | apply()  | 값 변환, 매핑   |

### ✅ 1. Predicate<T>
``` 
@FunctionalInterface
public interface Predicate<T> {

    /**
     * Evaluates this predicate on the given argument.
     *
     * @param t the input argument
     * @return {@code true} if the input argument matches the predicate,
     * otherwise {@code false}
     */
    boolean test(T t);
    
    ``` 
    
 }
``` 
- 역할: T를 받아서 boolean 값을 반환
- 메서드: boolean test(T t)
- 주 사용처: 조건 검사, 필터링 (filter)
  - 컬렉션에서 특정 조건에 맞는 요소를 필터링할 때 사용

#### 익명 함수 버전
``` 
import java.util.function.Predicate;

public class Main {

    public static void main(String[] args) {
        Predicate<Integer> even = new Predicate<>() {
            @Override
            public boolean test(Integer value) {
                return value % 2 == 0;
            }
        };

        System.out.println("짝수 = " + even.test(3)); // true
    }
}
``` 

#### 람다 버전
``` 
import java.util.function.Predicate;

public class Main {

    public static void main(String[] args) {
        Predicate<Integer> even = value -> value % 2 == 0;

        System.out.println("짝수 = " + even.test(4)); // false
    }
}
```
#### 스트림 활용
``` 
import java.util.List;
import java.util.stream.Collectors;

public class PredicateMain {

    public static void main(String[] args) {
        List<Integer> numbers = List.of(-3, -2, -1, 1, 2, 3);

        List<Integer> even = numbers.stream().filter(value -> value % 2 == 0).collect(Collectors.toList());
        
        System.out.println(even);
    }
}
``` 

### ✅ 2. Consumer<T>
- 주어진 값을 사용해서 작접을 수행하고 끝내는 것이 특징이다.
- 역할: T를 받아서 소비(consume), 반환값 없음
- 메서드: void accept(T t)
- 주 사용처: 출력, 콜백, forEach 처리
- 단일 인자를 받아서 처리를 하지만, 결과를 반환하지 않는 함수형 인터페이스

```
@FunctionalInterface
public interface Consumer<T> {

    /**
     * Performs this operation on the given argument.
     *
     * @param t the input argument
     */
    void accept(T t);
    
    ```
}
```
#### 익명 함수 버전
``` 
import java.util.function.Consumer;

public class ConsumerMain {

    public static void main(String[] args) {
        Consumer<String> consumer = new Consumer<>() {
            @Override
            public void accept(String s) {
                System.out.println(s);
            }
        };

        consumer.accept("Hello");
    }
}
```
#### 람다 버전
``` 
import java.util.function.Consumer;

public class ConsumerMain {

    public static void main(String[] args) {
        Consumer<String> consumer = s -> System.out.println(s);
        
        consumer.accept("Hello");
    }
}
```
#### 람다 버전2
``` 
import java.util.function.Consumer;

public class ConsumerMain {

    public static void main(String[] args) {
        Consumer<String> consumer = System.out::println;

        consumer.accept("Hello");
    }
}
```
#### 스트림 활용
``` 
import java.util.List;

public class ConsumerMain {

    public static void main(String[] args) {
        List<String> names = List.of("Kim", "Lee", "Park");
        names.stream().forEach(s -> System.out.println(s));
    }
}
``` 

### ✅ 3. Supplier<T>
- 인자를 받지 않고 결과를 반환하는 함수형 인터페이스
- 역할: 아무 입력값 없이 T를 공급(supply)
- 메서드: T get()
- 주 사용처: 데이터 생성, Lazy Loading, 팩토리 패턴


```
@FunctionalInterface
public interface Supplier<T> {

    /**
     * Gets a result.
     *
     * @return a result
     */
    T get();
}
```
#### 익명 함수 버전
``` 
import java.util.function.Supplier;

public class Main {

    public static void main(String[] args) {
        Supplier<Double> supplier = new Supplier<Double>() {
            @Override
            public Double get() {
                return Math.random();
            }
        };

        System.out.println("랜덤 숫자 = " + supplier.get());
    }
}

```
#### 람다 버전
``` 
import java.util.function.Supplier;

public class Main {

    public static void main(String[] args) {
        Supplier<Double> supplier = () -> Math.random();

        System.out.println("랜덤 숫자 = " + supplier.get());
    }
}
```

### ✅ 4. Function<T, R>
- 인자를 하나 받아서 다른 타입의 결과를 반환하는 함수형 인터페이스입니다.
- 역할: T를 받아서 R을 반환 (입력과 출력 타입이 다를 수 있음)
- 메서드: R apply(T t)
- 주 사용처: 값 변환, 매핑(map)

``` 
import java.util.function.Function;

public class FunctionMain {

    public static void main(String[] args) {
        Function<String, Integer> function = new Function<>() {
            @Override
            public Integer apply(String s) {
                return s.length();
            }
        };

        System.out.println(function.apply("Lambda"));
    }
}
```
#### 람다 버전
``` 
import java.util.function.Function;

public class FunctionMain {

    public static void main(String[] args) {
        Function<String, Integer> function = s -> s.length();

        System.out.println(function.apply("Lambda"));
    }
}
```
#### 스트림 활용
``` 
import java.util.List;
import java.util.stream.Collectors;

public class FunctionMain {

    public static void main(String[] args) {

        List<String> names = List.of("Java", "Spring", "Boot");

        List<Integer> lengths = names.stream().map(s -> s.length()).collect(Collectors.toList());
        System.out.println(lengths);
    }
}
```

> 💡 핵심 요약
> 람다 = 하나의 동작을 값처럼 전달  
> 컴파일러가 타입을 추론하려면 인터페이스에 추상 메서드가 하나만 있어야 한다.  
> 그래서 함수형 인터페이스는 @FunctionalInterface와 함께 추상 메서드를 1개만 가진다.