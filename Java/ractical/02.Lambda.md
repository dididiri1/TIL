# 섹션 2. 람다가 필요한 이유

![](https://github.com/dididiri1/TIL/blob/main/JAVA/pactical/images/02_01.png?raw=true)


## 람다가 필요한 이유 1
람다를 본격적으로 학습하기 전에, 먼저 람다가 필요한 이유에 대해서 알아보자, 람다를 이해하려면 먼저 내부 클래스에 대한 개념을 
확실히 알아두어야 한다.

> 학습 전 체크 사항
> 자바 람다에 대해 제대로 이해하려면 먼저 내부 클래스에 대해 확실한 이해가 필요하다.
> 내부 클래스에 대한 개념이 약하다면 중급 1편 - 중첩 클래스, 내부 클래스를 먼저 복습하자.

지금부터 설명하는 내용은 중급 1편의 익명 클래스 활용을 일부 심화한 내용이다. 이부분은 기족에 이해를 잘 했어도 복습한다.
색하고, 코드로 꼭 따라해보자.

``` 
package lambda.start;

public class Ex0Main {

    public static void helloJava() {
        System.out.println("프로그램 시작");
        System.out.println("Hello Java");
        System.out.println("프로그램 종료");
    }

    public static void helloSpring() {
        System.out.println("프로그램 시작");
        System.out.println("Hello Spring");
        System.out.println("프로그램 종료");
    }

    public static void main(String[] args) {
        helloJava();
        helloSpring();
    }
}

``` 

### 여기서는 상황에 따라 변화는 문자열 데이터를 다음과 같이 매개변수(파라미터)를 통해 외부에서 전달 받아서 출력하면 된다.
``` 
package lambda.start;

public class Ex0RefMain {
    
    public static void hello(String str) {
        System.out.println("프로그램 시작");
        // 변화는 문자값
        System.out.println(str);
        
        System.out.println("프로그램 종료");
    }

    public static void main(String[] args) {
        hello("Hello Java");
        hello("Hello Spring");
    }
}
``` 
- 변하지 않는 부분은 그대로 유지하고, 변하는 문자열은 외부에서 전달 받아서 처리한다.

단순한 문제였지만 프로그래밍에서 중복을 제거하고, 좋은 코드를 유지하는 핵심은 변하는 부분과 변하지 않는 부분을 분리하는 것이다.
여기서는 변하지 않는 "프로그램 시작", "프로그램 종료"를 출력하는 부분은 그대로 유지하고, 상황에 따라 변화가 필요한 문자열은
외부에서 전달 받아서 처리했다.  
이렇게 변하는 부분과 변하지 않는 부분을 분리하고, 변하는 부분을 외부에서 전달 받으면, 메서드(함수)의 재사용성을 높일 수 있다.
리펙토링 전과 후를 비교해보자. hello(String str) 메서드의 재사용성은 매우 높아졌다.
여기서 핵심은 변하는 부분을 메소드 내부에서 사지고 있는 것이 아니라, 외부에서 전달 받는다는 점이다.

### 값 매개변수화(Value Parameterization)
여기서 변하는 부분은 같은 문자값(Value)이다.
```
System.out.println("Hello Java"); 
System.out.println("Hello Spring");
``` 

## 람다기 필요한 이유2

``` 
package lambda.start;

import java.util.Random;

public class Ex1Main {
    public static void helloDice() {
        long startNs = System.nanoTime();
        //코드 조각 시작
        int randomValue = new Random().nextInt(6) + 1;
        System.out.println("주사위 = " + randomValue);
        //코드 조각 종료
        long endNs = System.nanoTime();
        System.out.println("실행 시간: " + (endNs - startNs) + "ns");
    }

    public static void helloSum() {
        long startNs = System.nanoTime();
        //코드 조각 시작
        for (int i = 1; i <= 3; i++) {
            System.out.println("i = " + i);
        }
        //코드 조각 종료
        long endNs = System.nanoTime();
        System.out.println("실행 시간: " + (endNs - startNs) + "ns");
    }

    public static void main(String[] args) {
        helloDice();
        helloSum();
    }
}
``` 
#### 실행 결과
``` 
주사위 = 2
실행 시간: 2882959ns
i = 1
i = 2
i = 3
실행 시간: 191083ns
``` 
- 두 메서드에서 시작을 측정하고, 시간을 출력하는 부분은 변하지 않는 부분이다.
- 코드 조각을 시작하고 종료하는 부분은 변하는 부분이다.
- 중복을 제거하고 재사용성을 늘리려면 결국 코드 조각을 시작하고 종료하는 부분을 외부에서  
  전달 받아야 한다. 이것은 단순히 문자열, 숫자 같은 값을 데이터를 전달 받는 것과는 다른 문제이다.


### 어떻게 코드 조각을 전달할 수 있을까?
코드 조각은 보통 메서드(함수)에 정의한다. 따라서 코드 조각을 전할하기 위해서는 메서드가 필요하다.
인스턴스를 전달하고, 인스턴스에 있는 메서드를 호출하면 됩니다.

### 이 문제를 해결하기 위해 인터페이스를 정의하고 구현 클래스를 만들었다.
#### 리팩토링 후
``` 
public interface Procedure {
    void run();
}
``` 
``` 
public class Ex1RefMain {
    public static void hello(Procedure procedure){
        long startNs = System.nanoTime();

        //코드 조각 시작
        procedure.run();
        //코드 조각 종료
        long endNs = System.nanoTime();
        System.out.println("실행 시간: " + (endNs - startNs) + "ns");
    }

    static class Dice implements Procedure{

        @Override
        public void run() {
            int randomValue = new Random().nextInt(6) + 1;
            System.out.println("주사위 = " + randomValue);
        }
    }

    static class sum implements Procedure{

        @Override
        public void run() {
            for (int i = 1; i <= 3; i++) {
                System.out.println("i = " + i);
            }
        }
    }

    public static void main(String[] args) {
        Procedure dice = new Dice();
        Procedure sum = new Dice();

        hello(dice);
        hello(sum);
    }
}
``` 
- Dice , Sum 각각의 클래스는 Procedure 인터페이스를 구현하고 run() 메서드에 필요한 코드 조각을 구현했다.
- 리팩토링한 hello() 메서드에는 Procedure procedure 매개변수(파라미터)를 통해 인스턴스를 전달할 수 있다.   
  이 인스턴스의 run() 메서드를 실행하면 필요한 코드 조각을 실행할 수 있다.
- 이때 다형성을 활용해서 외부에서 전달되는 인스턴스에 따라 각각 다른 코드 조각이 실행된다.

### 정리
- 문자열, 숫자 같은 값 데이터를 메서드에 전달할 떄는 Spring, int와 같은 각 데이터에 맞는 값을 전달하면 된다.
- 코드 조각을 메서드에 전달할 때는 인스턴스를 전달하고 해당 인스턴스에 있는 메서드를 호출하면 된다.

### 동작 매개변수화(Behavior Parameterization)

#### 값 매개변수화(Value Parameterization)
- 문자값(Value), 숫자값(Value)처럼 구체적인 값을 메서드(함수) 안에 두는 것이 아니라, 매개변수(파라미터)를 통해 외부에서 전달 받도록 해서, 
  메서드의 동작을 달리하고, 재사용성을 높이는 방법을 값 매개변수화라 한다. 
- 값 매개변수화, 값 파라미터화 등으로 부른다.

#### 동작 매개변수화(Behavior Parameterization)

- 코드 조각(코드의 동작 방법, 로직, Behavior)을 메서드(함수) 안에 두는 것이 아니라, 매개변수(파라미터)를 통해서 외부에서 전달 받도록 해서, 메서드의 동작을 달리하고,   
  재사용성을 높이는 방법을 동작 매개변수화라 한다. 동작 매개변수화, 
- 동작 파라미터화, 행동 매개변수화(파라미터화), 행위 파라미터화 등으로 부른다. 

#### 정리하면 다음과 같다.

- 값 매개변수화: 값(숫자, 문자열 등)을 바꿔가며 메서드(함수)의 동작을 달리 함
- 동작 매개변수화: 어떤 동작(로직)을 수행할지를 메서드(함수)에 전달(인스턴스 참조, 람다 등)

자바에서 동작 매개변수화를 하려면 클래스를 정의하고 해당 클래스를 인스턴스로 만들어서 전달해야 한다.
자바8에서 등장한 람다를 사용하면 코드 조각을 매우 편리하게 전달 할 수 있는데, 람다를 알아보기 전에 기존에 자바로 할 수 있는 다양한 방법들을 먼저 알아보자.

### 이번에는 익명 클래스를 사용해서 같은 기능을 구현해보자.
```

```
