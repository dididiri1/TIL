# 10. CAS-동기화와 원자적 연산
- [/원자적 연산 - 소개](#원자적-연산---소개)
- [/원자적 연산 - 시작](#원자적-연산---시작)
- [/원자적 연산 - volatile, synchronized](#원자적-연산---volatile-synchronized)
- [/원자적 연산 - AtomicInteger](#원자적-연산---atomicinteger)
- [/CAS 연산1](#cas-연산1)
- [/CAS 연산2](#cas-연산2)
- [/CAS 연산3](#cas-연산3)
- [/CAS 락 구현1](#cas-락-구현1)
- [/CAS 락 구현2](#cas-락-구현2)
- [/정리](#정리)

## 원자적 연산 - 소개
컴퓨터 과학에서 사용하는 원자적 연산(atomic operation)의 의미는 해당 연산이 더 이상 나눌 수 없는 단위로 수행된 다는 것을 의미한다. 
즉, 원자적 연산은 중단되지 않고, 다른 연산과 간섭 없이 완전히 실행되거나 전혀 실행되지 않는 성질을 가지고 있다. 
쉽게 이야기해서 멀티스레드 상황에서 다른 스레드의 간섭 없이 안전하게 처리되는 연산이라는 뜻 이다.

> **참고**: 과거에 원자는 더 이상 나눌 수 없는 가장 작은 단위로 여겨졌다. 그래서 더는 나눌 수 없다는 뜻으로 **원자적 연산**이라는 단어를 사용한다. 
> 물론 현대 물리학에서는 원자가 더 작은 입자들로 구성되어 있다는 것이 밝혀졌다. 하지만 원자적 연산이라는 단어는 그대로 사용한다.

예를 들어서 다음과 같은 필드가 있을 때
volatile int i = 0;

다음 연산은 둘로 쪼갤 수 없는 원자적 연산이다.
- i = 1
왜냐하면 이 연산은 다음 단 하나의 순서로 실행되기 때문이다.
1. 오른쪽에 있는 1 의 값은 왼쪽의 i 변수에 대입한다.

하지만 다음 연산은 원자적 연산이 아니다.
```
i = i + 1;
```
왜냐하면 이 연산은 다음 순서로 나누어 실행되기 때문이다.
1. 오른쪽에 있는 i 의 값을 읽는다. i 의 값은 10이다.
2. 읽은 10에 1을 더해서 11을 만든다.
3. 더한 11을 왼쪽의 i 변수에 대입한다.

원자적 연산은 멀티스레드 상황에서 아무런 문제가 발생하지 않는다. 하지만 원자적 연산이 아닌 경우에는
synchronized 블럭이나 Lock 등을 사용해서 안전한 임계 영역을 만들어야 한다.

#### 순서대로 실행
예를 들어서 2개의 스레드가 해당 로직을 수행하는데, 하나가 완전히 끝나고 나서, 나머지 하나가 수행된다고 가정해보자.
```
처음에 i = 0이라고 가정하겠다.

스레드1: i = i + 1 연산 수행
스레드1: i의 값을 읽는다. i는 0이다.
스레드1: 읽은 0에 1을 더해서 1을 만든다.
스레드1: 더한 1을 왼쪽의 i변수에 대입한다.
결과: i의 값은 1이다.

스레드2: i = i + 1 연산 수행
스레드2: i의 값을 읽는다. i는 1이다.
스레드2: 읽은 1에 1을 더해서 2을 만든다.
스레드2: 더한 2을 왼쪽의 i변수에 대입한다.
결과: i의 값은 2이다.
```
2개의 스레드가 각각 한 번 연산을 수행했으므로 변수 i 의 값은 0 2가 된다.

#### 동시에 실행
이번에는 문제가 되는 경우를 알아보자. 2개의 스레드가 해당 로직을 동시에 함께 수행하면, 문제가 발생한다.
```
처음에 i = 0이라고 가정하겠다.

스레드1: i = i + 1 연산 수행
스레드2: i = i + 1 연산 수행
스레드1: i의 값을 읽는다. i는 0이다.
스레드2: i의 값을 읽는다. i는 0이다.
스레드1: 읽은 0에 1을 더해서 1을 만든다.
스레드2: 읽은 0에 1을 더해서 1을 만든다.
스레드1: 더한 1을 왼쪽의 i변수에 대입한다.
스레드2: 더한 1을 왼쪽의 i변수에 대입한다.
결과: i의 값은 1이다.
```
2개의 스레드가 각각 한 번 연산을 수행했지만 변수 i 의 값은 0 1이 된다. 한 번의 연산이 사라진 것이다.

그렇다면 다음 연산은 원자적 연산일까?
i++

이 연산은 원자적 연산처럼 보이지만 사실은 원자적 연산이 아니다. 왜냐하면 이 연산은 앞서 살펴본 i = i + 1 을 축약한 것이기 때문이다. 
결과적으로 i++ 은 i = i + 1 와 똑같이 동작한다.

## 원자적 연산 - 시작
원자적이지 않은 연산을 멀티스레드 환경에서 실행하면 어떤 문제가 발생하는지 코드로 알아보자.
IncrementInteger 는 숫자 값을 하나씩 증가시키는 기능을 제공한다. 예를 들어서 지금까지 접속한 사용자의 수 등
을 계산할 때 사용할 수 있다.

```java
package thread.cas.increment;

public interface IncrementInteger {
    void increment();
    
    int get();
}
```
- IncrementInteger 는 값을 증가하는 기능을 가진 숫자 기능을 제공하는 인터페이스다.
- increment() : 값을 하나 증가
- get() : 값을 조회

```java
public class BasicInteger implements IncrementInteger {

    private int value;

    @Override
    public void increment() {
        value++;
    }

    @Override
    public int get() {
        return value;
    }
}
```
- IncrementInteger 인터페이스의 가장 기본 구현이다.
- increment() 를 호출하면 value++ 를 통해서 값을 하나 증가한다.
  - value 값은 인스턴스의 필드이기 때문에, 여러 스레드가 공유할 수 있다. 이렇게 공유 가능한 자원에 ++ 와 같은 원자적이지 않은 
    연산을 사용하면 멀티스레드 상황에 문제가 될 수 있다.

```java
package thread.cas.increment;

import java.util.ArrayList;
import java.util.List;
import static util.ThreadUtils.sleep;

public class IncrementThreadMain {

    public static final int THREAD_COUNT = 1000;

    public static void main(String[] args) throws InterruptedException {
        test(new BasicInteger());
    }

    private static void test(IncrementInteger incrementInteger) throws InterruptedException {
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                sleep(10); // 너무 빨리 실행되기 때문에, 다른 스레드와 동시 실행을 위해 잠깐 쉬었다가 실행
                incrementInteger.increment();
            }
        };

        List<Thread> threads = new ArrayList<>();
        for (int i = 0; i < THREAD_COUNT; i++) {
            Thread thread = new Thread(runnable);
            threads.add(thread);
            thread.start();
        }

        for (Thread thread : threads) {
            thread.join();
        }

        int result = incrementInteger.get();
        System.out.println(incrementInteger.getClass().getSimpleName() + " result: " + result);
    }
}
```
- THREAD_COUNT 수 만큼 스레드를 생성하고 incrementInteger.increment() 를 호출한다.
- 스레드를 1000개 생성했다면, increment() 메서드도 1000번 호출하기 때문에 결과는 1000이 되어야 한다.
- 참고로 스레드가 너무 빨리 실행되기 때문에, 여러 스레드가 동시에 실행되는 상황을 확인하기 어렵다. 그래서 run() 메서드에 sleep(10) 을 두어서, 
  최대한 많은 스레드가 동시에 increment() 를 호출하도록 한다.

#### 실행 결과
```
BasicInteger result: 950
```
실행 결과를 보면 기대한 1000이 아니라 다른 숫자가 보인다. 아마도 실행 환경에 따라서 다르겠지만 1000이 아니라 조금 더 적은 숫자가 보일 것이다. 
물론 실행 환경에 따라서 1000이 보일 수도 있다. 이 문제는 앞서 설명한 것 처럼 여러 스레드가 동시에 원자적이지 않은 value++ 을 호출했기 때문에 발생한다.
그럼 혹시 volatile 을 적용하면 될까?

## 원자적 연산 - volatile, synchronized
### 예제 - volatile
다음과 같이 VolatileInteger 클래스를 만들고, volatile 을 적용해보자.
```java
package thread.cas.increment;

public class VolatileInteger implements IncrementInteger {

    private volatile int value;

    @Override
    public void increment() {
        value++;
    }

    @Override
    public int get() {
        return value;
    }
}
```
- BasicInteger 와 같고 volatile 만 적용해주었다.

#### IncrementThreadMain에 추가
```java
public class IncrementThreadMain {
    public static void main(String[] args) throws InterruptedException {
        test(new BasicInteger());
        test(new VolatileInteger()); // 추가
    }
    //...
}
```
- test(new VolatileInteger()); 를 한 줄 추가하고 실행해보자.

#### 실행 결과
```
BasicInteger result: 950
VolatileInteger result: 961
```
실행 결과를 보면 VolatileInteger 도 여전히 1000이 아니라 더 작은 숫자가 나온다.
volatile 은 여러 CPU 사이에 발생하는 캐시 메모리와 메인 메모리가 동기화 되지 않는 문제를 해결할 뿐이다.
volatile 을 사용하면 CPU의 캐시 메모리를 무시하고, 메인 메모리를 직접 사용하도록 한다. 하지만 지금 이 문제는
캐시 메모리가 영향을 줄 수는 있지만, 캐시 메모리를 사용하지 않고, 메인 메모리를 직접 사용해도 여전히 발생하는 문제이다.
이 문제는 연산 자체가 나누어져 있기 때문에 발생한다. volatile 은 연산 자제를 원자적으로 묶어주는 기능이 아니다.

이렇게 연산 자체가 나누어진 경우에는 synchronized 블럭이나 Lock 등을 사용해서 안전한 임계 영역을 만들어야 한다.

### 예제 - synchronized
다음과 같이 SyncInteger 클래스를 만들고 synchronized 를 적용해서 안전한 임계 영역을 만들어보자
```java
package thread.cas.increment;

public class SyncInteger implements IncrementInteger {

    private int value;

    @Override
    public synchronized void increment() {
        value++;
    }

    @Override
    public synchronized int get() {
        return value;
    }
}
```
- value++ 연산은 synchronized 를 통해 임계 영역 안에서 안전하게 수행된다. 쉽게 이야기해서 한 번에 하나 의 스레드만 해당 연산을 수행할 수 있다.

#### IncrementThreadMain에 추가
```java
public class IncrementThreadMain {

    public static void main(String[] args) throws InterruptedException {
        test(new BasicInteger());
        test(new VolatileInteger());
        test(new SyncInteger()); // 추가
    }

    //...
}
```

#### 실행 결과
```
BasicInteger result: 950
VolatileInteger result: 961
SyncInteger result: 1000
```
synchronized 를 통해 안전한 임계 영역을 만들고 value++ 연산을 수행했더니 정확히 1000이라는 결과가 나왔다. 1000개의 스레드가 안전하게
value++ 연산을 수행한 것이다.


## 원자적 연산 - AtomicInteger
자바는 앞서 만든 SyncInteger 와 같이 멀티스레드 상황에서 안전하게 증가 연산을 수행할 수 있는 AtomicInteger 라는 클래스를 제공한다. 
이름 그대로 원자적인 Integer 라는 뜻이다. 다음과 같이 MyAtomicInteger 클래스를 만들고, 자바가 제공하는 AtomicInteger 를 사용해보자.

```java
package thread.cas.increment;

import java.util.concurrent.atomic.AtomicInteger;

public class MyAtomicInteger implements IncrementInteger {

    AtomicInteger atomicInteger = new AtomicInteger(0);

    @Override
    public void increment() {
        atomicInteger.incrementAndGet();
    }

    @Override
    public int get() {
        return atomicInteger.get();
    }
}
```
- new AtomicInteger(0) : 초기값을 지정한다. 생략하면 0 부터 시작한다.
- incrementAndGet() : 값을 하나 증가하고 증가된 결과를 반환한다. 
- get() : 현재 값을 반환한다.

#### IncrementThreadMain에 추가
```java
public class IncrementThreadMain {
    public static void main(String[] args) throws InterruptedException {
        test(new BasicInteger());
        test(new VolatileInteger());
        test(new SyncInteger());
        test(new MyAtomicInteger()); // 추가
    }
    //...
}
```

#### 실행 결과
```
BasicInteger result: 950
VolatileInteger result: 961
SyncInteger result: 1000
MyAtomicInteger result: 1000
```
실행 결과를 보면 AtomicInteger 를 사용하면 MyAtomicInteger 의 결과도 1000인 것을 확인할 수 있다.
1000개의 스레드가 안전하게 증가 연산을 수행한 것이다.

AtomicInteger 는 멀티스레드 상황에 안전하고 또 다양한 값 증가, 감소 연산을 제공한다. 특정 값을 증가하거나 감소해야 하는데 
여러 스레드가 해당 값을 공유해야 한다면, AtomicInteger 를 사용하면 된다.

> 참고: AtomicInteger , AtomicLong , AtomicBoolean 등 다양한 AtomicXxx 클래스가 존재한다.

## 원자적 연산 - 성능 테스트
이제 AtomicInteger 의 진짜 모습을 하나씩 알아보자.
우선 AtomicInteger 와 우리가 직접 만든 각 클래스의 성능을 비교해보자.

```java
package thread.cas.increment;

public class IncrementPerformanceMain {
    public static final long COUNT = 100_000_000;

    public static void main(String[] args) {
        test(new BasicInteger());
        test(new VolatileInteger());
        test(new SyncInteger());
        test(new MyAtomicInteger());
    }

    private static void test(IncrementInteger incrementInteger) {
        long startMs = System.currentTimeMillis();
        for (long i = 0; i < COUNT; i++) {
            incrementInteger.increment();
        }
        long endMs = System.currentTimeMillis();
        System.out.println(incrementInteger.getClass().getSimpleName() + ": ms=" + (endMs - startMs));
    }
}
```
- 단일 연산은 너무 빠르기 때문에 성능을 확인하려면 어느 정도 반복적인 연산이 필요하다.
- 각각 COUNT 만큼 반복해서 연산을 수행해 보자. 여기서는 1억 번 값 증가 연산을 수행했다.

#### 실행 결과
```
BasicInteger: ms=39
VolatileInteger: ms=455
SyncInteger: ms=625
MyAtomicInteger: ms=367
```

#### BasicInteger
- 가장 빠르다.
- CPU 캐시를 적극 사용한다. CPU 캐시의 위력을 알 수 있다.
- 안전한 임계 영역도 없고, volatile 도 사용하지 않기 때문에 멀티스레드 상황에는 사용할 수 없다.
- 단일 스레드가 사용하는 경우에 효율적이다.

#### VolatileInteger
- volatile 을 사용해서 CPU 캐시를 사용하지 않고 메인 메모리를 사용한다.
- 안전한 임계 영역이 없기 때문에 멀티스레드 상황에는 사용할 수 없다.
- 단일 스레드가 사용하기에는 BasicInteger 보다 느리다. 그리고 멀티스레드 상황에도 안전하지 않다.

#### SyncInteger
- synchronized 를 사용한 안전한 임계 영역이 있기 때문에 멀티스레드 상황에도 안전하게 사용할 수 있다.
- MyAtomicInteger 보다 성능이 느리다.

#### MyAtomicInteger
- 자바가 제공하는 AtomicInteger 를 사용한다. 멀티스레드 상황에 안전하게 사용할 수 있다.
- 성능도 synchronized, Lock(ReentrantLock) 을 사용하는 경우보다 1.5 ~ 2배 정도 빠르다.

SyncInteger 처럼 락을 사용하는 경우보다, AtomicInteger 가 더 빠른 이유는 무엇일까? i++ 연산은 원자적인 연산이 아니다. 
따라서 분명히 synchronized , Lock(ReentrantLock) 와 같은 락을 통해 안전한 임계 영역을 만들어야 할 것 같다.
놀랍게도 AtomicInteger 가 제공하는 incrementAndGet() 메서드는 락을 사용하지 않고, 원자적 연산을 만들어낸다.

## CAS 연산1
참고: CAS 연산은 심화 내용이다. 이해가 어렵다면 가볍게 듣고 넘어가도 괜찮다. 왜냐하면 우리가 직접 CAS 연산을
사용하는 경우는 거의 없기 때문이다. 대부분 복잡한 동시성 라이브러리들이 CAS 연산을 사용한다. 우리는
AtomicInteger와 같은 CAS 연산을 사용하는 라이브러리들을 잘 사용하는 정도면 충분하다.

### 락 기반 방식의 문제점
SyncInteger 와 같은 클래스는 데이터를 보호하기 위해 락을 사용한다.
여기서 말하는 락은 synchronized , Lock(ReentrantLock) 등을 사용하는 것을 말한다.
락은 특정 자원을 보호하기 위해 스레드가 해당 자원에 대한 접근하는 것을 제한한다. 락이 걸려 있는 동안 다른 스레드
들은 해당 자원에 접근할 수 없고, 락이 해제될 때까지 대기해야 한다.
또한 락 기반 접근에서는 락을 획득하고 해제하는 데 시간이 소요된다.

예를 들어서 락을 사용하는 연산이 있다고 가정하자. 락을 사용하는 방식은 다음과 같이 작동한다.
1. 락이 있는지 확인한다.
2. 락을 획득하고 임계 영역에 들어간다.
3. 작업을 수행한다.
4. 락을 반납한다.

여기서 락을 획득하고 반납하는 과정이 계속 반복된다. 10000번의 연산이 있다면 10000번의 연산 모두 같은 과정을 반복한다.
이렇듯 락을 사용하는 방식은 직관적이지만 상대적으로 무거운 방식이다.

### CAS
이런 문제를 해결하기 위해 락을 걸지 않고 원자적인 연산을 수행할 수 있는 방법이 있는데, 이것을 CAS(Compare-And-Swap, Compare-And-Set) 
연산이라 한다. 이 방법은 락을 사용하지 않기 때문에 락 프리(lock-free) 기법이라 한다. 참고로 CAS 연산은 락을 완전히 대체하는 것은 아니고, 
**작은 단위의 일부 영역에 적용할 수 있다.** 기본은 락을 사용하고, 특별한 경우에 CAS를 적용할 수 있다고 생각하면 된다.

지금부터 코드를 통해 CAS 연산을 알아보자.
```java
package thread.cas;

import java.util.concurrent.atomic.AtomicInteger;

public class CasMainV1 {
    public static void main(String[] args) {
        AtomicInteger atomicInteger = new AtomicInteger(0);
        System.out.println("start value = " + atomicInteger.get());

        boolean result1 = atomicInteger.compareAndSet(0, 1);
        System.out.println("result1 = " + result1 + ", value = " + atomicInteger.get());

        boolean result2 = atomicInteger.compareAndSet(0, 1);
        System.out.println("result2 = " + result2 + ", value = " + atomicInteger.get());
    }
}
```
- new AtomicInteger(0) : 내부에 있는 기본 숫자 값을 0 으로 설정한다.
- 자바는 AtomicXxx 의 compareAndSet() 메서드를 통해 CAS 연산을 지원한다.

#### 실행 결과
```
start value = 0
result1 = true, value = 1
result2 = false, value = 1
```

#### compareAndSet(0, 1)
atomicInteger 가 가지고 있는 값이 현재 0이면 이 값을 1로 변경하라는 매우 단순한 메서드이다.
- 만약 atomicInteger 의 값이 현재 0이라면 atomicInteger 의 값은 1로 변경된다. 이 경우 true 를 반환 한다.
- 만약 atomicInteger 의 값이 현재 0이 아니라면 atomicInteger 의 값은 변경되지 않는다. 이 경우 false 를 반환한다.
여기서 가장 중요한 내용이 있는데, 이 메서드는 원자적으로 실행된다는 점이다.
그리고 이 메서드가 제공하는 기능이 바로 CAS(compareAndSet) 연산이다.

### 실행 순서 분석
#### CAS - 성공 케이스
![](https://github.com/dididiri1/TIL/blob/main/Java/adv1/images/10_01.png?raw=true)

- 여기서는 AtomicInteger 내부에 있는 value 값이 0이라면 1로 변경하고 싶다.
- compareAndSet(0, 1) 을 호출한다. 매개변수의 왼쪽이 기대하는 값, 오른쪽이 변경하는 값이다.
- CAS 연산은 메모리에 있는 값이 기대하는 값이라면 원하는 값으로 변경한다.
- 메모리에 있는 value 의 값이 0이므로 1로 변경할 수 있다.
- 그런데 생각해보면 이 명령어는 2개로 나누어진 명령어이다. 따라서 원자적이지 않은 연산처럼 보인다.
  1. 먼저 메인 메모리에 있는 값을 확인한다.
  2. 해당 값이 기대하는 값(0)이라면 원하는 값(1)으로 변경한다.

#### CPU 하드웨어의 지원
CAS 연산은 이렇게 원자적이지 않은 두 개의 연산을 CPU 하드웨어 차원에서 특별하게 하나의 원자적인 연산으로 묶어서 제공하는 기능이다. 
이것은 소프트웨어가 제공하는 기능이 아니라 하드웨어가 제공하는 기능이다. 대부분의 현대 CPU들은 CAS 연산을 위한 명령어를 제공한다.

CPU는 다음 두 과정을 묶어서 하나의 원자적인 명령으로 만들어버린다. 따라서 중간에 다른 스레드가 개입할 수 없다.
1. x001의 값을 확인한다.
2. 읽은 값이 0이면 1로 변경한다.

CPU는 두 과정을 하나의 원자적인 명령으로 만들기 위해 1번과 2번 사이에 다른 스레드가 x001 의 값을 변경하지 못하게 막는다. 
참고로 1번과 2번 사이의 시간은 CPU 입장에서 보면 아주 잠깐 찰나의 순간이다. 그래서 성능에 큰 영향을 끼치지 않는다. 
CPU가 1초에 얼마나 많은 연산을 수행하는지 생각해보면 이해가 될 것이다.

![](https://github.com/dididiri1/TIL/blob/main/Java/adv1/images/10_02.png?raw=true)
- value 의 값이 0 1이 되었다.
- CAS 연산으로 값을 성공적으로 변경하고 나면 true 를 반환한다.

#### CAS - 실패 케이스
![](https://github.com/dididiri1/TIL/blob/main/Java/adv1/images/10_03.png?raw=true)
- CAS 연산은 메모리에 있는 값이 기대하는 값이라면 원하는 값으로 변경한다.
- 여기서는 AtomicInteger 내부에 있는 value 값이 0이라면 1로 변경하고 싶다.
- 현재 value 의 값이 기대하는 0이 아니라 1이므로 아무것도 변경하지 않는다.

![](https://github.com/dididiri1/TIL/blob/main/Java/adv1/images/10_04.png?raw=true)
- CAS 연산으로 값 변경에 실패하면 false 를 반환하고, 값도 변경하지 않는다.
- 
여기까지 듣고 보면 CAS 연산을 사용하면, 1. 기대하는 값을 확인하고 2. 값을 변경하는 두 연산을 하나로 묶어서 원자적으로 제공한다는 것은 이해했을 것이다. 
그런데 이 기능이 어떻게 락을 일부 대체할 수 있다는 것일까?

## CAS 연산2
어떤 값을 하나 증가하는 value++ 연산은 원자적 연산이 아니다. 이 연산은 다음 연산과 같다.
```
i = i + 1;
```
이 연산은 다음 순서로 나누어 실행된다. i 의 초기 값은 0으로 가정하겠다.
1. 오른쪽에 있는 i 의 값을 읽는다. i 의 값은 0이다.
2. 읽은 0에 1을 더해서 1을 만든다.
3. 더한 1을 왼쪽의 i 변수에 대입한다.

1번과 3번 연산 사이에 다른 스레드가 i 의 값을 변경할 수 있기 때문에, 문제가 될 수 있다. 따라서 value++ 연산을 여러 스레드에서 사용한다면, 
락을 건 다음에 값을 증가해야 한다.

CAS 연산을 활용해서 락 없이 값을 증가하는 기능을 만들어보자.
AtomicInteger 가 제공하는 incrementAndGet() 메서드가 어떻게 CAS 연산을 활용해서 락 없이 만들어졌는지 직접 구현해보자.

```java
package thread.cas;

import java.util.concurrent.atomic.AtomicInteger;
import static util.MyLogger.log;

public class CasMainV2 {
    public static void main(String[] args) {
        AtomicInteger atomicInteger = new AtomicInteger(0);
        System.out.println("start value = " + atomicInteger.get());

        // incrementAndGet 구현
        int resultValue1 = incrementAndGet(atomicInteger);
        System.out.println("resultValue1 = " + resultValue1);

        int resultValue2 = incrementAndGet(atomicInteger);
        System.out.println("resultValue2 = " + resultValue2);
    }

    private static int incrementAndGet(AtomicInteger atomicInteger) {
        int getValue;
        boolean result;
        do {
            getValue = atomicInteger.get();
            log("getValue: " + getValue);
            result = atomicInteger.compareAndSet(getValue, getValue + 1);
            log("result: " + result);
        } while (!result);
        return getValue + 1;
    }
}
```
여기서 만든 incrementAndGet() 은 atomicInteger 내부의 value 값을 하나 증가하는 메서드이다. 사실 atomicInteger 도 이 메서드를 제공하지만, 
여기서는 이해를 위해 직접 구현해보자.

CAS 연산을 사용하면 여러 스레드가 같은 값을 사용하는 상황에서도 락을 걸지 않고, 안전하게 값을 증가할 수 있다.
여기서는 락을 걸지 않고 CAS 연산을 사용해서 값을 증가했다.
- getValue = atomicInteger.get() 을 사용해서 value 값을 읽는다.
- compareAndSet(getValue, getValue + 1) 을 사용해서, 방금 읽은 value 값이 메모리의 value 값과 같다면 value 값을 하나 증가한다. 
  여기서 CAS 연산을 사용한다.
- 만약 CAS 연산이 성공한다면 true 를 반환하고 do~while 문을 빠져나온다.
- 만약 CAS 연산이 실패한다면 false 를 반환하고 do~while 문을 다시 시작한다.

#### 실행 결과
```
start value = 0
17:48:20.440 [     main] getValue: 0
17:48:20.442 [     main] result: true
resultValue1 = 1
17:48:20.442 [     main] getValue: 1
17:48:20.442 [     main] result: true
resultValue2 = 2
```
지금은 순서대로 실행되기 때문에, 결과는 다음과 같다.
#### incrementAndGet 첫 번째 실행
- atomicInteger.get() 을 사용해서 value 값을 읽는다. getValue 는 0이다.
- compareAndSet(0,1) 을 수행한다.
  - compareAndSet(getValue, getValue + 1)
- CAS 연산이 성공했으므로 value 값은 0에서 1로 증가하고 true 를 반환한다.
- do~while 문을 빠져나간다.

#### incrementAndGet 두 번째 실행
- atomicInteger.get() 을 사용해서 value 값을 읽는다. getValue 는 1이다.
- compareAndSet(1,2) 을 수행한다.
  - compareAndSet(getValue, getValue + 1)
- CAS 연산이 성공했으므로 value 값은 1에서 2로 증가하고 true 를 반환한다.
- do~while 문을 빠져나간다.

지금은 main 스레드 하나로 순서대로 실행되기 때문에 CAS 연산이 실패하는 상황을 볼 수 없다. 우리가 기대하는 실패하는 상황은 연산의 중간에 
다른 스레드가 값을 변경해버리는 것이다. 멀티스레드로 실행해서 CAS 연산이 실패하는 경우에 어떻게 작동하는지 알아보자.


## CAS 연산2
어떤 값을 하나 증가하는 value++ 연산은 원자적 연산이 아니다. 이 연산은 다음 연산과 같다.
```
i = i + 1;
```
이 연산은 다음 순서로 나누어 실행된다. i 의 초기 값은 0으로 가정하겠다.
1. 오른쪽에 있는 i 의 값을 읽는다. i 의 값은 0이다.
2. 읽은 0에 1을 더해서 1을 만든다.
3. 더한 1을 왼쪽의 i 변수에 대입한다.

1번과 3번 연산 사이에 다른 스레드가 i 의 값을 변경할 수 있기 때문에, 문제가 될 수 있다. 따라서 value++ 연산을
여러 스레드에서 사용한다면, 락을 건 다음에 값을 증가해야 한다.

CAS 연산을 활용해서 락 없이 값을 증가하는 기능을 만들어보자.
AtomicInteger 가 제공하는 incrementAndGet() 메서드가 어떻게 CAS 연산을 활용해서 락 없이 만들어졌는지 직접 구현해보자.

```java
package thread.cas;

import java.util.concurrent.atomic.AtomicInteger;
import static util.MyLogger.log;

public class CasMainV2 {
    public static void main(String[] args) {
        AtomicInteger atomicInteger = new AtomicInteger(0);
        System.out.println("start value = " + atomicInteger.get());

        // incrementAndGet 구현
        int resultValue1 = incrementAndGet(atomicInteger);
        System.out.println("resultValue1 = " + resultValue1);

        int resultValue2 = incrementAndGet(atomicInteger);
        System.out.println("resultValue2 = " + resultValue2);
    }

    private static int incrementAndGet(AtomicInteger atomicInteger) {
        int getValue;
        boolean result;
        do {
            getValue = atomicInteger.get();
            log("getValue: " + getValue);
            result = atomicInteger.compareAndSet(getValue, getValue + 1);
            log("result: " + result);
        } while (!result);
        return getValue + 1;
    }
}
```
여기서 만든 incrementAndGet() 은 atomicInteger 내부의 value 값을 하나 증가하는 메서드이다. 사실
atomicInteger 도 이 메서드를 제공하지만, 여기서는 이해를 위해 직접 구현해보자.

CAS 연산을 사용하면 여러 스레드가 같은 값을 사용하는 상황에서도 락을 걸지 않고, 안전하게 값을 증가할 수 있다.
여기서는 락을 걸지 않고 CAS 연산을 사용해서 값을 증가했다.
- getValue = atomicInteger.get() 을 사용해서 value 값을 읽는다.
- compareAndSet(getValue, getValue + 1) 을 사용해서, 방금 읽은 value 값이 메모리의 value 값과 같다면 value 값을 하나 증가한다. 여기서 CAS 연산을 사용한다.
- 만약 CAS 연산이 성공한다면 true 를 반환하고 do~while 문을 빠져나온다. 
- 만약 CAS 연산이 실패한다면 false 를 반환하고 do~while 문을 다시 시작한다.

#### 실행 결과
```
start value = 0
17:48:20.440 [ main] getValue: 0
17:48:20.442 [ main] result: true
resultValue1 = 1
17:48:20.442 [ main] getValue: 1
17:48:20.442 [ main] result: true
resultValue2 = 2
```

지금은 순서대로 실행되기 때문에, 결과는 다음과 같다.
#### incrementAndGet 첫 번째 실행
- atomicInteger.get() 을 사용해서 value 값을 읽는다. getValue 는 0이다.
- compareAndSet(0,1) 을 수행한다.
  - compareAndSet(getValue, getValue + 1)
- CAS 연산이 성공했으므로 value 값은 0에서 1로 증가하고 true 를 반환한다.
- do~while 문을 빠져나간다.

#### incrementAndGet 두 번째 실행
- atomicInteger.get() 을 사용해서 value 값을 읽는다. getValue 는 1이다.
- compareAndSet(1,2) 을 수행한다.
- compareAndSet(getValue, getValue + 1)
- CAS 연산이 성공했으므로 value 값은 1에서 2로 증가하고 true 를 반환한다.
- do~while 문을 빠져나간다.

지금은 main 스레드 하나로 순서대로 실행되기 때문에 CAS 연산이 실패하는 상황을 볼 수 없다. 우리가 기대하는 실패하는 상황은 연산의 중간에 
다른 스레드가 값을 변경해버리는 것이다. 멀티스레드로 실행해서 CAS 연산이 실패하는 경우에 어떻게 작동하는지 알아보자.

## CAS 연산3
멀티스레드를 사용해서 중간에 다른 스레드가 먼저 값을 증가시켜 버리는 경우를 알아보자. 그리고 CAS 연산이 실패하는 경우에 어떻게 되는지 알아보자. 
이 경우에도 값을 정상적으로 증가시킬 수 있을까?

```java
package thread.cas;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;
import static util.MyLogger.log;
import static util.ThreadUtils.sleep;

public class CasMainV3 {
    private static final int THREAD_COUNT = 2;

    public static void main(String[] args) throws InterruptedException {
        AtomicInteger atomicInteger = new AtomicInteger(0);
        System.out.println("start value = " + atomicInteger.get());

        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                incrementAndGet(atomicInteger);
            }
        };

        List<Thread> threads = new ArrayList<>();
        for (int i = 0; i < THREAD_COUNT; i++) {
            Thread thread = new Thread(runnable);
            threads.add(thread);
            thread.start();
        }

        for (Thread thread : threads) {
            thread.join();
        }

        int result = atomicInteger.get();
        System.out.println(atomicInteger.getClass().getSimpleName() + " resultValue: " + result);
    }

    private static int incrementAndGet(AtomicInteger atomicInteger) {
        int getValue;
        boolean result;
        do {
            getValue = atomicInteger.get();
            sleep(100); // 스레드 동시 실행을 위한 대기
            log("getValue: " + getValue);
            result = atomicInteger.compareAndSet(getValue, getValue + 1);
            log("result: " + result);
        } while (!result);
        return getValue + 1;
    }
}
```
- 2개의 스레드가 incrementAndGet() 를 호출해서 AtomicInteger 내부의 value 값을 동시에 하나씩 증가시킨다.
- 이때 두 스레드는 incrementAndGet() 메서드를 함께 호출한다. 여기서 스레드가 동시에 같은 값을 읽고 CAS를 수행하는 
  상황을 쉽게 만들기위해 중간에 sleep() 코드를 추가했다.

#### 실행 결과
```
start value = 0
18:13:37.623 [ Thread-1] getValue: 0
18:13:37.623 [ Thread-0] getValue: 0
18:13:37.625 [ Thread-1] result: true
18:13:37.625 [ Thread-0] result: false
18:13:37.731 [ Thread-0] getValue: 1
18:13:37.731 [ Thread-0] result: true
AtomicInteger resultValue: 2
```
실행 결과를 보면 마지막에 AtomicInteger 가 정상적으로 2 증가된 것을 확인할 수 있다.

두 스레드의 실행 결과를 분석해보자. 보기 쉽게 스레드 별로 로그를 나누었다.

#### Thread-1 실행
```
18:13:37.623 [ Thread-1] getValue: 0
18:13:37.625 [ Thread-1] result: true
```
- atomicInteger.get() 을 사용해서 value 값을 읽는다. getValue 는 0이다.
- compareAndSet(0,1) 을 수행한다.
  - compareAndSet(getValue, getValue + 1)
- CAS 연산이 성공했으므로 value 값은 0에서 1로 증가하고 true 를 반환한다.
- do~while 문을 빠져나간다.

#### Thread-0 실행
```
//[Thread-0] do~while 첫 번째 시도
18:13:37.623 [ Thread-0] getValue: 0
18:13:37.625 [ Thread-0] result: false

//[Thread-0] do~while 두 번째 시도
18:13:37.731 [ Thread-0] getValue: 1
18:13:37.731 [ Thread-0] result: true
```

#### [Thread-0] do~while 첫 번째 시도
- atomicInteger.get() 을 사용해서 value 값을 읽는다. getValue 는 0이다.
- compareAndSet(0,1) 을 수행한다.
  - compareAndSet(getValue, getValue + 1)
- 그런데 compareAndSet(0,1) 연산은 실패한다.
  - CAS 연산에서 현재 value 값으로 0을 기대했지만 Thread-1 이 중간에 먼저 실행되면서 value 의 값을 0 1로 변경해버렸다.
- CAS 연산이 실패했으므로 value 값은 변경하지 않고, false 를 반환한다.
- 실패했으므로 do~while 문을 빠져나가지 못한다. do~while 문을 다시 시작한다.
  - while (!result) while(!false) while(true) 이므로 다시 반복

#### [Thread-0] do~while 두 번째 시도
- do~while 문이 다시 시작된다.
- atomicInteger.get() 을 사용해서 value 값을 읽는다. getValue 는 1이다.
- compareAndSet(1,2) 을 수행한다.
  - compareAndSet(getValue, getValue + 1)
- CAS 연산이 성공했으므로 value 값은 1에서 2로 증가하고 true 를 반환한다.
- do~while 문을 빠져나간다.

#### 정리
AtomicInteger 가 제공하는 incrementAndGet() 코드도 앞서 우리가 직접 작성한 incrementAndGet() 코드와 똑같이 CAS를 활용하도록 작성되어 있다. 
CAS를 사용하면 락을 사용하지 않지만, 대신에 다른 스레드가 값을 먼저 증가해서 문제가 발생하는 경우 루프를 돌며 재시도를 하는 방식을 사용한다.

이 방식은 다음과 같이 동작한다
1. 현재 변수의 값을 읽어온다.
2. 변수의 값을 1 증가시킬 때, 원래 값이 같은지 확인한다. (CAS 연산 사용)
3. 동일하다면 증가된 값을 변수에 저장하고 종료한다.
4. 동일하지 않다면 다른 스레드가 값을 중간에 변경한 것이므로, 다시 처음으로 돌아가 위 과정을 반복한다.

두 스레드가 동시에 실행되면서 문제가 발생하는 상황을 스레드가 충돌했다고 표현한다.
이 과정에서 충돌이 발생할 때마다 반복해서 다시 시도하므로, 결과적으로 락 없이 데이터를 안전하게 변경할 수 있다.
CAS를 사용하는 방식은 충돌이 드물게 발생하는 환경에서는 락을 사용하지 않으므로 높은 성능을 발휘할 수 있다. 
이는 락을 사용하는 방식과 비교했을 때, 스레드가 락을 획득하기 위해 대기하지 않기 때문에 대기 시간과 오버헤드가 줄어드는 장점이 있다.

그러나 충돌이 빈번하게 발생하는 환경에서는 성능에 문제가 될 수 있다. 여러 스레드가 자주 동시에 동일한 변수의 값을 변경하려고 시도할 때, 
CAS는 자주 실패하고 재시도해야 하므로 성능 저하가 발생할 수 있다. 이런 상황에서는 반복문을 계속 돌기 때문에 CPU 자원을 많이 소모하게 된다.

### CAS(Compare-And-Swap)와 락(Lock) 방식의 비교
#### 락(Lock) 방식
- 비관적(pessimistic) 접근법
- 데이터에 접근하기 전에 항상 락을 획득
- 다른 스레드의 접근을 막음
- "다른 스레드가 방해할 것이다"라고 가정

#### CAS(Compare-And-Swap) 방식
- 낙관적(optimistic) 접근법
- 락을 사용하지 않고 데이터에 바로 접근
- 충돌이 발생하면 그때 재시도
- "대부분의 경우 충돌이 없을 것이다"라고 가정

정리하면 충돌이 많이 없는 경우에 CAS 연산이 빠른 것을 확인할 수 있다.
그럼 충돌이 많이 발생하지 않는 연산은 어떤 것이 있을까? 언제 CAS 연산을 사용하면 좋을까?
사실 간단한 CPU 연산은 너무 빨리 처리되기 때문에 충돌이 자주 발생하지 않는다. 충돌이 발생하기도 전에 이미 연산을 완료하는 경우가 더 많다.

앞서 여러 스레드가 value++ 연산을 수행했던 BasicInteger , VolatileInteger 의 예를 보자.

#### 실행 결과
```
BasicInteger result: 950
VolatileInteger result: 961
SyncInteger result: 1000
MyAtomicInteger result: 1000
```

이 경우 최대한 많이 충돌하게 만들기 위해 1000개의 스레드를 동시에 쉬게 만든 다음에 동시에 실행했다.
```
sleep(10); //너무 빨리 실행되기 때문에, 다른 스레드와 동시 실행을 위해 잠깐 쉬었다가 실행
incrementInteger.increment();
```

BasicInteger 의 실행 결과를 보면 최대한 스레드를 충돌하게 만들었는데도, 1000개 중에 약 50개의 스레드만 충돌한 사실을 확인할 수 있다.

#### 락 방식
- 스레드 충돌을 방지하기 위해 1000개의 스레드가 모두 락을 획득하고 반환하는 과정을 거친다.
- 락을 사용하기 때문에 1000개의 스레드는 순서대로 하나씩 수행된다.
- 사실 이 중에 스레드가 충돌하는 경우는 50개의 경우 뿐이다.

#### CAS 방식
- 1000개의 스레드를 모두 한 번에 실행한다.
- 그리고 충돌이 나는 50개의 경우만 재시도 한다.

이 예제는 억지로 충돌을 만들기 위해서 sleep(10) 을 넣었다. 만약 이 코드를 제거한다면 충돌 가능성은 100개 중에 1개도 안될 것이다.

정리하면 간단한 CPU 연산에는 락 보다는 CAS를 사용하는 것이 효과적이다.