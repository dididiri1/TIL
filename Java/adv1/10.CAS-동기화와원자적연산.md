# 10. CAS-동기화와 원자적 연산
- [/원자적 연산 - 소개](#원자적-연산---소개)
- [/원자적 연산 - 시작](#원자적-연산---시작)
- [/원자적 연산 - volatile, synchronized](#원자적-연산---volatile-synchronized)
- [/원자적 연산 - AtomicInteger](#원자적-연산---atomicinteger)
- [/CAS 연산1](#cas-연산1)
- [/CAS 연산2](#cas-연산2)
- [/CAS 연산3](#cas-연산3)
- [/CAS 락 구현1](#cas-락-구현1)
- [/CAS 락 구현2](#cas-락-구현2)
- [/정리](#정리)

## 원자적 연산 - 소개
컴퓨터 과학에서 사용하는 원자적 연산(atomic operation)의 의미는 해당 연산이 더 이상 나눌 수 없는 단위로 수행된 다는 것을 의미한다. 
즉, 원자적 연산은 중단되지 않고, 다른 연산과 간섭 없이 완전히 실행되거나 전혀 실행되지 않는 성질을 가지고 있다. 
쉽게 이야기해서 멀티스레드 상황에서 다른 스레드의 간섭 없이 안전하게 처리되는 연산이라는 뜻 이다.

> **참고**: 과거에 원자는 더 이상 나눌 수 없는 가장 작은 단위로 여겨졌다. 그래서 더는 나눌 수 없다는 뜻으로 **원자적 연산**이라는 단어를 사용한다. 
> 물론 현대 물리학에서는 원자가 더 작은 입자들로 구성되어 있다는 것이 밝혀졌다. 하지만 원자적 연산이라는 단어는 그대로 사용한다.

예를 들어서 다음과 같은 필드가 있을 때
volatile int i = 0;

다음 연산은 둘로 쪼갤 수 없는 원자적 연산이다.
- i = 1
왜냐하면 이 연산은 다음 단 하나의 순서로 실행되기 때문이다.
1. 오른쪽에 있는 1 의 값은 왼쪽의 i 변수에 대입한다.

하지만 다음 연산은 원자적 연산이 아니다.
```
i = i + 1;
```
왜냐하면 이 연산은 다음 순서로 나누어 실행되기 때문이다.
1. 오른쪽에 있는 i 의 값을 읽는다. i 의 값은 10이다.
2. 읽은 10에 1을 더해서 11을 만든다.
3. 더한 11을 왼쪽의 i 변수에 대입한다.

원자적 연산은 멀티스레드 상황에서 아무런 문제가 발생하지 않는다. 하지만 원자적 연산이 아닌 경우에는
synchronized 블럭이나 Lock 등을 사용해서 안전한 임계 영역을 만들어야 한다.

#### 순서대로 실행
예를 들어서 2개의 스레드가 해당 로직을 수행하는데, 하나가 완전히 끝나고 나서, 나머지 하나가 수행된다고 가정해보자.
```
처음에 i = 0이라고 가정하겠다.

스레드1: i = i + 1 연산 수행
스레드1: i의 값을 읽는다. i는 0이다.
스레드1: 읽은 0에 1을 더해서 1을 만든다.
스레드1: 더한 1을 왼쪽의 i변수에 대입한다.
결과: i의 값은 1이다.

스레드2: i = i + 1 연산 수행
스레드2: i의 값을 읽는다. i는 1이다.
스레드2: 읽은 1에 1을 더해서 2을 만든다.
스레드2: 더한 2을 왼쪽의 i변수에 대입한다.
결과: i의 값은 2이다.
```
2개의 스레드가 각각 한 번 연산을 수행했으므로 변수 i 의 값은 0 2가 된다.

#### 동시에 실행
이번에는 문제가 되는 경우를 알아보자. 2개의 스레드가 해당 로직을 동시에 함께 수행하면, 문제가 발생한다.
```
처음에 i = 0이라고 가정하겠다.

스레드1: i = i + 1 연산 수행
스레드2: i = i + 1 연산 수행
스레드1: i의 값을 읽는다. i는 0이다.
스레드2: i의 값을 읽는다. i는 0이다.
스레드1: 읽은 0에 1을 더해서 1을 만든다.
스레드2: 읽은 0에 1을 더해서 1을 만든다.
스레드1: 더한 1을 왼쪽의 i변수에 대입한다.
스레드2: 더한 1을 왼쪽의 i변수에 대입한다.
결과: i의 값은 1이다.
```
2개의 스레드가 각각 한 번 연산을 수행했지만 변수 i 의 값은 0 1이 된다. 한 번의 연산이 사라진 것이다.

그렇다면 다음 연산은 원자적 연산일까?
i++

이 연산은 원자적 연산처럼 보이지만 사실은 원자적 연산이 아니다. 왜냐하면 이 연산은 앞서 살펴본 i = i + 1 을 축약한 것이기 때문이다. 
결과적으로 i++ 은 i = i + 1 와 똑같이 동작한다.

## 원자적 연산 - 시작
원자적이지 않은 연산을 멀티스레드 환경에서 실행하면 어떤 문제가 발생하는지 코드로 알아보자.
IncrementInteger 는 숫자 값을 하나씩 증가시키는 기능을 제공한다. 예를 들어서 지금까지 접속한 사용자의 수 등
을 계산할 때 사용할 수 있다.

```java
package thread.cas.increment;

public interface IncrementInteger {
    void increment();
    
    int get();
}
```
- IncrementInteger 는 값을 증가하는 기능을 가진 숫자 기능을 제공하는 인터페이스다.
- increment() : 값을 하나 증가
- get() : 값을 조회

```java
public class BasicInteger implements IncrementInteger {

    private int value;

    @Override
    public void increment() {
        value++;
    }

    @Override
    public int get() {
        return value;
    }
}
```
- IncrementInteger 인터페이스의 가장 기본 구현이다.
- increment() 를 호출하면 value++ 를 통해서 값을 하나 증가한다.
  - value 값은 인스턴스의 필드이기 때문에, 여러 스레드가 공유할 수 있다. 이렇게 공유 가능한 자원에 ++ 와 같은 원자적이지 않은 
    연산을 사용하면 멀티스레드 상황에 문제가 될 수 있다.

```java
package thread.cas.increment;

import java.util.ArrayList;
import java.util.List;
import static util.ThreadUtils.sleep;

public class IncrementThreadMain {

    public static final int THREAD_COUNT = 1000;

    public static void main(String[] args) throws InterruptedException {
        test(new BasicInteger());
    }

    private static void test(IncrementInteger incrementInteger) throws InterruptedException {
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                sleep(10); // 너무 빨리 실행되기 때문에, 다른 스레드와 동시 실행을 위해 잠깐 쉬었다가 실행
                incrementInteger.increment();
            }
        };

        List<Thread> threads = new ArrayList<>();
        for (int i = 0; i < THREAD_COUNT; i++) {
            Thread thread = new Thread(runnable);
            threads.add(thread);
            thread.start();
        }

        for (Thread thread : threads) {
            thread.join();
        }

        int result = incrementInteger.get();
        System.out.println(incrementInteger.getClass().getSimpleName() + " result: " + result);
    }
}
```
- THREAD_COUNT 수 만큼 스레드를 생성하고 incrementInteger.increment() 를 호출한다.
- 스레드를 1000개 생성했다면, increment() 메서드도 1000번 호출하기 때문에 결과는 1000이 되어야 한다.
- 참고로 스레드가 너무 빨리 실행되기 때문에, 여러 스레드가 동시에 실행되는 상황을 확인하기 어렵다. 그래서 run() 메서드에 sleep(10) 을 두어서, 
  최대한 많은 스레드가 동시에 increment() 를 호출하도록 한다.

#### 실행 결과
```
BasicInteger result: 950
```
실행 결과를 보면 기대한 1000이 아니라 다른 숫자가 보인다. 아마도 실행 환경에 따라서 다르겠지만 1000이 아니라 조금 더 적은 숫자가 보일 것이다. 
물론 실행 환경에 따라서 1000이 보일 수도 있다. 이 문제는 앞서 설명한 것 처럼 여러 스레드가 동시에 원자적이지 않은 value++ 을 호출했기 때문에 발생한다.
그럼 혹시 volatile 을 적용하면 될까?

## 원자적 연산 - volatile, synchronized
### 예제 - volatile
다음과 같이 VolatileInteger 클래스를 만들고, volatile 을 적용해보자.
```java
package thread.cas.increment;

public class VolatileInteger implements IncrementInteger {

    private volatile int value;

    @Override
    public void increment() {
        value++;
    }

    @Override
    public int get() {
        return value;
    }
}
```
- BasicInteger 와 같고 volatile 만 적용해주었다.

#### IncrementThreadMain에 추가
```java
public class IncrementThreadMain {
    public static void main(String[] args) throws InterruptedException {
        test(new BasicInteger());
        test(new VolatileInteger()); // 추가
    }
    //...
}
```
- test(new VolatileInteger()); 를 한 줄 추가하고 실행해보자.

#### 실행 결과
```
BasicInteger result: 950
VolatileInteger result: 961
```
실행 결과를 보면 VolatileInteger 도 여전히 1000이 아니라 더 작은 숫자가 나온다.
volatile 은 여러 CPU 사이에 발생하는 캐시 메모리와 메인 메모리가 동기화 되지 않는 문제를 해결할 뿐이다.
volatile 을 사용하면 CPU의 캐시 메모리를 무시하고, 메인 메모리를 직접 사용하도록 한다. 하지만 지금 이 문제는
캐시 메모리가 영향을 줄 수는 있지만, 캐시 메모리를 사용하지 않고, 메인 메모리를 직접 사용해도 여전히 발생하는 문제이다.
이 문제는 연산 자체가 나누어져 있기 때문에 발생한다. volatile 은 연산 자제를 원자적으로 묶어주는 기능이 아니다.

이렇게 연산 자체가 나누어진 경우에는 synchronized 블럭이나 Lock 등을 사용해서 안전한 임계 영역을 만들어야 한다.

### 예제 - synchronized
다음과 같이 SyncInteger 클래스를 만들고 synchronized 를 적용해서 안전한 임계 영역을 만들어보자
```java
package thread.cas.increment;

public class SyncInteger implements IncrementInteger {

    private int value;

    @Override
    public synchronized void increment() {
        value++;
    }

    @Override
    public synchronized int get() {
        return value;
    }
}
```
- value++ 연산은 synchronized 를 통해 임계 영역 안에서 안전하게 수행된다. 쉽게 이야기해서 한 번에 하나 의 스레드만 해당 연산을 수행할 수 있다.

#### IncrementThreadMain에 추가
```java
public class IncrementThreadMain {

    public static void main(String[] args) throws InterruptedException {
        test(new BasicInteger());
        test(new VolatileInteger());
        test(new SyncInteger()); // 추가
    }

    //...
}
```

#### 실행 결과
```
BasicInteger result: 950
VolatileInteger result: 961
SyncInteger result: 1000
```
synchronized 를 통해 안전한 임계 영역을 만들고 value++ 연산을 수행했더니 정확히 1000이라는 결과가 나왔다. 1000개의 스레드가 안전하게
value++ 연산을 수행한 것이다.


## 원자적 연산 - AtomicInteger
자바는 앞서 만든 SyncInteger 와 같이 멀티스레드 상황에서 안전하게 증가 연산을 수행할 수 있는 AtomicInteger 라는 클래스를 제공한다. 
이름 그대로 원자적인 Integer 라는 뜻이다. 다음과 같이 MyAtomicInteger 클래스를 만들고, 자바가 제공하는 AtomicInteger 를 사용해보자.

```java
package thread.cas.increment;

import java.util.concurrent.atomic.AtomicInteger;

public class MyAtomicInteger implements IncrementInteger {

    AtomicInteger atomicInteger = new AtomicInteger(0);

    @Override
    public void increment() {
        atomicInteger.incrementAndGet();
    }

    @Override
    public int get() {
        return atomicInteger.get();
    }
}
```
- new AtomicInteger(0) : 초기값을 지정한다. 생략하면 0 부터 시작한다.
- incrementAndGet() : 값을 하나 증가하고 증가된 결과를 반환한다. 
- get() : 현재 값을 반환한다.

#### IncrementThreadMain에 추가
```java
public class IncrementThreadMain {
    public static void main(String[] args) throws InterruptedException {
        test(new BasicInteger());
        test(new VolatileInteger());
        test(new SyncInteger());
        test(new MyAtomicInteger()); // 추가
    }
    //...
}
```

#### 실행 결과
```
BasicInteger result: 950
VolatileInteger result: 961
SyncInteger result: 1000
MyAtomicInteger result: 1000
```
실행 결과를 보면 AtomicInteger 를 사용하면 MyAtomicInteger 의 결과도 1000인 것을 확인할 수 있다.
1000개의 스레드가 안전하게 증가 연산을 수행한 것이다.

AtomicInteger 는 멀티스레드 상황에 안전하고 또 다양한 값 증가, 감소 연산을 제공한다. 특정 값을 증가하거나 감소해야 하는데 
여러 스레드가 해당 값을 공유해야 한다면, AtomicInteger 를 사용하면 된다.

> 참고: AtomicInteger , AtomicLong , AtomicBoolean 등 다양한 AtomicXxx 클래스가 존재한다.

## 원자적 연산 - 성능 테스트
이제 AtomicInteger 의 진짜 모습을 하나씩 알아보자.
우선 AtomicInteger 와 우리가 직접 만든 각 클래스의 성능을 비교해보자.

```java
package thread.cas.increment;

public class IncrementPerformanceMain {
    public static final long COUNT = 100_000_000;

    public static void main(String[] args) {
        test(new BasicInteger());
        test(new VolatileInteger());
        test(new SyncInteger());
        test(new MyAtomicInteger());
    }

    private static void test(IncrementInteger incrementInteger) {
        long startMs = System.currentTimeMillis();
        for (long i = 0; i < COUNT; i++) {
            incrementInteger.increment();
        }
        long endMs = System.currentTimeMillis();
        System.out.println(incrementInteger.getClass().getSimpleName() + ": ms=" + (endMs - startMs));
    }
}
```
- 단일 연산은 너무 빠르기 때문에 성능을 확인하려면 어느 정도 반복적인 연산이 필요하다.
- 각각 COUNT 만큼 반복해서 연산을 수행해 보자. 여기서는 1억 번 값 증가 연산을 수행했다.

#### 실행 결과
```
BasicInteger: ms=39
VolatileInteger: ms=455
SyncInteger: ms=625
MyAtomicInteger: ms=367
```

#### BasicInteger
- 가장 빠르다.
- CPU 캐시를 적극 사용한다. CPU 캐시의 위력을 알 수 있다.
- 안전한 임계 영역도 없고, volatile 도 사용하지 않기 때문에 멀티스레드 상황에는 사용할 수 없다.
- 단일 스레드가 사용하는 경우에 효율적이다.

#### VolatileInteger
- volatile 을 사용해서 CPU 캐시를 사용하지 않고 메인 메모리를 사용한다.
- 안전한 임계 영역이 없기 때문에 멀티스레드 상황에는 사용할 수 없다.
- 단일 스레드가 사용하기에는 BasicInteger 보다 느리다. 그리고 멀티스레드 상황에도 안전하지 않다.

#### SyncInteger
- synchronized 를 사용한 안전한 임계 영역이 있기 때문에 멀티스레드 상황에도 안전하게 사용할 수 있다.
- MyAtomicInteger 보다 성능이 느리다.

#### MyAtomicInteger
- 자바가 제공하는 AtomicInteger 를 사용한다. 멀티스레드 상황에 안전하게 사용할 수 있다.
- 성능도 synchronized, Lock(ReentrantLock) 을 사용하는 경우보다 1.5 ~ 2배 정도 빠르다.

SyncInteger 처럼 락을 사용하는 경우보다, AtomicInteger 가 더 빠른 이유는 무엇일까? i++ 연산은 원자적인 연산이 아니다. 
따라서 분명히 synchronized , Lock(ReentrantLock) 와 같은 락을 통해 안전한 임계 영역을 만들어야 할 것 같다.
놀랍게도 AtomicInteger 가 제공하는 incrementAndGet() 메서드는 락을 사용하지 않고, 원자적 연산을 만들어낸다.





![](https://github.com/dididiri1/TIL/blob/main/Java/adv1/images/08_02.png?raw=true)

