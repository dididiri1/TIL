# 4. 스레드 제어와 생명 주기2
- [인터럽트 - 시작](#인터럽트---시작)
- [인터럽트 - 시작2](#인터럽트---시작2)
- [인터럽트 - 시작3](#인터럽트---시작3)
- [인터럽트 - 시작4](#인터럽트---시작4)
- [프린터 예제1 - 시작](#프린터-예제1---시작)
- [프린터 예제2 - 인터럽트 도입](#프린터-예제2---인터럽트-도입)
- [프린터 예제3 - 인터럽트 코드 개선](#프린터-예제3---인터럽트-코드-개선)
- [yield - 양보하기](#yield---양보하기)
- [프린터 예제4 - yield 도입](#프린터-예제4---yield-도입)
- [정리](#정리)

## 인터럽트 - 시작1
특정 스레드의 작업을 중간에 중단하려면 어떻게 해야할까?
다음 코드를 보자.
```java
package thread.control.interrupt;

import static util.MyLogger.log;
import static util.ThreadUtils.sleep;

public class ThreadStopMainV1 {

    public static void main(String[] args) {
        MyTask task = new MyTask();
        Thread thread = new Thread(task, "work");
        thread.start();

        sleep(4000);
        log("작업 중단 지시 runFlag=false");
        task.runFlag = false;
    }

    static class MyTask implements Runnable {
        volatile boolean runFlag = true;

        @Override
        public void run() {
            while (runFlag) {
                log("작업 중");
                sleep(3000);
            }
            log("자원 정리");
            log("작업 종료");
        }
    }
}
```
- 특정 스레드의 작업을 중단하는 가장 쉬운 방법은 변수를 사용하는 것이다.
- 여기서는 runFlag 를 사용해서 work 스레드에 작업 중단을 지시할 수 있다.
- 작업 하나에 3초가 걸린다고 가정하고, sleep(3000) 을 사용하자.
- main 스레드는 4초 뒤에 작업 중단을 지시한다.
- volatile 키워드는 뒤에서 자세히 설명한다. 지금은 단순히 여러 스레드에서 공유하는 값에 사용하는 키워드라고 알아두자.

#### 실행 결과
```
14:58:27.520 [ work] 작업 중
14:58:30.525 [ work] 작업 중
14:58:31.510 [ main] 작업 중단 지시 runFlag=false
14:58:33.532 [ work] 자원 정리
14:58:33.533 [ work] 작업 종료
```

![](https://github.com/dididiri1/TIL/blob/main/Java/adv1/images/04_01.png?raw=true)
- work 스레드는 runFlag 가 true 인 동안 계속 실행된다.

![](https://github.com/dididiri1/TIL/blob/main/Java/adv1/images/04_02.png?raw=true)
- 프로그램 시작 후 4초 뒤에 main 스레드는 runFlag 를 false 로 변경한다.
- work 스레드는 while(runFlag) 에서 runFlag 의 조건이 false 로 변한 것을 확인하고, while문을 빠져나가면서 작업을 종료한다.

#### 문제점
실행을 해보면 알겠지만 main 스레드가 runFlag=false 를 통해 작업 중단을 지시해도, work 스레드가 즉각 반응하지 않는다. 
로그를 보면 작업 중단 지시 2초 정도 이후에 자원을 정리하고 작업을 종료한다.
```
14:58:27.520 [     work] 작업 중
14:58:30.525 [     work] 작업 중
14:58:31.510 [     main] 작업 중단 지시 runFlag=false
14:58:33.532 [     work] 자원 정리 //2초 정도 경과후 실행
14:58:33.533 [     work] 작업 종료
```

이 방식의 가장 큰 문제는 다음 코드의 sleep() 에 있다.
```
while (runFlag) {
    log("작업 중");
    sleep(3000);
}
```
- main 스레드가 runFlag 를 false 로 변경해도, work 스레드는 sleep(3000) 을 통해 3초간 잠들어 있다. 
  3초간의 잠이 깬 다음에 while(runFlag) 코드를 실행해야, runFlag 를 확인하고 작업을 중단할 수 있다.
- 참고로 runFlag 를 변경한 후 2초라는 시간이 지난 이후에 작업이 종료되는 이유는 work 스레드가 3초에 한번씩 깨어나서 runFlag 를 확인하는데, 
  main 스레드가 4초에 runFlag 를 변경했기 때문이다.
  - work 스레드 입장에서 보면 두 번째 sleep() 에 들어가고 1초 후 main 스레드가 runFlag 를 변경한다. 3초간 sleep() 이므로 아직 
    2초가 더 있어야 깨어난다.

어떻게 하면 sleep() 처럼 스레드가 대기하는 상태에서 스레드를 깨우고, 작업도 빨리 종료할 수 있을까?

## 인터럽트 - 시작2
예를 들어서, 특정 스레드가 Thread.sleep() 을 통해 쉬고 있는데, 처리해야 하는 작업이 들어와서 해당 스레드를 급하게 깨워야 할 수 있다. 
또는 sleep() 으로 쉬고 있는 스레드에게 더는 일이 없으니, 작업 종료를 지시할 수도 있다.
인터럽트를 사용하면, WAITING , TIMED_WAITING 같은 대기 상태의 스레드를 직접 깨워서, 작동하는 RUNNABLE 상태로 만들 수 있다.
앞서 작성한 예제의 작업 중단 지시를 인터럽트를 통해 처리해보자.
```java
package thread.control.interrupt;

import static util.MyLogger.log;
import static util.ThreadUtils.sleep;

public class ThreadStopMainV2 {

    public static void main(String[] args) {
        MyTask task = new MyTask();
        Thread thread = new Thread(task, "work");
        thread.start();

        sleep(4000);
        log("작업 중단 지시 thread.interrupt()");
        thread.interrupt();
        log("work 스레드 인터럽트 상태1 = " + thread.isInterrupted());
    }

    static class MyTask implements Runnable {
        @Override
        public void run() {
            try {
                while (true) {
                    log("작업 중");
                    Thread.sleep(3000);
                }
            } catch (InterruptedException e) {
                log("work 스레드 인터럽트 상태2 = " + Thread.currentThread().isInterrupted());
                log("interrupt message = " + e.getMessage());
                log("state = " + Thread.currentThread().getState());
            }
            log("자원 정리");
            log("작업 종료");
        }
    }
}
```
- 예제의 run() 에서는 인터럽트를 이해하기 위해, 직접 만든 sleep() 대신에 Thread.sleep() 를 사용하고, try ~ catch 도 사용하자.
- 특정 스레드의 인스턴스에 interrupt() 메서드를 호출하면, 해당 스레드에 인터럽트가 발생한다.
- 인터럽트가 발생하면 해당 스레드에 InterruptedException 이 발생한다.
  - 이때 인터럽트를 받은 스레드는 대기 상태에서 깨어나 RUNNABLE 상태가 되고, 코드를 정상 수행한다.
  - 이때 InterruptedException 을 catch 로 잡아서 정상 흐름으로 변경하면 된다.
- 참고로 interrupt() 를 호출했다고 해서 즉각 InterruptedException 이 발생하는 것은 아니다. 
  오직 sleep() 처럼 InterruptedException 을 던지는 메서드를 호출 하거나 또는 호출 중일 때 예외가 발생한다.
  - 예를 들어서 위 코드에서 while(true) , log("작업 중") 에서는 InterruptedException 이 발생 하지 않는다.
  - Thread.sleep() 처럼 InterruptedException 을 던지는 메서드를 호출하거나 또는 호출하며 대기중일 때 예외가 발생한다.

#### 실행 결과
```
18:10:40.024 [    work] 작업 중
18:10:43.026 [    work] 작업 중
18:10:44.011 [    main] 작업 중단 지시 thread.interrupt()
18:10:44.021 [    main] work 스레드 인터럽트 상태1 = true
18:10:44.021 [    work] work 스레드 인터럽트 상태2 = false
18:10:44.022 [    work] interrupt message=sleep interrupted
18:10:44.022 [    work] state=RUNNABLE
18:10:44.022 [    work] 자원 정리
18:10:44.023 [    work] 작업 종료
```
- 일부 로그를 보기 쉽게 조정했다.
- thread.interrupt() 를 통해 작업 중단을 지시를 하고, 거의 즉각적으로 인터럽트가 발생한 것을 확인할 수 있다.
- 이때 work 스레드는 TIMED_WAITING RUNNABLE 상태로 변경되면서 InterruptedException 예외가 발생한다.
  - 참고로 스레드가 RUNNABLE 상태여야 catch 의 예외 코드도 실행될 수 있다.
- 실행 결과를 보면 work 스레드가 catch 블럭 안에서 RUNNABLE 상태로 바뀐 것을 확인할 수 있다.

![](https://github.com/dididiri1/TIL/blob/main/Java/adv1/images/04_03.png?raw=true)
- main 스레드가 4초 뒤에 work 스레드에 interrupt() 를 건다.
- work 스레드는 인터럽트 상태( true )가 된다.
- 스레드가 인터럽트 상태일 때는, sleep() 처럼 InterruptedException 이 발생하는 메서드를 호출하거나 또는 이미 호출하고 대기 중이라면 
  InterruptedException 이 발생한다.
- 이때 2가지 일이 발생한다.
  - work 스레드는 TIMED_WAITING 상태에서 RUNNABLE 상태로 변경되고, InterruptedException 예외를 처리하면서 반복문을 탈출한다.
  - work 스레드는 인터럽트 상태가 되었고, 인터럽트 상태이기 때문에 인터럽트 예외가 발생한다.
  - 인터럽트 상태에서 인터럽트 예외가 발생하면 work 스레드는 다시 작동하는 상태가 된다. 따라서 work 스레드의 인터럽트 상태는 종료된다.
    - work 스레드의 인터럽트 상태는 false 로 변경된다.

#### 주요 로그
```
10:14:49.409 [     main] work 스레드 인터럽트 상태1 = true //여기서 인터럽트 발생
10:14:49.410 [     work] work 스레드 인터럽트 상태2 = false
10:14:49.414 [     work] state=RUNNABLE
```
- 인터럽트가 적용되고, 인터럽트 예외가 발생하면, 해당 스레드는 실행 가능 상태가 되고, 인터럽트 발생 상태도 정상으로 돌아온다.
- 인터럽트를 사용하면 대기중인 스레드를 바로 깨워서 실행 가능한 상태로 바꿀 수 있다. 덕분에 단순히 runFlag 를 사용하는 이전 방식보다 
  반응성이 좋아진 것을 확인할 수 있다.


