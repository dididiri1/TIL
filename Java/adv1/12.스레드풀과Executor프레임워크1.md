# 12. 스레드풀과 Executor 프레임워크1
- [스레드를 직접 사용할 때의 문제점](#스레드를-직접-사용할-때의-문제점)
- [Executor 프레임워크 소개](#executor-프레임워크-소개)
- [ExecutorService 코드로 시작하기](#executorservice-코드로-시작하기)
- [Runnable의 불편함](#runnable의-불편함)
- [Future1 - 시작](#future1---시작)
- [Future2 - 분석](#future2---분석)
- [Future3 - 활용](#future3---활용)
- [Future4 - 이유](#future4---이유)
- [Future5 - 정리](#future5---정리)
- [Future6 - 취소](#future6---취소)
- [Future7 - 예외](#future7---예외)
- [ExecutorService - 작업 컬렉션 처리](#executorservice---작업-컬렉션-처리)
- [문제와 풀이](#문제와-풀이)
- [정리](#정리)



## 스레드를 직접 사용할 때의 문제점
실무에서 스레드를 직접 생성해서 사용하면 다음과 같은 3가지 문제가 있다.
1. 스레드 생성 시간으로 인한 성능 문제
2. 스레드 관리 문제
3. Runnable 인터페이스의 불편함

#### 1. 스레드 생성 비용으로 인한 성능 문제
스레드를 사용하려면 먼저 스레드를 생성해야 한다. 그런데 스레드는 다음과 같은 이유로 매우 무겁다.
- 메모리 할당: 각 스레드는 자신만의 호출 스택(call stack)을 가지고 있어야 한다. 이 호출 스택은 스레드가 실행되는 동안 사용하는
  메모리 공간이다. 따라서 스레드를 생성할 때는 이 호출 스택을 위한 메모리를 할당해야 한다.
- 운영체제 자원 사용: 스레드를 생성하는 작업은 운영체제 커널 수준에서 이루어지며, 시스템 콜(system call)을 통해 처리된다.
  이는 CPU와 메모리 리소스를 소모하는 작업이다.
- 운영체제 스케줄러 설정: 새로운 스레드가 생성되면 운영체제의 스케줄러는 이 스레드를 관리하고 실행 순서를 조정해야 한다.
  이는 운영체제의 스케줄링 알고리즘에 따라 추가적인 오버헤드가 발생할 수 있다.
- 참고로 스레드 하나는 보통 1MB 이상의 메모리를 사용한다.

스레드를 생성하는 작업은 상대적으로 무겁다. 단순히 자바 객체를 하나 생성하는 것과는 비교할 수 없을 정도로 큰 작업이다.
예를 들어서 어떤 작업 하나를 수행할 때 마다 스레드를 각각 생성하고 실행한다면, 스레드의 생성 비용 때문에, 이미 많은 시간이 소모된다.
아주 가벼운 작업이라면, 작업의 실행 시간보다 스레드의 생성 시간이 더 오래 걸릴 수도 있다. 이런 문제를 해결하려면 생성한 스레드를
재사용하는 방법을 고려할 수 있다. 스레드를 재사용하면 처음 생성할 때를 제외하고는 생성을 위한 시간이 들지 않는다. 따라서 스레드가
아주 빠르게 작업을 수행할 수 있다.

2. 스레드 관리 문제
   서버의 CPU, 메모리 자원은 한정되어 있기 때문에, 스레드는 무한하게 만들 수 없다.
   예를 들어서, 사용자의 주문을 처리하는 서비스라고 가정하자. 그리고 사용자의 주문이 들어올 때 마다 스레드를 만들어
   서 요청을 처리한다고 가정하겠다. 서비스 마케팅을 위해 선착순 할인 이벤트를 진행한다고 가정해보자. 그러면 사용자
   가 갑자기 몰려들 수 있다. 평소 동시에 100개 정도의 스레드면 충분했는데, 갑자기 10000개의 스레드가 필요한 상황
   이 된다면 CPU, 메모리 자원이 버티지 못할 것이다.
   이런 문제를 해결하려면 우리 시스템이 버틸 수 있는, 최대 스레드의 수 까지만 스레드를 생성할 수 있게 관리해야 한다.
   또한 이런 문제도 있다. 예를 들어 애플리케이션을 종료한다고 가정해보자.
   이때 안전한 종료를 위해 실행 중인 스레드가 남은 작업은 모두 수행한 다음에 프로그램을 종료하고 싶다거나, 또는 급
   하게 종료해야 해서 인터럽트 등의 신호를 주고 스레드를 종료하고 싶다고 가정해보자.
   이런 경우에도 스레드가 어딘가에 관리가 되어 있어야한다.

#### 3. Runnable 인터페이스의 불편함
```java
public interface Runnable {
    void run();
}
```

Runnable 인터페이스는 다음과 같은 이유로 불편하다.
- 반환 값이 없다: run() 메서드는 반환 값을 가지지 않는다. 따라서 실행 결과를 얻기 위해서는 별도의 메커니즘을 사용해야 한다.
  쉽게 이야기해서 스레드의 실행 결과를 직접 받을 수 없다. 앞에서 공부한 SumTask 의 예를 생각해보자. 스레드가 실행한 결과를
  멤버 변수에 넣어두고, join() 등을 사용해서 스레드가 종료되길 기다린 다음에 멤버 변수에 보관한 값을 받아야 한다.
- 예외 처리: run() 메서드는 체크 예외(checked exception)를 던질 수 없다. 체크 예외의 처리는 메서드 내부에서 처리해야 한다.

이런 문제를 해결하려면 반환 값도 받을 수 있고, 예외도 좀 더 쉽게 처리할 수 있는 방법이 필요하다. 추가로 반환 값 뿐만 아니라
해당 스레드에서 발생한 예외도 받을 수 있다면 더 좋을 것이다.

#### 해결
지금까지 설명한 1번, 2번 문제를 해결하려면 스레드를 생성하고 관리하는 풀(Pool)이 필요하다.

![](https://github.com/dididiri1/TIL/blob/main/Java/adv1/images/12_01.png?raw=true)
- 스레드를 관리하는 스레드 풀(스레드가 모여서 대기하는 수영장 풀 같은 개념)에 스레드를 미리 필요한 만큼 만들어둔다.
- 스레드는 스레드 풀에서 대기하며 쉰다.
- 작업 요청이 온다.

![](https://github.com/dididiri1/TIL/blob/main/Java/adv1/images/12_02.png?raw=true)
- 스레드 풀에서 이미 만들어진 스레드를 하나 조회한다.
- 조회한 스레드1로 작업을 처리한다.

![](https://github.com/dididiri1/TIL/blob/main/Java/adv1/images/12_03.png?raw=true)

- 스레드1은 작업을 완료한다.
- 작업을 완료한 스레드는 종료하는게 아니라, 다시 스레드 풀에 반납한다. 스레드1은 이후에 다시 재사용 될 수 있다.

이렇게 스레드 풀이라는 개념을 사용하면 스레드를 재사용할 수 있어서, 재사용시 스레드의 생성 시간을 절약할 수 있
다. 그리고 스레드 풀에서 스레드가 관리되기 때문에 필요한 만큼만 스레드를 만들 수 있고, 또 관리할 수 있다.

사실 스레드 풀이라는 것이 별것이 아니다. 그냥 컬렉션에 스레드를 보관하고 재사용할 수 있게 하면 된다. 하지만 스레
드 풀에 있는 스레드는 처리할 작업이 없다면, 대기( WAITING ) 상태로 관리해야 하고, 작업 요청이 오면 RUNNABLE
상태로 변경해야 한다. 막상 구현하려고 하면 생각보다 매우 복잡하다는 사실을 알게될 것이다. 여기에 생산자 소비자
문제까지 겹친다. 잘 생각해보면 어떤 생산자가 작업(task)를 만들 것이고, 우리의 스레드 풀에 있는 스레드가 소비자가
되는 것이다.

이런 문제를 한방에 해결해주는 것이 바로 자바가 제공하는 Executor 프레임워크다.
Executor 프레임워크는 스레드 풀, 스레드 관리, Runnable 의 문제점은 물론이고, 생산자 소비자 문제까지 한방에
해결해주는 자바 멀티스레드 최고의 도구이다. 지금까지 우리가 배운 멀티스레드 기술의 총 집합이 여기에 들어있다.

참고로 앞서 설명한 이유와 같이 스레드를 사용할 때는 생각보다 고려해야 할 일이 많다. 그래서 실무에서는 스레드를
직접 하나하나 생성해서 사용하는 일이 드물다. 대신에 지금부터 설명할 Executor 프레임워크를 주로 사용하는데, 이
기술을 사용하면 매우 편리하게 멀티스레드 프로그래밍을 할 수 있다.

## ExecutorService 코드로 시작하기
먼저 1초간 대기하는 아주 간단한 작업을 하나 만들자.
```java
package thread.executor;

import static util.MyLogger.log;
import static util.ThreadUtils.sleep;

public class RunnableTask implements Runnable {
    private final String name;
    private int sleepMs = 1000;

    public RunnableTask(String name) {
        this.name = name;
    }

    public RunnableTask(String name, int sleepMs) {
        this.name = name;
        this.sleepMs = sleepMs;
    }

    @Override
    public void run() {
        log(name + " 시작");
        sleep(sleepMs); // 작업 시간 시뮬레이션
        log(name + " 완료");
    }
}
```
- Runnable 인터페이스를 구현한다. 1초의 작업이 걸리는 간단한 작업으로 가정하자.

```java
package thread.executor;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

import static thread.executor.ExecutorUtils.*;
import static util.MyLogger.log;
import static util.ThreadUtils.sleep;

public class ExecutorBasicMain {
    public static void main(String[] args) throws InterruptedException {
        ExecutorService es = new ThreadPoolExecutor(
                2,
                2,
                0,
                TimeUnit.MILLISECONDS,
                new LinkedBlockingQueue<>()
        );

        log("== 초기 상태 ==");
        printState(es);

        es.execute(new RunnableTask("taskA"));
        es.execute(new RunnableTask("taskB"));
        es.execute(new RunnableTask("taskC"));
        es.execute(new RunnableTask("taskD"));

        log("== 작업 수행 중 ==");
        printState(es);

        sleep(3000);

        log("== 작업 수행 완료 ==");
        printState(es);

        es.close();
        log("== shutdown 완료 ==");
        printState(es);
    }
}
```

ExecutorService 의 가장 대표적인 구현체는 ThreadPoolExecutor 이다.

![](https://github.com/dididiri1/TIL/blob/main/Java/adv1/images/12_04.png?raw=true)

ThreadPoolExecutor(ExecutorService) 는 크게 2가지 요소로 구성되어 있다.
- 스레드 풀: 스레드를 관리한다.
- BlockingQueue : 작업을 보관한다. 생산자 소비자 문제를 해결하기 위해 단순한 큐가 아니라, BlockingQueue 를 사용한다.

생산자가 es.execute(new RunnableTask("taskA")) 를 호출하면, RunnableTask("taskA") 인스턴스가 BlockingQueue 에 보관된다.
- **생산자**: es.execute(작업) 를 호출하면 내부에서 BlockingQueue 에 작업을 보관한다. main 스레드가 생산자가 된다.
- **소비자**: 스레드 풀에 있는 스레드가 소비자이다. 이후에 소비자 중에 하나가 BlockingQueue 에 들어있는 작업을 받아서 처리한다.

#### ThreadPoolExecutor 생성자
ThreadPoolExecutor 의 생성자는 다음 속성을 사용한다.
- corePoolSize : 스레드 풀에서 관리되는 기본 스레드의 수
- maximumPoolSize : 스레드 풀에서 관리되는 최대 스레드 수
- keepAliveTime , TimeUnit unit : 기본 스레드 수를 초과해서 만들어진 스레드가 생존할 수 있는 대기 시간이다.
  이 시간 동안 처리할 작업이 없다면 초과 스레드는 제거된다.
- BlockingQueue workQueue : 작업을 보관할 블로킹 큐

new ThreadPoolExecutor(2,2,0, TimeUnit.MILLISECONDS, new
LinkedBlockingQueue<>());
- 최대 스레드 수와 keepAliveTime , TimeUnit unit 에 대한 부분은 뒤에서 따로 설명하겠다.
- 여기서는 corePoolSize=2 , maximumPoolSize=2 를 사용해서 기본 스레드와 최대 스레드 수를 맞추었다.
  따라서 풀에서 관리되는 스레드는 2개로 고정된다. keepAliveTime , TimeUnit unit 는 0으로 설정했는데, 이 부분은 뒤에서 설명한다.
- 작업을 보관할 블로킹 큐의 구현체로 LinkedBlockingQueue 를 사용했다. 참고로 이 블로킹 큐는 작업을 무 한대로 저장할 수 있다.

#### 실행 결과
```
12:10:54.451 [     main] == 초기 상태 ==
12:10:54.461 [     main] [pool=0, active=0, queuedTasks=0, completedTasks=0]
12:10:54.461 [     main] == 작업 수행 중 ==
12:10:54.461 [     main] [pool=2, active=2, queuedTasks=2, completedTasks=0]
12:10:54.461 [pool-1-thread-1] taskA 시작
12:10:54.461 [pool-1-thread-2] taskB 시작
12:10:55.467 [pool-1-thread-1] taskA 완료
12:10:55.467 [pool-1-thread-2] taskB 완료
12:10:55.468 [pool-1-thread-1] taskC 시작
12:10:55.468 [pool-1-thread-2] taskD 시작
12:10:56.471 [pool-1-thread-2] taskD 완료
12:10:56.474 [pool-1-thread-1] taskC 완료
12:10:57.465 [     main] == 작업 수행 완료 ==
12:10:57.466 [     main] [pool=2, active=0, queuedTasks=0, completedTasks=4]
12:10:57.468 [     main] == shutdown 완료 ==
12:10:57.469 [     main] [pool=0, active=0, queuedTasks=0, completedTasks=4]
```

![](https://github.com/dididiri1/TIL/blob/main/Java/adv1/images/12_05.png?raw=true)

```
12:10:54.451 [     main] == 초기 상태 ==
12:10:54.461 [     main] [pool=0, active=0, queuedTasks=0, completedTasks=0]
```
- ThreadPoolExecutor 를 생성한 시점에 스레드 풀에 스레드를 미리 만들어두지는 않는다.

![](https://github.com/dididiri1/TIL/blob/main/Java/adv1/images/12_06.png?raw=true)

- main 스레드가 es.execute("taskA ~ taskD") 를 호출한다.
    - 참고로 당연한 이야기지만 main 스레드는 작업을 전달하고 기다리지 않는다. 전달한 작업은 다른 스레드가 실행할 것이다.
      main 스레드는 작업을 큐에 보관까지만 하고 바로 다음 코드를 수행한다.
- taskA~D 요청이 블로킹 큐에 들어온다.
- 최초의 작업이 들어오면 이때 작업을 처리하기 위해 스레드를 만든다.
    - 참고로 스레드 풀에 스레드를 미리 만들어두지는 않는다.
- 작업이 들어올 때 마다 corePoolSize 의 크기 까지 스레드를 만든다.
    - 예를 들어서 최초 작업인 taskA 가 들어오는 시점에 스레드1을 생성하고, 다음 작업인 taskB 가 들어오는 시점에 스레드2를 생성한다.
    - 이런 방식으로 corePoolSize 에 지정한 수 만큼 스레드를 스레드 풀에 만든다. 여기서는 2를 설정했으므로 2개까지 만든다.
    - corePoolSize 까지 스레드가 생성되고 나면, 이후에는 스레드를 생성하지 않고 앞서 만든 스레드를 재 사용한다.

![](https://github.com/dididiri1/TIL/blob/main/Java/adv1/images/12_07.png?raw=true)
```
12:10:54.461 [     main] == 작업 수행 중 ==
12:10:54.461 [     main] [pool=2, active=2, queuedTasks=2, completedTasks=0]
```
- 스레드 풀에 관리되는 스레드가 2개이므로 pool=2
- 작업을 수행중인 스레드가 2개이므로 active=2
- 큐에 대기중인 작업이 2개이므로 queuedTasks=2
- 완료된 작업은 없으므로 completedTasks=0

참고로 이해를 돕기 위해 스레드 풀의 스레드가 작업을 실행할 때, 그림으로는 스레드 풀에서 스레드를 꺼내는 것 처럼 표현했지만,
실제로 꺼내는 것은 아니고, 스레드의 상태가 변경된다고 이해하면 된다. 그래서 여전히 pool=2 로 유지 된다.

![](https://github.com/dididiri1/TIL/blob/main/Java/adv1/images/12_08.png?raw=true)
- 작업이 완료되면 스레드 풀에 스레드를 반납한다. 스레드를 반납하면 스레드는 대기( WAITING ) 상태로 스레드 풀에 대기한다.
    - 참고로 실제 반납 되는게 아니라, 스레드의 상태가 변경된다고 이해하면 된다.

![](https://github.com/dididiri1/TIL/blob/main/Java/adv1/images/12_09.png?raw=true)
- 반납된 스레드는 재사용된다.

![](https://github.com/dididiri1/TIL/blob/main/Java/adv1/images/12_10.png?raw=true)
- taskC , taskD 의 작업을 처리하기 위해 스레드 풀에서 스레드를 꺼내 재사용한다.

![](https://github.com/dididiri1/TIL/blob/main/Java/adv1/images/12_11.png?raw=true)
- 작업이 완료되면 스레드는 다시 스레드 풀에서 대기한다.
```
12:10:57.465 [     main] == 작업 수행 완료 ==
12:10:57.466 [     main] [pool=2, active=0, queuedTasks=0, completedTasks=4]
```

![](https://github.com/dididiri1/TIL/blob/main/Java/adv1/images/12_12.png?raw=true)
```
12:10:57.468 [     main] == shutdown 완료 ==
12:10:57.469 [     main] [pool=0, active=0, queuedTasks=0, completedTasks=4]
```
close() 를 호출하면 ThreadPoolExecutor 가 종료된다. 이때 스레드 풀에 대기하는 스레드도 함께 제거된다.

> 참고: close() 는 자바 19부터 지원되는 메서드이다. 만약 19 미만 버전을 사용한다면 shutdown() 을 호출 하자.
> 둘의 차이는 뒤에서 설명한다.

## Runnable의 불편함
앞서 Runnable 인터페이스는 다음과 같은 불편함이 있다고 설명했다.

#### Runnable 인터페이스의 불편함
```java
public interface Runnable {
    void run();
}
```
- **반환 값이 없다**: run() 메서드는 반환 값을 가지지 않는다. 따라서 실행 결과를 얻기 위해서는 별도의 메커니즘을 사용해야 한다. 
  쉽게 이야기해서 스레드의 실행 결과를 직접 받을 수 없다. 앞에서 공부한 SumTask 의 예를 생각해보자. 스레드가 실행한 결과를 멤버 변수에 
  넣어두고, join() 등을 사용해서 스레드가 종료되길 기다린 다음에 멤버 변수를 통해 값을 받아야 한다.
- **예외 처리**: run() 메서드는 체크 예외(checked exception)를 던질 수 없다. 체크 예외의 처리는 메서드 내부 에서 처리해야 한다.

Executor 프레임워크는 어떤 방식으로 이런 불편함을 해결하는지 알아보자.

### Runnable 사용
이해를 돕기 위해 먼저 Runnable 을 통해 별도의 스레드에서 무작위 값을 하나 구하는 간단한 코드를 작성해보자.
```java
package thread.executor.future;

import java.util.Random;
import static util.MyLogger.log;
import static util.ThreadUtils.sleep;

public class RunnableMain {
    public static void main(String[] args) throws InterruptedException {
        MyRunnable task = new MyRunnable();
        Thread thread = new Thread(task, "Thread-1");
        thread.start();
        thread.join();
        int result = task.value;
        log("result value = " + result);
    }

    static class MyRunnable implements Runnable {
        int value;

        @Override
        public void run() {
            log("Runnable 시작");
            sleep(2000);
            value = new Random().nextInt(10);
            log("create value = " + value);
            log("Runnable 완료");
        }
    }
}
```
- **run()**: 0 ~ 9 사이의 무작위 값을 조회한다. 작업에 2초가 걸린다고 가정한다.

#### 실행 결과
```
14:22:06.675 [ Thread-1] Runnable 시작
14:22:08.685 [ Thread-1] create value = 1
14:22:08.686 [ Thread-1] Runnable 완료
14:22:08.686 [     main] result value = 1
```
- 무작위 값이므로 숫자의 결과는 다를 수 있다.
- 프로그램이 시작되면 Thread-1 이라는 별도의 스레드를 하나 만든다.
- Thread-1 이 수행하는 MyRunnable 은 무작위 값을 하나 구한 다음에 value 필드에 보관한다.
- 클라이언트인 main 스레드가 이 별도의 스레드에서 만든 무작위 값을 얻어오려면 Thread-1 스레드가 종료될 때까지 기다려야 한다. 
  그래서 main 스레드는 join() 을 호출해서 대기한다.
- 이후에 main 스레드에서 MyRunnable 인스턴스의 value 필드를 통해 최종 무작위 값을 획득한다.

별도의 스레드에서 만든 무작위 값 하나를 받아오는 과정이 이렇게 복잡하다.
작업 스레드( Thread-1 )는 값을 어딘가에 보관해두어야 하고, 요청 스레드( main )는 작업 스레드의 작업이 끝날 때 까지 join() 을 호출해서
대기한 다음에, 어딘가에 보관된 값을 찾아서 꺼내야 한다.

작업 스레드는 간단히 값을 return 을 통해 반환하고, 요청 스레드는 그 반환 값을 바로 받을 수 있다면 코드가 훨씬 더 간결해질 것이다.
이런 문제를 해결하기 위해 Executor 프레임워크는 Callable 과 Future 라는 인터페이스를 도입했다.

## Future1 - 시작
### Runnable과 Callable 비교
#### Runnable은 다음과 같다.
```java
package java.lang;

public interface Runnable {
    void run();
}
```
- Runnable 의 run() 은 반환 타입이 void 이다. 따라서 값을 반환할 수 없다.
- 예외가 선언되어 있지 않다. 따라서 해당 인터페이스를 구현하는 모든 메서드는 체크 예외를 던질 수 없다.
  - 참고로 자식은 부모의 예외 범위를 넘어설 수 없다. 부모에 예외가 선언되어 있지 않으므로 예외를 던질 수 없다.
  - 물론 런타임(비체크)예외는 제외다.

#### Callable은 다음과 같다.
```java
package java.util.concurrent;

public interface Callable<V> {
    V call() throws Exception;
}
```
- java.util.concurrent 에서 제공되는 기능이다.
- Callable 의 call() 은 반환 타입이 제네릭 V 이다. 따라서 값을 반환할 수 있다.
- throws Exception 예외가 선언되어 있다. 따라서 해당 인터페이스를 구현하는 모든 메서드는 체크 예외인 Exception 과 
  그 하위 예외를 모두 던질 수 있다.

Callable 을 실제 어떻게 사용하는지 알아보자.

### Callable과 Future 사용
```java
package thread.executor.future;

import java.util.Random;
import java.util.concurrent.*;
import static util.MyLogger.log;
import static util.ThreadUtils.sleep;

public class CallableMainV1 {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService es = Executors.newFixedThreadPool(1);
        Future<Integer> future = es.submit(new MyCallable());
        Integer result = future.get();
        log("result value = " + result);
        es.close();
    }

    static class MyCallable implements Callable<Integer> {
        @Override
        public Integer call() {
            log("Callable 시작");
            sleep(2000);
            int value = new Random().nextInt(10);
            log("create value = " + value);
            log("Callable 완료");
            return value;
        }
    }
}
```
java.util.concurrent.Executors 가 제공하는 newFixedThreadPool(size) 을 사용하면 편리하게
ExecutorService 를 생성할 수 있다.

#### 기존 코드
```
ExecutorService es = new ThreadPoolExecutor(1,1,0, TimeUnit.MILLISECONDS, new
LinkedBlockingQueue<>());
```

#### 편의 코드
```
ExecutorService es = Executors.newFixedThreadPool(1);
```

#### 실행 결과
```
14:39:47.764 [pool-1-thread-1] Callable 시작
14:39:49.776 [pool-1-thread-1] create value = 4
14:39:49.776 [pool-1-thread-1] Callable 완료
14:39:49.777 [     main] result value = 4
```
먼저 MyCallable 을 구현하는 부분을 보자.
- 숫자를 반환하므로 반환할 제네릭 타입을 <Integer> 로 선언했다.
- 구현은 Runnable 코드와 비슷한데, 유일한 차이는 결과를 필드에 담아두는 것이 아니라, 결과를 반환한다는 점이다. 
  따라서 결과를 보관할 별도의 필드를 만들지 않아도 된다.

#### submit()
```
<T> Future<T> submit(Callable<T> task); //인터페이스 정의
```
ExecutorService 가 제공하는 submit() 을 통해 Callable 을 작업으로 전달할 수 있다.
```
Future<Integer> future = es.submit(new MyCallable());
```
MyCallable 인스턴스가 블로킹 큐에 전달되고, 스레드 풀의 스레드 중 하나가 이 작업을 실행할 것이다.
이때 작업의 처리 결과는 직접 반환되는 것이 아니라 Future 라는 특별한 인터페이스를 통해 반환된다.
```
Integer result = future.get();
```
future.get() 을 호출하면 MyCallable 의 call() 이 반환한 결과를 받을 수 있다.

참고로 Future.get() 은 InterruptedException, ExecutionException 체크 예외를 던진다. 여기서는 잡지말고 간단하게 밖으로 던지자. 
예외에 대한 부분은 뒤에서 설명한다.

Executor 프레임워크의 강점
요청 스레드가 결과를 받아야 하는 상황이라면, Callable 을 사용한 방식은 Runnable 을 사용하는 방식보다 훨씬 편리하다. 
코드만 보면 복잡한 멀티스레드를 사용한다는 느낌보다는, 단순한 싱글 스레드 방식으로 개발한다는 느낌이 들 것이다.
이 과정에서 내가 스레드를 생성하거나, join() 으로 스레드를 제어하거나 한 코드는 전혀 없다. 심지어 Thread 라 는 코드도 없다.

단순하게 ExecutorService 에 필요한 작업을 요청하고 결과를 받아서 쓰면 된다!
복잡한 멀티스레드를 매우 편리하게 사용할 수 있는 것이 바로 Executor 프레임워크의 큰 강점이다.

하지만 편리한 것은 편리한 것이고, 기반 원리를 제대로 이해해야 문제없이 사용할 수 있다.
여기서 잘 생각해보면 한 가지 애매한 상황이 있다.
future.get() 을 호출하는 요청 스레드( main )는 future.get() 을 호출 했을 때 2가지 상황으로 나뉘게 된다.
- MyCallable 작업을 처리하는 스레드 풀의 스레드가 작업을 완료했다.
- MyCallable 작업을 처리하는 스레드 풀의 스레드가 아직 작업을 완료하지 못했다.

future.get() 을 호출했을 때 스레드 풀의 스레드가 작업을 완료했다면 반환 받을 결과가 있을 것이다. 그런데 아직
작업을 처리중이라면 어떻게 될까?
이런 의문도 들 것이다. 왜 결과를 바로 반환하지 않고, 불편하게 Future 라는 객체를 대신 반환할까? 이 부분을 제대
로 이해해야 한다.

## Future2 - 분석
Future 는 번역하면 미래라는 뜻이고, 여기서는 미래의 결과를 받을 수 있는 객체라는 뜻이다. 그렇다면 누구의 미래
의 결과를 말하는 것일까? 다음 코드를 보자?
```
Future<Integer> future = es.submit(new MyCallable());
```
- submit() 의 호출로 MyCallable 의 인스턴스를 전달한다.
- 이때 submit() 은 MyCallable.call() 이 반환하는 무작위 숫자 대신에 Future 를 반환한다.
- 생각해보면 MyCallable 이 즉시 실행되어서 즉시 결과를 반환하는 것은 불가능하다. 왜냐하면 MyCallable 은 즉시 실행되는 것이 아니다. 
  스레드 풀의 스레드가 미래의 어떤 시점에 이 코드를 대신 실행해야 한다.
- MyCallable.call() 메서드는 호출 스레드가 실행하는 것도 아니고, 스레드 풀의 다른 스레드가 실행하기 때문에 언제 실행이 완료되어서
  결과를 반환할 지 알 수 없다.
- 따라서 결과를 즉시 받는 것은 불가능하다. 이런 이유로 es.submit() 은 MyCallable 의 결과를 반환하는 대신에 MyCallable 의 결과를 나중에
  받을 수 있는 Futurue 라는 객체를 대신 제공한다.
- 정리하면 Future 는 전달한 작업의 미래이다. 이 객체를 통해 전달한 작업의 미래 결과를 받을 수 있다.

단순하게 정리하면, Future 는 전달한 작업의 미래 결과를 담고 있다고 생각하면 된다.

이제 본격적으로 Future 가 어떻게 작동하는지 알아보자.

CallableMainV2 는 CallableMainV1 과 같은 코드에 로그를 추가했다.
```java
package thread.executor.future;

import java.util.Random;
import java.util.concurrent.*;

import static util.MyLogger.log;
import static util.ThreadUtils.sleep;

public class CallableMainV2 {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService es = Executors.newFixedThreadPool(1);

        log("submit() 호출");
        Future<Integer> future = es.submit(new MyCallable());

        log("future 즉시 반환, future = " + future);
        log("future.get() [블로킹] 메서드 호출 시작 -> main 스레드 WAITING");

        Integer result = future.get();

        log("future.get() [블로킹] 메서드 호출 완료 -> main 스레드 RUNNABLE");
        log("result value = " + result);
        log("future 완료, future = " + future);

        es.close();
    }

    static class MyCallable implements Callable<Integer> {
        @Override
        public Integer call() {
            log("Callable 시작");
            sleep(2000);
            int value = new Random().nextInt(10);
            log("create value = " + value);
            log("Callable 완료");
            return value;
        }
    }
}
```

#### 실행 결과
```
09:24:42.689 [ main] submit() 호출
09:24:42.691 [pool-1-thread-1] Callable 시작
09:24:42.691 [ main] future 즉시 반환, future = FutureTask@46d56d67[Not 
completed, task = thread.executor.future.CallableMainV2$MyCallable@14acaea5]
09:24:42.691 [ main] future.get() [블로킹] 메서드 호출 시작 -> main 스레드 WAITING
09:24:44.703 [pool-1-thread-1] create value = 4
09:24:44.703 [pool-1-thread-1] Callable 완료
09:24:44.703 [ main] future.get() [블로킹] 메서드 호출 완료 -> , main 스레드 RUNNABLE
09:24:44.704 [ main] result value = 4
09:24:44.704 [ main] future 완료, future = FutureTask@46d56d67[Completed normally]
```

![](https://github.com/dididiri1/TIL/blob/main/Java/adv1/images/12_13.png?raw=true)
- MyCallable 인스턴스를 편의상 taskA 라고 하겠다.
- 편의상 스레드풀에 스레드가 1개 있다고 가정하겠다.
```
es.submit(new MyCallable())
```
```
09:24:42.689 [    main] submit() 호출, [논블로킹] 메서드
```

#### Future의 생성
![](https://github.com/dididiri1/TIL/blob/main/Java/adv1/images/12_14.png?raw=true)
- 요청 스레드는 es.submit(taskA) 를 호출하고 있는 중이다.
- ExecutorService 는 전달한 taskA 의 미래 결과를 알 수 있는 Future 객체를 생성한다.
  - Future 는 인터페이스이다. 이때 생성되는 실제 구현체는 FutureTask 이다.
- 그리고 생성한 Future 객체 안에 taskA 의 인스턴스를 보관한다.
- Future 는 내부에 taskA 작업의 완료 여부와, 작업의 결과 값을 가진다.

![](https://github.com/dididiri1/TIL/blob/main/Java/adv1/images/12_15.png?raw=true)
- submit() 을 호출한 경우 Future 가 만들어지고, 전달한 작업인 taskA 가 바로 블로킹 큐에 담기는 것이 아니라, 
  그림처럼 taskA 를 감싸고 있는 Future 가 대신 블로킹 큐에 담긴다.
```
Future<Integer> future = es.submit(new MyCallable());
```

```
09:24:42.691 [ main] future 즉시 반환, future = FutureTask@46d56d67[Not 
completed, task = thread.executor.future.CallableMainV2$MyCallable@14acaea5]
```
- Future 는 내부에 작업의 완료 여부와, 작업의 결과 값을 가진다. 작업이 완료되지 않았기 때문에 아직은 결과값이 없다.
  - 로그를 보면 Future 의 구현체는 FutureTask 이다.
  - Future 의 상태는 "Not completed"(미 완료)이고, 연관된 작업은 전달한 taskA(MyCallable 인스턴스) 이다.
- 여기서 중요한 핵심이 있는데, 작업을 전달할 때 생성된 Future 는 즉시 반환된다는 점이다.

다음 로그를 보자
```
09:24:42.691 [     main] future 즉시 반환, future = FutureTask@46d56d67[Not 
completed, task = thread.executor.future.CallableMainV2$MyCallable@14acaea5]
09:24:42.691 [     main] future.get() [블로킹] 메서드 호출 시작 -> main 스레드 WAITING
```
- 생성한 Future 를 즉시 반환하기 때문에 요청 스레드는 대기하지 않고, 자유롭게 본인의 다음 코드를 호출할 수 있다.
  - 이것은 마치 Thread.start() 를 호출한 것과 비슷하다. Thread.start() 를 호출하면 스레드의 작업 코드가 별도의 스레드에서 실행된다.
    요청 스레드는 대기하지 않고, 즉시 다음 코드를 호출할 수 있다.

![](https://github.com/dididiri1/TIL/blob/main/Java/adv1/images/12_16.png?raw=true)
```
09:24:42.691 [pool-1-thread-1] Callable 시작
```
- 큐에 들어있는 Future[taskA] 를 꺼내서 스레드 풀의 스레드1이 작업을 시작한다.
- 참고로 Future 의 구현체인 FutureTask 는 Runnable 인터페이스도 함께 구현하고 있다.
- 스레드1은 FutureTask 의 run() 메서드를 수행한다.
- 그리고 run() 메서드가 taskA 의 call() 메서드를 호출하고 그 결과를 받아서 처리한다.
  - FutureTask.run() MyCallable.call()

![](https://github.com/dididiri1/TIL/blob/main/Java/adv1/images/12_17.png?raw=true)
```
09:24:42.691 [     main] future.get() [블로킹] 메서드 호출 시작 -> main 스레드 WAITING
```
#### 스레드1
- 스레드1은 taskA 의 작업을 아직 처리중이다. 아직 완료하지는 않았다.
#### 요청 스레드
- 요청 스레드는 Future 인스턴스의 참조를 가지고 있다.
- 그리고 언제든지 본인이 필요할 때 Future.get() 을 호출해서 taskA 작업의 미래 결과를 받을 수 있다.
- 요청 스레드는 작업의 결과가 필요해서 future.get() 을 호출한다.
  - Future 에는 완료 상태가 있다. taskA 의 작업이 완료되면 Future 의 상태도 완료로 변경된다.
  - 그런데 여기서 taskA 의 작업이 아직 완료되지 않았다. 따라서 Future 도 완료 상태가 아니다.
- 요청 스레드가 future.get() 을 호출하면 Future 가 완료 상태가 될 때 까지 대기한다. 이때 요청 스레드의 상태는 RUNNABLE WAITING 이 된다.

future.get() 을 호출했을 때
- **Future가 완료 상태**: Future 가 완료 상태면 Future 에 결과도 포함되어 있다. 이 경우 요청 스레드는 대기하지 않고, 값을 즉시 반환받을 수 있다.
- **Future가 완료 상태가 아님**: taskA 가 아직 수행되지 않았거나 또는 수행 중이라는 뜻이다. 이때는 어쩔 수 없이 요청 스레드가 결과를 받기 위해 
  대기해야 한다. 요청 스레드가 마치 락을 얻을 때처럼, 결과를 얻기 위해 대기한다. 이처럼 스레드가 어떤 결과를 얻기 위해 대기하는 것을 블로킹(Blocking)
  이라 한다.

#### 참고: 블로킹 메서드
Thread.join() , Future.get() 과 같은 메서드는 스레드가 작업을 바로 수행하지 않고, 다른 작업이 완료될 때
까지 기다리게 하는 메서드이다. 이러한 메서드를 호출하면 호출한 스레드는 지정된 작업이 완료될 때까지 블록(대기)
되어 다른 작업을 수행할 수 없다.

![](https://github.com/dididiri1/TIL/blob/main/Java/adv1/images/12_18.png?raw=true)
```
09:24:44.703 [pool-1-thread-1] create value = 4
09:24:44.703 [pool-1-thread-1] Callable 완료
09:24:44.703 [ main] future.get() [블로킹] 메서드 호출 완료 -> , main 스레드 RUNNABLE
```

####  요청 스레드
- 대기( WAITING ) 상태로 future.get() 을 호출하고 대기중이다.
#### 스레드1
1. taskA 작업을 완료한다.
2. Future 에 taskA 의 반환 결과를 담는다.
3. Future 의 상태를 완료로 변경한다.
4. 요청 스레드를 깨운다. 요청 스레드는 WAITING RUNNABLE 상태로 변한다.

![](https://github.com/dididiri1/TIL/blob/main/Java/adv1/images/12_19.png?raw=true)
```
09:24:44.703 [ main] future.get() [블로킹] 메서드 호출 완료 -> , main 스레드 RUNNABLE
09:24:44.704 [ main] result value = 4
```

#### 요청 스레드
- 요청 스레드는 RUNNABLE 상태가 되었다. 그리고 완료 상태의 Future 에서 결과를 반환 받는다. 참고로 taskA 의 결과가 Future 에 담겨있다.
#### 스레드1
- 작업을 마친 스레드1은 스레드 풀로 반환된다. RUNNABLE WAITING

![](https://github.com/dididiri1/TIL/blob/main/Java/adv1/images/12_20.png?raw=true)
```
09:24:44.704 [     main] future 완료, future = 
java.util.concurrent.FutureTask@46d56d67[Completed normally]
```
- Future 의 인스턴스인 FutureTask 를 보면 "Completed normally"로 정상 완료된 것을 확인할 수 있다.

#### 정리
```
Future<Integer> future = es.submit(new MyCallable());
```
- Future 는 작업의 미래 결과를 받을 수 있는 객체이다.
- submit() 호출시 future 는 즉시 반환된다. 덕분에 요청 스레드는 블로킹 되지 않고, 필요한 작업을 할 수 있다.

```
Integer result = future.get();
```
- 작업의 결과가 필요하면 Future.get() 을 호출하면 된다.
- Future가 완료 상태: Future 가 완료 상태면 Future 에 결과도 포함되어 있다. 이 경우 요청 스레드는 대기하지 않고, 값을 즉시 반환받을 수 있다.
- Future가 완료 상태가 아님: 작업이 아직 수행되지 않았거나 또는 수행 중이라는 뜻이다. 이때는 어쩔 수 없이 요청 스레드가 결과를 받기 위해 블로킹 
  상태로 대기해야 한다.

### Future가 필요한 이유?
그런데 잘 생각해보면 한 가지 의문이 들 수 있다.

다음 두 코드를 비교해보자.
#### Future를 반환 하는 코드
```
Future<Integer> future = es.submit(new MyCallable()); // 여기는 블로킹 아님
future.get(); // 여기서 블로킹
```
ExecutorService 를 설계할 때 지금처럼 복잡하게 Future 를 반환하는게 아니라 다음과 같이 결과를 직접 받도록
설계하는게 더 단순하고 좋지 않았을까?

#### 결과를 직접 반환 하는 코드(가정)
```
Integer result = es.submut(new MyCallable()); // 여기서 블로킹
```

물로니 이렇게 설계하면 submit() 을 호출할 때, 작업의 결과가 언제 나올지 알 수 없다. 따라서 작업의 결과를 잡을때 까지
요청 스레드는 대기해야 한다. 그런데 이것은 Future를 사용할 때도 마찬가지다. Future만 즉시 반환 받을뿐이지, 작업의 결과를
얻으려면 결국 future.get() 을 호출해야 한다. 그리고 이 시점에는 작업의 결과를 받을 때 까지 대기해야 한다.

다음 활용 예제를 보면 Future라는 개념이 왜 필요한지 이해가 될 것이다.

