# 6. 동기화 - synchronized
- [출금 예제 - 시작](#출금-예제---시작)
- [동시성 문제](#동시성-문제)
- [임계 영역](#임계-영역)
- [synchronized 메서드](#synchronized-메서드)
- [synchronized 코드 블럭](#synchronized-코드-블럭)
- [문제와 풀이](#문제와-풀이)
- [정리](#정리)

## 출금 예제 - 시작
멀티스레드를 사용할 때 가장 주의해야 할 점은, 같은 자원(리소스)에 여러 스레드가 동시에 접근할 때 발생하는 동시성 문제이다. 
참고로 여러 스레드가 접근하는 자원을 **공유 자원**이라 한다. 대표적인 공유 자원은 인스턴스의 필드(멤버 변수)이다.
멀티스레드를 사용할 때는 이런 공유 자원에 대한 접근을 적절하게 동기화(synchronization)해서 동시성 문제가 발생 하지 않게 방지하는 것이 중요하다.

동시성 문제가 어떤 문제인지 이해하기 위해 간단한 은행 출금 예제를 하나 만들어보자.
```java
package thread.sync;

public interface BankAccount {
    boolean withdraw(int amount);
    int getBalance();
}
```
- BankAccount 인터페이스이다. 앞으로 이 인터페이스의 구현체를 점진적으로 발전시키면서 문제를 해결할 예정이다.
- withdraw(amount) : 계좌의 돈을 출금한다. 출금할 금액을 매개변수로 받는다.
  - 계좌의 잔액이 출금할 금액보다 많다면 출금에 성공하고, true 를 반환한다.
  - 계좌의 잔액이 출금할 금액보다 적다면 출금에 실패하고, false 를 반환한다.
- getBalance() : 계좌의 잔액을 반환한다.

```java
package thread.sync;

import static util.MyLogger.log;
import static util.ThreadUtils.sleep;

public class BankAccountV1 implements BankAccount {

    private int balance;
    // volatile private int balance;

    public BankAccountV1(int initialBalance) {
        this.balance = initialBalance;
    }

    @Override
    public boolean withdraw(int amount) {
        log("거래 시작: " + getClass().getSimpleName());
        log("[검증 시작] 출금액: " + amount + ", 잔액: " + balance);

        if (balance < amount) {
            log("[검증 실패] 출금액: " + amount + ", 잔액: " + balance);
            return false;
        }

        log("[검증 완료] 출금액: " + amount + ", 잔액: " + balance);
        sleep(1000); // 출금에 걸리는 시간으로 가정
        balance = balance - amount;

        log("[출금 완료] 출금액: " + amount + ", 변경 잔액: " + balance);
        log("거래 종료");
        return true;
    }

    @Override
    public int getBalance() {
        return balance;
    }
}
```
- BankAccountV1 은 BankAccount 인터페이스를 구현한다.
- 생성자를 통해 계좌의 초기 잔액를 저장한다.
- int balance : 계좌의 잔액 필드
- withdraw(amount) : 검증과 출금 2가지 단계로 나누어진다.
  - **검증 단계**: 출금액과 잔액을 비교한다. 만약 출금액이 잔액보다 많다면 문제가 있으므로 검증에 실패하고, false 를 반환한다.
  - **출금 단계**: 검증에 통과하면 잔액이 출금액보다 많으므로 출금할 수 있다. 잔액에서 출금액을 빼고 출금을 완료하면, 성공이라는 
    의미의 true 를 반환한다.
- getBalance() : 잔액을 반환한다.

```java
package thread.sync;

public class WithdrawTask implements Runnable {

    private BankAccount account;
    private int amount;

    public WithdrawTask(BankAccount account, int amount) {
        this.account = account;
        this.amount = amount;
    }

    @Override
    public void run() {
        account.withdraw(amount);
    }
}
```
- 출금을 담당하는 Runnable 구현체이다. 생성시 출금할 계좌( account )와 출금할 금액( amount )을 저장해 둔다.
- run() 을 통해 스레드가 출금을 실행한다.

```java
package thread.sync;

import static util.MyLogger.log;
import static util.ThreadUtils.sleep;

public class BankMain {

    public static void main(String[] args) throws InterruptedException {
        BankAccount account = new BankAccountV1(1000);

        Thread t1 = new Thread(new WithdrawTask(account, 800), "t1");
        Thread t2 = new Thread(new WithdrawTask(account, 800), "t2");

        t1.start();
        t2.start();

        sleep(500); // 검증 완료까지 잠시 대기
        log("t1 state: " + t1.getState());
        log("t2 state: " + t2.getState());

        t1.join();
        t2.join();

        log("최종 잔액: " + account.getBalance());
    }
}
```
- new BankAccountV1(1000) 을 통해 초기 잔액을 1000 원으로 설정한다.
- main 스레드는 t1 , t2 스레드를 만든다. 만든 스레드들은 같은 계좌에 각각 800 원의 출금을 시도한다.
- main 스레드는 join() 을 사용해서 t1 , t2 스레드가 출금을 완료한 이후에 최종 잔액을 확인한다.

![](https://github.com/dididiri1/TIL/blob/main/Java/adv1/images/06_01.png?raw=true)
- 각각의 스레드의 스택에서 run() 이 실행된다.
- t1 스레드는 WithdrawTask(x002) 인스턴스의 run() 을 호출한다.
- t2 스레드는 WithdrawTask(x003) 인스턴스의 run() 을 호출한다.
- 스택 프레임의 this 에는 호출한 메서드의 인스턴스 참조가 들어있다.
- 두 스레드는 같은 계좌( x001 )에 대해서 출금을 시도한다.

**참고**: 그림에서는 편의상 BankAccountV1 대신에 BankAccount 라고 표현하겠다.
![](https://github.com/dididiri1/TIL/blob/main/Java/adv1/images/06_02.png?raw=true)
- t1 스레드의 run() 에서 withdraw() 를 실행한다.
- 거의 동시에 t2 스레드의 run() 에서 withdraw() 를 실행한다.
- t1 스레드와 t2 스레드는 같은 BankAccount(x001) 인스턴스의 withdraw() 메서드를 호출한다.
- 따라서 두 스레드는 같은 BankAccount(x001) 인스턴스에 접근하고 또 x001 인스턴스에 있는 잔액(balance) 필드도 함께 사용한다.

#### 실행 결과
```
11:09:40.185 [       t1] 거래 시작: BankAccountV1
11:09:40.185 [       t2] 거래 시작: BankAccountV1
11:09:40.192 [       t1] [검증 시작] 출금액: 800, 잔액: 1000
11:09:40.192 [       t2] [검증 시작] 출금액: 800, 잔액: 1000
11:09:40.192 [       t1] [검증 완료] 출금액: 800, 잔액: 1000
11:09:40.192 [       t2] [검증 완료] 출금액: 800, 잔액: 1000
11:09:40.673 [     main] t1 state: TIMED_WAITING
11:09:40.673 [     main] t2 state: TIMED_WAITING
11:09:41.195 [       t1] [출금 완료] 출금액: 800, 변경 잔액: 200
11:09:41.195 [       t1] 거래 종료
11:09:41.197 [       t2] [출금 완료] 출금액: 800, 변경 잔액: -600
11:09:41.197 [       t2] 거래 종료
11:09:41.200 [     main] 최종 잔액: -600
```
- 참고: 여기서는 t1 스레드가 먼저 실행되었다. 그런데 실행 환경에 따라서 t1 , t2 가 완전히 동시에 실행될 수 도 있다. 
  이 경우 출금액은 같고, 잔액은 200원이 된다. 이 부분은 바로 뒤에서 설명한다.

#### 동시성 문제
이 시나리오는 악의적인 사용자가 2대의 PC에서 동시에 같은 계좌의 돈을 출금한다고 가정한다.
- t1 , t2 , 스레드는 거의 동시에 실행되지만, 아주 약간의 차이로 t1 스레드가 먼저 실행되고, t2 스레드가 그 다음에 실행된다고 가정하겠다.
- 처음 계좌의 잔액은 1000원이다. t1 스레드가 800원을 출금하면 잔액은 200원이 남는다.
- 이제 계좌의 잔액은 200원이다. t2 스레드가 800원을 출금하면 잔액보다 더 많은 돈을 출금하게 되므로 출금에 실패해야 한다.

그런데 실행 결과를 보면 기대와는 다르게 t1 , t2 는 각각 800원씩 총 1600원 출금에 성공한다.
계좌의 잔액은 -600 원이 되어있고, 계좌는 예상치 못하게 마이너스 금액이 되어버렸다.
악의적인 사용자는 2대의 PC를 통해 자신의 계좌에 있는 1000원 보다 더 많은 금액인 1600원 출금에 성공한다.
분명히 계좌를 출금할 때 잔고를 체크하는 로직이 있는데도 불구하고, 왜 이런 문제가 발생했을까?

#### 계좌 출금시 잔고 체크 로직
```
if (balance < amount) {
    log("[검증 실패] 출금액: " + amount + ", 잔액: " + balance);
     return false;
}
```
**참고**: balance 값에 volatile 을 도입하면 문제가 해결되지 않을까? 그렇지 않다. volatile 은 한 스레드가 값 을 변경했을 때 
다른 스레드에서 변경된 값을 즉시 볼 수 있게 하는 메모리 가시성의 문제를 해결할 뿐이다. 예를 들어 t1 스레드가 balance 의 값을 변경했을 때, 
t2 스레드에서 balance 의 변경된 값을 즉시 확인해도 여전히 같은 문제가 발생한다. 이 문제는 메모리 가시성 문제를 해결해도 여전히 발생한다.

## 동시성 문제
왜 이런 문제가 발생하는지 하나씩 천천히 분석해보자.

### t1, t2 순서로 실행 가정
t1 이 아주 약간 빠르게 실행되는 경우를 먼저 알아보자. 설명을 단순화 하기 위해 일부 그림은 생략했다.
![](https://github.com/dididiri1/TIL/blob/main/Java/adv1/images/06_03.png?raw=true)
- t1 이 약간 먼저 실행되면서, 출금을 시도한다.
- t1 이 출금 코드에 있는 검증 로직을 실행한다. 이때 잔액이 출금 액수보다 많은지 확인한다.
  - 잔액[1000]이 출금액[800] 보다 많으므로 검증 로직을 통과한다.

![](https://github.com/dididiri1/TIL/blob/main/Java/adv1/images/06_04.png?raw=true)
- t1 : 출금 검증 로직을 통과해서 출금을 위해 잠시 대기중이다. 출금에 걸리는 시간으로 생각하자.
- t2 : 검증 로직을 실행한다. 잔액이 출금 금액보다 많은지 확인한다.
  - 잔액[1000]이 출금액[800] 보다 많으므로 통과한다.

**바로 이 부분이 문제다! t1이 아직 잔액(balance)를 줄이지 못했기 때문에 t2는 검증 로직에서 현재 잔액을 1000원으로 확인한다.**
t1 이 검증 로직을 통과하고 바로 잔액을 줄였다면 이런 문제가 발생하지 않겠지만, t1 이 검증 로직을 통과하고 잔액을 줄이기도 전에 먼저 t2 가 
검증 로직을 확인한 것이다.
그렇다면 sleep(1000) 코드를 빼면 되지 않을까? 이렇게하면 t1 이 검증 로직을 통과하고 바로 잔액을 줄일 수 있을 것 같다.
하지만 t1 이 검증 로직을 통과하고 balance = balance - amount 를 계산하기 직전에 t2 가 실행 되면서 검증 로직을 통과할 수도 있다. 
sleep(1000) 은 단지 이런 문제를 쉽게 확인하기 위해 넣었을 뿐이다.

![](https://github.com/dididiri1/TIL/blob/main/Java/adv1/images/06_05.png?raw=true)
- 결과적으로 t1 , t2 모두 검증 로직을 통과하고, 출금을 위해 잠시 대기중이다. 출금에 걸리는 시간으로 생각하자.

![](https://github.com/dididiri1/TIL/blob/main/Java/adv1/images/06_06.png?raw=true)
- t1 은 800원을 출금하면서, 잔액을 1000원에서 출금 액수인 800원 만큼 차감한다. **이제 계좌의 잔액은 200원이 된다.**

![](https://github.com/dididiri1/TIL/blob/main/Java/adv1/images/06_07.png?raw=true)
- t2 는 800원을 출금하면서, 잔액을 200원에서 출금 액수인 800원 만큼 차감한다. **이제 잔액은 -600원이 된다.**

![](https://github.com/dididiri1/TIL/blob/main/Java/adv1/images/06_08.png?raw=true)

#### 결과
- t1 : 800원 출금 완료
- t2 : 800원 출금 완료
- 처음 원금은 1000원이었는데, 최종 잔액은 -600원이 된다.
- 은행 입장에서 마이너스 잔액이 있으면 안된다!

#### 실행 결과
```
11:09:40.185 [      t2] 거래 시작: BankAccountV1
11:09:40.185 [      t1] 거래 시작: BankAccountV1
11:09:40.192 [      t1] [검증 시작] 출금액: 800, 잔액: 1000
11:09:40.192 [      t2] [검증 시작] 출금액: 800, 잔액: 1000
11:09:40.192 [      t1] [검증 완료] 출금액: 800, 잔액: 1000
11:09:40.192 [      t2] [검증 완료] 출금액: 800, 잔액: 1000
11:09:40.673 [    main] t1 state: TIMED_WAITING
11:09:40.673 [    main] t2 state: TIMED_WAITING
11:09:41.195 [      t1] [출금 완료] 출금액: 800, 변경 잔액: 200
11:09:41.195 [      t1] 거래 종료
11:09:41.197 [      t2] [출금 완료] 출금액: 800, 변경 잔액: -600
11:09:41.197 [      t2] 거래 종료
11:09:41.200 [    main] 최종 잔액: -600
```
이것은 우리가 기대한 결과가 아니다.

### t1, t2 동시에 실행 가정
t1, t2가 완전히 동시에 실행되는 상황을 알아보자.
![](https://github.com/dididiri1/TIL/blob/main/Java/adv1/images/06_09.png?raw=true)
- t1 , t2 는 동시에 검증 로직을 실행한다. 잔액이 출금 금액보다 많은지 확인한다.
  - 잔액[1000]이 출금액[800] 보다 많으므로 둘다 통과한다.

![](https://github.com/dididiri1/TIL/blob/main/Java/adv1/images/06_10.png?raw=true)
- 결과적으로 t1 , t2 모두 검증 로직을 통과하고, 출금을 위해 잠시 대기중이다. 출금에 걸리는 시간으로 생각하자.

![](https://github.com/dididiri1/TIL/blob/main/Java/adv1/images/06_11.png?raw=true)
- t1 은 800원을 출금하면서, 잔액을 1000원에서 출금 액수인 800원 만큼 차감한다. **이제 잔액은 200원이 된다.**
- t2 은 800원을 출금하면서, 잔액을 1000원에서 출금 액수인 800원 만큼 차감한다. **이제 잔액은 200원이 된다.**
- t1 , t2 가 동시에 실행되기 때문에 둘다 잔액( balance )을 확인하는 시점에 잔액은 1000원이다!
- t1 , t2 둘다 동시에 계산된 결과를 잔액에 반영하는데, 둘다 계산 결과인 200원을 반영하므로 **최종 잔액은 200원이 된다.**
```
balance = balance - amount;
```
이 코드는 다음의 단계로 이루어진다.
1. 계산을 위해 오른쪽에 있는 balance 값과 amount 값을 조회한다.
2. 두 값을 계산한다.
3. 계산 결과를 왼쪽의 balance 변수에 저장한다.
- 여기서 1번 단계의 balance 값을 조회할 때 t1 , t2 두 스레드가 동시에 x001.balance 의 필드 값을 읽는다. 이때 값은 1000 이다. 
  따라서 두 스레드는 모두 잔액을 1000원으로 인식한다.
- 2번 단계에서 두 스레드 모두 1000 - 800 을 계산해서 200 이라는 결과를 만든다.
- 3번 단계에서 두 스레드 모두 balance = 200 을 대입한다.

![](https://github.com/dididiri1/TIL/blob/main/Java/adv1/images/06_12.png?raw=true)
#### 결과
- t1 : 800원 출금완료
- t2 : 800원 출금완료
- 원래 원금이 1000원이었는데, 최종 잔액은 200원이 된다.
- 은행 입장에서 보면 총 1600원이 빠져나갔는데, 잔액은 800원만 줄어들었다. 800원이 감쪽같이 어디론가 사라진 것이다!

#### 실행 결과
```
12:31:10.885 [       t2] 거래 시작: BankAccountV1
12:31:10.885 [       t1] 거래 시작: BankAccountV1
12:31:10.892 [       t1] [검증 시작] 출금액: 800, 잔액: 1000
12:31:10.892 [       t2] [검증 시작] 출금액: 800, 잔액: 1000
12:31:10.893 [       t1] [검증 완료] 출금액: 800, 잔액: 1000
12:31:10.893 [       t2] [검증 완료] 출금액: 800, 잔액: 1000
12:31:11.370 [     main] t1 state: TIMED_WAITING
12:31:11.370 [     main] t2 state: TIMED_WAITING
12:31:11.898 [       t2] [출금 완료] 출금액: 800, 변경 잔액: 200
12:31:11.898 [       t1] [출금 완료] 출금액: 800, 변경 잔액: 200
12:31:11.899 [       t2] 거래 종료
12:31:11.899 [       t1] 거래 종료
12:31:11.905 [     main] 최종 잔액: 200
```
실행 결과에서 시간이 완전히 같다는 사실을 통해 두 스레드가 같이 실행된 것을 대략 확인할 수 있다.
이것은 우리가 기대한 결과가 아니다.
이 문제가 왜 발생했고, 또 이런 문제를 어떻게 해결할 수 있을까?

## 임계 영역
이런 문제가 발생한 근본 원인은 여러 스레드가 함께 사용하는 공유 자원을 여러 단계로 나누어 사용하기 때문이다.
- 1. 검증 단계: 잔액( balance )이 출금액( amount ) 보다 많은지 확인한다.
- 2. 출금 단계: 잔액( balance )을 출금액( amount ) 만큼 줄인다.
```
출금() {
    1. 검증 단계: 잔액(balance) 확인
    2. 출금 단계: 잔액(balance) 감소
}
```
#### 이 로직에는 하나의 큰 가정이 있다.
스레드 하나의 관점에서 출금() 을 보면 1. 검증 단계에서 확인한 잔액( balance ) 1000원은 2. 출금 단계에서 계산을 끝마칠 때 까지 
같은 1000원으로 유지되어야 한다. 그래야 검증 단계에서 확인한 금액으로, 출금 단계에서 정확한 잔액을 계산할 수 있다.
그래야 검증 단계에서 확인한 1000원에 800원을 차감해서 200원이라는 잔액을 정확하게 계산할 수 있다.
결국 여기서는 내가 사용하는 값이 중간에 변경되지 않을 것이라는 가정이 있다.

그런데 만약 중간에 다른 스레드가 잔액의 값을 변경한다면, 큰 혼란이 발생한다. 1000원이라 생각한 잔액이 다른 값으
로 변경되면 잔액이 전혀 다른 값으로 계산될 수 있다.

#### 공유 자원
잔액( balance )은 여러 스레드가 함께 사용하는 공유 자원이다. 따라서 출금 로직을 수행하는 중간에 다른 스레드에서
이 값을 얼마든지 변경할 수 있다. 참고로 여기서는 출금() 메서드를 호출할 때만 잔액( balance )의 값이 변경된다.
따라서 다른 스레드가 출금 메서드를 호출하면서, 사용중인 출금 값을 중간에 변경해 버릴 수 있다.

#### 한 번에 하나의 스레드만 실행
만약 출금() 이라는 메서드를 한 번에 하나의 스레드만 실행할 수 있게 제한한다면 어떻게 될까? 예를 들어 t1 , t2 스레드가 함께 출금() 을 호출하면 
t1 스레드가 먼저 처음부터 끝까지 출금() 메서드를 완료하 고, 그 다음에 t2 스레드가 처음부터 끝까지 출금() 메서드를 완료하는 것이다.

이렇게 하면 공유 자원인 balance 를 한 번에 하나의 스레드만 변경할 수 있다. 따라서 계산 중간에 다른 스레드가 balance 의 값을 변경하는 부분을 
걱정하지 않아도 된다. (참고로 여기서는 출금() 메서드를 호출할 때만 잔액(balance)의 값이 변경된다.)

- 더 자세히는 출금을 진행할 때 잔액( balance )을 검증하는 단계부터 잔액의 계산을 완료할 때 까지 잔액의 값은 중간에 변하면 안된다.
- 이 검증과 계산 이 두 단계는 한 번에 하나의 스레드만 실행해야 한다. 그래야 잔액( balance )이 중간에 변하지 않고, 안전하게 계산을 수행할 수 있다.

#### 임계 영역(critical section)
영어로 크리티컬 섹션이라 한다.
- 여러 스레드가 동시에 접근하면 데이터 불일치나 예상치 못한 동작이 발생할 수 있는 위험하고 또 중요한 코드 부분을 뜻한다.
- 여러 스레드가 동시에 접근해서는 안 되는 공유 자원을 접근하거나 수정하는 부분을 의미한다.
  - 예) 공유 변수나 공유 객체를 수정

앞서 우리가 살펴본 출금() 로직이 바로 임계 영역이다.
더 자세히는 출금을 진행할 때 잔액( balance )을 검증하는 단계부터 잔액의 계산을 완료할 때 까지가 임계 영역이다.
여기서 balance 는 여러 스레드가 동시에 접근해서는 안되는 공유 자원이다.

이런 임계 영역은 한 번에 하나의 스레드만 접근할 수 있도록 안전하게 보호해야 한다.
그럼 어떻게 한 번에 하나의 스레드만 접근할 수 있도록 임계 영역을 안전하게 보호할 수 있을까?
여러가지 방법이 있지만 자바는 synchronized 키워드를 통해 아주 간단하게 임계 영역을 보호할 수 있다.

## synchronized 메서드
자바의 synchronized 키워드를 사용하면 한 번에 하나의 스레드만 실행할 수 있는 코드 구간을 만들 수 있다.
BankAccountV1 을 복사해서 BankAccountV2 코드를 만들고 synchronized 를 도입해보자.
```java
package thread.sync;

import static util.MyLogger.log;
import static util.ThreadUtils.sleep;

public class BankAccountV2 implements BankAccount {

    private int balance;

    public BankAccountV2(int initialBalance) {
        this.balance = initialBalance;
    }

    @Override
    public synchronized boolean withdraw(int amount) {
        log("거래 시작: " + getClass().getSimpleName());
        log("[검증 시작] 출금액: " + amount + ", 잔액: " + balance);

        if (balance < amount) {
            log("[검증 실패] 출금액: " + amount + ", 잔액: " + balance);
            return false;
        }

        log("[검증 완료] 출금액: " + amount + ", 잔액: " + balance);
        sleep(1000);
        balance = balance - amount;

        log("[출금 완료] 출금액: " + amount + ", 변경 잔액: " + balance);
        log("거래 종료");
        return true;
    }

    @Override
    public synchronized int getBalance() {
        return balance;
    }
}
```
- BankAccountV1 와 같은데, withdraw() , getBalance() 코드에 synchronized 키워드가 추가되었다.
- 이제 withdraw() , getBalance() 메서드는 한 번에 하나의 스레드만 실행할 수 있다.
```java
public class BankMain {

    public static void main(String[] args) throws InterruptedException {
        // BankAccount account = new BankAccountV1(1000);
        BankAccount account = new BankAccountV2(1000);
        
    }
}
```
- BankMain 에서 BankAccountV2 를 실행하도록 코드를 변경하자.

#### 실행 결과
```
14:48:15.144 [      t1] 거래 시작: BankAccountV2
14:48:15.149 [      t1] [검증 시작] 출금액: 800, 잔액: 1000
14:48:15.149 [      t1] [검증 완료] 출금액: 800, 잔액: 1000
14:48:15.633 [    main] t1 state: TIMED_WAITING
14:48:15.633 [    main] t2 state: BLOCKED
14:48:16.155 [      t1] [출금 완료] 출금액: 800, 변경 잔액: 200
14:48:16.155 [      t1] 거래 종료
14:48:16.156 [      t2] 거래 시작: BankAccountV2
14:48:16.156 [      t2] [검증 시작] 출금액: 800, 잔액: 200
14:48:16.156 [      t2] [검증 실패] 출금액: 800, 잔액: 200
14:48:16.160 [    main] 최종 잔액: 200
```
실행 결과를 보면 t1 이 withdraw() 메서드를 시작부터 완료까지 모두 끝내고 나서, 그 다음에 t2 가 withdraw() 메서드를 수행하는 것을 
확인할 수 있다. 물론 환경에 따라 t2 가 먼저 실행될 수도 있다. 이 경우에도 t2 가 withdraw() 메서드를 모두 수행한 다음에 t1 이 withdraw()
메서드를 수행한다.

### synchronized 분석
지금부터 자바의 synchronized 가 어떻게 작동하는지 그림으로 분석해보자.
참고로 실행 결과를 보면 t2 가 BLOCKED 상태인데, 이 상태도 확인해보자.
![](https://github.com/dididiri1/TIL/blob/main/Java/adv1/images/06_13.png?raw=true)
- 모든 객체(인스턴스)는 내부에 자신만의 락(lock)을 가지고 있다.
  - 모니터 락(monitor lock)이라도고 부른다.
  - 객체 내부에 있고 우리가 확인하기는 어렵다.
- 스레드가 synchronized 키워드가 있는 메서드에 진입하려면 반드시 해당 인스턴스의 락이 있어야 한다!
  - 여기서는 BankAccount(x001) 인스턴스의 synchronized withdraw() 메서드를 호출하므로 이 인스턴스의 락이 필요하다.
- 스레드 t1 , t2 는 withdraw() 를 실행하기 직전이다.
![](https://github.com/dididiri1/TIL/blob/main/Java/adv1/images/06_14.png?raw=true)
- t1 이 먼저 실행된다고 가정하겠다.
- 스레드 t1 이 먼저 synchronized 키워드가 있는 withdraw() 메서드를 호출한다.
- synchronized 메서드를 호출하려면 먼저 해당 인스턴스의 락이 필요하다.
- 락이 있으므로 스레드 t1 은 BankAccount(x001) 인스턴스에 있는 락을 획득한다.
![](https://github.com/dididiri1/TIL/blob/main/Java/adv1/images/06_15.png?raw=true)
- 스레드 t1 은 해당 인스턴스의 락을 획득했기 때문에 withdraw() 메서드에 진입할 수 있다.
- 스레드 t2 도 withdraw() 메서드 호출을 시도한다. synchronized 메서드를 호출하려면 먼저 해당 인스턴스의 락이 필요하다.
- 스레드 t2 는 BankAccount(x001) 인스턴스에 있는 락 획득을 시도한다. 하지만 락이 없다. 이렇게 락이 없으면 t2 스레드는 락을 획득할 때 까지 
  BLOCKED 상태로 대기한다.
  - t2 스레드의 상태는 RUNNABLE BLOCKED 상태로 변하고, 락을 획득할 때 까지 무한정 대기한다.

참고로 BLOCKED 상태가 되면 락을 다시 획득하기 전까지는 계속 대기하고, CPU 실행 스케줄링에 들어가지 않는다.
![](https://github.com/dididiri1/TIL/blob/main/Java/adv1/images/06_16.png?raw=true)
- t1 : 출금을 위한 검증 로직을 수행한다. 조건을 만족하므로 검증 로직을 통과한다.
  - 잔액[1000]이 출금액[800] 보다 많으므로 통과한다.
![](https://github.com/dididiri1/TIL/blob/main/Java/adv1/images/06_17.png?raw=true)
- t1 : 잔액 1000원에서 800원을 출금하고 계산 결과인 200원을 잔액( balance )에 반영한다.
![](https://github.com/dididiri1/TIL/blob/main/Java/adv1/images/06_18.png?raw=true)
- t1 : 메서드 호출이 끝나면 락을 반납한다.
![](https://github.com/dididiri1/TIL/blob/main/Java/adv1/images/06_19.png?raw=true)
- t2 : 인스턴스에 락이 반납되면 락 획득을 대기하는 스레드는 자동으로 락을 획득한다.
  - 이때 락을 획득한 스레드는 BLOCKED RUNNABLE 상태가 되고, 다시 코드를 실행한다.
![](https://github.com/dididiri1/TIL/blob/main/Java/adv1/images/06_20.png?raw=true)
- 스레드 t2 는 해당 인스턴스의 락을 획득했기 때문에 withdraw() 메서드에 진입할 수 있다. 
- t2 : 출금을 위한 검증 로직을 수행한다. 조건을 만족하지 않으므로 false 를 반환한다.
  - 이때 잔액( balance )은 200원이다. 800원을 출금해야 하므로 조건을 만족하지 않는다.
![](https://github.com/dididiri1/TIL/blob/main/Java/adv1/images/06_21.png?raw=true)
- t2 : 락을 반납하면서 return 한다.

#### 결과
- t1 : 800원 출금 완료
- t2 : 잔액 부족으로 출금 실패
- 원금 1000원, 최종 잔액은 200원

t1 은 800원 출금에 성공하지만, t2 는 잔액 부족으로 출금에 실패한다. 그리고 최종 잔액은 1000원에서 200원이 되므로 정확하게 맞다.
이렇게 자바의 synchronized 를 사용하면 한 번에 하나의 스레드만 실행하는 안전한 임계 영역 구간을 편리하게 만들 수 있다.

#### 참고: 락을 획득하는 순서는 보장되지 않는다.
만약 BankAccount(x001) 인스턴스의 withdraw() 를 수 많은 스레드가 동시에 호출한다면, 1개의 스레드만 락을 획득하고 나머지는 모두 
BLOCKED 상태가 된다. 그리고 이후에 BankAccount(x001) 인스턴스에 락을 반납하면, 해당 인스턴스의 락을 기다리는 수 많은 스레드 중에 하나의 
스레드만 락을 획득하고, 락을 획득한 스레드만 BLOCKED RUNNABLE 상태가 된다.
이때 어떤 순서로 락을 획득하는지는 자바 표준에 정의되어 있지 않다. 따라서 순서를 보장하지 않고, 환경에 따라서 순서가 달라질 수 있다.

참고: volatile 를 사용하지 않아도 synchronized 안에서 접근하는 변수의 메모리 가시성 문제는 해결된다. (이전에 학습한 자바 메모리 모델 참고)














