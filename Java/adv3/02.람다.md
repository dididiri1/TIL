# 2. ëŒë‹¤
- [/ëŒë‹¤ ì •ì˜](#ëŒë‹¤-ì •ì˜)
- [/í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤](#í•¨ìˆ˜í˜•-ì¸í„°í˜ì´ìŠ¤)
- [/ëŒë‹¤ì™€ ì‹œê·¸ë‹ˆì²˜](#ëŒë‹¤ì™€-ì‹œê·¸ë‹ˆì²˜)
- [/ëŒë‹¤ì™€ ìƒëµ](#ëŒë‹¤ì™€-ìƒëµ)
- [/ëŒë‹¤ì˜ ì „ë‹¬](#ëŒë‹¤ì˜-ì „ë‹¬)
- [/ê³ ì°¨ í•¨ìˆ˜](#ê³ ì°¨-í•¨ìˆ˜)
- [/ë¬¸ì œì™€ í’€ì´1](#ë¬¸ì œì™€-í’€ì´1)
- [/ë¬¸ì œì™€ í’€ì´2](#ë¬¸ì œì™€-í’€ì´2)
- [/ë¬¸ì œì™€ í’€ì´3](#ë¬¸ì œì™€-í’€ì´3)
- [/ì •ë¦¬](#ì •ë¦¬)

## ëŒë‹¤ ì •ì˜
- ìë°” 8ë¶€í„° ë„ì…ëœ ëŒë‹¤ëŠ” ìë°”ì—ì„œ í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì„ ì§€ì›í•˜ê¸° ìœ„í•œ í•µì‹¬ ê¸°ëŠ¥ì´ë‹¤.
  - í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì— ëŒ€í•´ì„œëŠ” ë’¤ì—ì„œ ì„¤ëª…í•œë‹¤.
- ëŒë‹¤ëŠ” ìµëª… í•¨ìˆ˜ì´ë‹¤. ë”°ë¼ì„œ ì´ë¦„ ì—†ì´ í•¨ìˆ˜ë¥¼ í‘œí˜„í•œë‹¤.

#### ë©”ì„œë“œë‚˜ í•¨ìˆ˜ëŠ” ë‹¤ìŒê³¼ ê°™ì´ í‘œí˜„í•œë‹¤.
```
ë°˜í™˜íƒ€ì… ë©”ì„œë“œëª…(ë§¤ê°œë³€ìˆ˜) {
    ë³¸ë¬¸
}
```

#### ëŒë‹¤ëŠ” ë‹¤ìŒê³¼ ê°™ì´ ê°„ê²°í•˜ê²Œ í‘œí˜„í•œë‹¤
```
(ë§¤ê°œë³€ìˆ˜) -> {ë³¸ë¬¸}
```
- ëŒë‹¤ëŠ” ìµëª… í•¨ìˆ˜ì´ë‹¤. ë”°ë¼ì„œ ì´ë¦„ì´ ì—†ë‹¤.
```
// ì¼ë°˜ í•¨ìˆ˜ - ì´ë¦„ì´ ìˆìŒ
public int add(int x) {
    return x + 1;
}

// ëŒë‹¤ - ì´ë¦„ì´ ì—†ìŒ
(int x) -> {
    return x + 1;
};
```
- ìë°”ëŠ” ë…ë¦½ì ì¸ í•¨ìˆ˜ë¥¼ ì§€ì›í•˜ì§€ ì•Šìœ¼ë©°, ë©”ì„œë“œëŠ” ë°˜ë“œì‹œ í´ë˜ìŠ¤ë‚˜ ì¸í„°í˜ì´ìŠ¤ì— ì†í•œë‹¤.
> **ìš©ì–´ - ëŒë‹¤ vs ëŒë‹¤ì‹(Lambda Expression)**
> - **ëŒë‹¤**: ìµëª… í•¨ìˆ˜ë¥¼ ì§€ì¹­í•˜ëŠ” ì¼ë°˜ì ì¸ ìš©ì–´ë‹¤. ì‰½ê²Œ ì´ì•¼ê¸°í•´ì„œ ê°œë…ì´ë‹¤.
> - **ëŒë‹¤ì‹**: (ë§¤ê°œë³€ìˆ˜) { ë³¸ë¬¸ } í˜•íƒœë¡œ ëŒë‹¤ë¥¼ êµ¬í˜„í•˜ëŠ” êµ¬ì²´ì ì¸ ë¬¸ë²• í‘œí˜„ì„ ì§€ì¹­í•œë‹¤.
> ì‰½ê²Œ ì´ì•¼ê¸°í•´ì„œ ëŒë‹¤ëŠ” ê°œë…ì„, ëŒë‹¤ì‹ì€ ìë°”ì—ì„œ ê·¸ ê°œë…ì„ êµ¬í˜„í•˜ëŠ” êµ¬ì²´ì ì¸ ë¬¸ë²•ì„ ì˜ë¯¸í•œë‹¤. ëŒë‹¤ê°€ ë„“ì€
> ì˜ë¯¸ì´ê³ , ë˜ ì‹¤ë¬´ì—ì„œ ë‘ ìš©ì–´ë¥¼ êµ¬ë¶„í•´ì„œ ì‚¬ìš©í•˜ì§€ëŠ” ì•Šê¸° ë•Œë¬¸ì— ì—¬ê¸°ì„œëŠ” ëŒ€ë¶€ë¶„ ê°„ê²°í•˜ê²Œ ëŒë‹¤ë¼ê³  í•˜ê² ë‹¤.

#### ëŒë‹¤ëŠ” í‘œí˜„ì´ ê°„ê²°í•˜ë‹¤
```
Procedure procedure = new Procedure() {
    @Override
    public void run() {
        System.out.println("hello! lambda");
    }
};
```
- ìµëª… í´ë˜ìŠ¤ë¥¼ ì‚¬ìš©í•˜ë©´ new í‚¤ì›Œë“œ, ìƒì„±í•  í´ë˜ìŠ¤ëª…, ë©”ì„œë“œëª…, ë°˜í™˜ íƒ€ì… ë“±ì„ ëª¨ë‘ ë‚˜ì—´í•´ì•¼ í•œë‹¤.
```
Procedure procedure = () -> {
    System.out.println("hello! lambda");
};
```
- ëŒë‹¤ë¥¼ ì‚¬ìš©í•˜ë©´ ì´ëŸ° ë¶€ë¶„ì„ ëª¨ë‘ ìƒëµí•˜ê³ , ë§¤ê°œë³€ìˆ˜ì™€ ë³¸ë¬¸ë§Œ ì ìœ¼ë©´ ëœë‹¤.

#### ëŒë‹¤ëŠ” ë³€ìˆ˜ì²˜ëŸ¼ ë‹¤ë£° ìˆ˜ ìˆë‹¤
```
Procedure procedure = () -> { // ëŒë‹¤ë¥¼ ë³€ìˆ˜ì— ë‹´ìŒ
    System.out.println("hello! lambda");
};

procedure.run(); // ë³€ìˆ˜ë¥¼ í†µí•´ ëŒë‹¤ë¥¼ ì‹¤í–‰
```
- ëŒë‹¤ë¥¼ procedure ë¼ëŠ” ë³€ìˆ˜ì— ë‹´ì•˜ë‹¤.
- procedure ë³€ìˆ˜ë¥¼ í†µí•´ ì´ê³³ì— ë‹´ì€ ëŒë‹¤ë¥¼ ì‹¤í–‰í•  ìˆ˜ ìˆë‹¤.

#### ëŒë‹¤ë„ í´ë˜ìŠ¤ê°€ ë§Œë“¤ì–´ì§€ê³ , ì¸ìŠ¤í„´ìŠ¤ê°€ ìƒì„±ëœë‹¤
- ëŒë‹¤ë„ ìµëª… í´ë˜ìŠ¤ì²˜ëŸ¼ í´ë˜ìŠ¤ê°€ ë§Œë“¤ì–´ì§€ê³ , ì¸ìŠ¤í„´ìŠ¤ê°€ ìƒì„±ëœë‹¤.
```java
package lambda.lambda1;

import lambda.Procedure;

public class InstanceMain {
    public static void main(String[] args) {
        Procedure procedure1 = new Procedure() {
            @Override
            public void run() {
                System.out.println("hello! lambda");
            }
        };

        System.out.println("class.class = " + procedure1.getClass());
        System.out.println("class.instance = " + procedure1);

        Procedure procedure2 = () -> {
            System.out.println("hello! lambda");
        };

        System.out.println("lambda.class = " + procedure2.getClass());
        System.out.println("lambda.instance = " + procedure2);
    }
}
```

#### ì‹¤í–‰ ê²°ê³¼
```
class.class = class lambda.lambda1.InstanceMain$1
class.instance = lambda.lambda1.InstanceMain$1@506e6d5e
lambda.class = class lambda.lambda1.InstanceMain$$Lambda/0x00000008000c2618
lambda.instance = lambda.lambda1.InstanceMain$$Lambda/
0x00000008000c2618@3796751b
```
- ìµëª… í´ë˜ìŠ¤ì˜ ê²½ìš° $ ë¡œ êµ¬ë¶„í•˜ê³  ë’¤ì— ìˆ«ìê°€ ë¶™ëŠ”ë‹¤.
- ëŒë‹¤ì˜ ê²½ìš° $$ ë¡œ êµ¬ë¶„í•˜ê³  ë’¤ì— ë³µì¡í•œ ë¬¸ìê°€ ë¶™ëŠ”ë‹¤.
- ì‹¤í–‰ í™˜ê²½ì— ë”°ë¼ ê²°ê³¼ëŠ” ë‹¤ë¥¼ ìˆ˜ ìˆë‹¤.

#### ì •ë¦¬
- ëŒë‹¤ë¥¼ ì‚¬ìš©í•˜ë©´ ìµëª… í´ë˜ìŠ¤ ì‚¬ìš©ì˜ ë³´ì¼ëŸ¬í”Œë ˆì´íŠ¸ ì½”ë“œë¥¼ í¬ê²Œ ì¤„ì´ê³ , ê°„ê²°í•œ ì½”ë“œë¡œ ìƒì‚°ì„±ê³¼ ê°€ë…ì„±ì„ ë†’ì¼ ìˆ˜ ìˆë‹¤.
- ëŒ€ë¶€ë¶„ì˜ ìµëª… í´ë˜ìŠ¤ëŠ” ëŒë‹¤ë¡œ ëŒ€ì²´í•  ìˆ˜ ìˆë‹¤.
  - ì°¸ê³ ë¡œ ëŒë‹¤ê°€ ìµëª… í´ë˜ìŠ¤ë¥¼ ì™„ì „íˆ ëŒ€ì²´í•  ìˆ˜ ìˆëŠ” ê²ƒì€ ì•„ë‹ˆë‹¤. ëŒë‹¤ì™€ ìµëª… í´ë˜ìŠ¤ì˜ ì°¨ì´ëŠ” ë’¤ì—ì„œ ë”°ë¡œ ì •ë¦¬í•˜ê² ë‹¤.
- ëŒë‹¤ë¥¼ ì‚¬ìš©í•  ë•Œ new í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šì§€ë§Œ, ëŒë‹¤ë„ ìµëª… í´ë˜ìŠ¤ì²˜ëŸ¼ ì¸ìŠ¤í„´ìŠ¤ê°€ ìƒì„±ëœë‹¤.
- ì§€ê¸ˆì€ ëŒë‹¤ë¥¼ ìµëª… í´ë˜ìŠ¤ì˜ êµ¬í˜„ì„ ê°„ë‹¨íˆ í‘œí˜„í•  ìˆ˜ ìˆëŠ” ë¬¸ë²• ì„¤íƒ•(Syntactic sugar, ì½”ë“œë¥¼ ê°„ê²°í•˜ê²Œ ë§Œë“œëŠ” ë¬¸ë²•ì  í¸ì˜) ì—­í•  ì •ë„ë¡œ
  ìƒê°í•˜ì. ëŒë‹¤ì™€ ìµëª… í´ë˜ìŠ¤ì˜ ì°¨ì´ëŠ” ë’¤ì—ì„œ ì„¤ëª…í•œë‹¤.

## í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤
**í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤**ëŠ” ì •í™•íˆ í•˜ë‚˜ì˜ ì¶”ìƒ ë©”ì„œë“œë¥¼ ê°€ì§€ëŠ” ì¸í„°í˜ì´ìŠ¤ë¥¼ ë§í•œë‹¤.
ëŒë‹¤ëŠ” ì¶”ìƒ ë©”ì„œë“œê°€ í•˜ë‚˜ì¸ **í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤**ì—ë§Œ í• ë‹¹í•  ìˆ˜ ìˆë‹¤.
ë‹¨ì¼ ì¶”ìƒ ë©”ì„œë“œë¥¼ ì¤„ì—¬ì„œ **SAM**(Single Abstract Method)ì´ë¼ í•œë‹¤.
ì°¸ê³ ë¡œ ëŒë‹¤ëŠ” í´ë˜ìŠ¤, ì¶”ìƒ í´ë˜ìŠ¤ì—ëŠ” í• ë‹¹í•  ìˆ˜ ì—†ë‹¤. ì˜¤ì§ ë‹¨ì¼ ì¶”ìƒ ë©”ì„œë“œë¥¼ ê°€ì§€ëŠ” ì¸í„°í˜ì´ìŠ¤ì—ë§Œ í• ë‹¹í•  ìˆ˜ ìˆë‹¤.

#### ì—¬ëŸ¬ ì¶”ìƒ ë©”ì„œë“œ
```java
package lambda.lambda1;

public interface NotSamInterface {
      void run();
      void go(); 
}
```
- ì¸í„°í˜ì´ìŠ¤ì˜ ë©”ì„œë“œ ì•ì—ëŠ” abstract (ì¶”ìƒ)ì´ ìƒëµë˜ì–´ ìˆë‹¤. (ìë°” ê¸°ë³¸!)
- ì—¬ê¸°ì—ëŠ” run() , go() ë‘ ê°œì˜ ì¶”ìƒ ë©”ì„œë“œê°€ ì„ ì–¸ë˜ì–´ ìˆë‹¤.
- ë‹¨ì¼ ì¶”ìƒ ë©”ì„œë“œ(SAM)ê°€ ì•„ë‹ˆë‹¤. ì´ ì¸í„°í˜ì´ìŠ¤ì—ëŠ” ëŒë‹¤ë¥¼ í• ë‹¹í•  ìˆ˜ ì—†ë‹¤.

#### ë‹¨ì¼ ì¶”ìƒ ë©”ì„œë“œ
```java
package lambda.lambda1;

public interface SamInterface {
    void run();
}
```
- ì—¬ê¸°ì—ëŠ” run() í•œ ê°œì˜ ì¶”ìƒ ë©”ì„œë“œë§Œ ì„ ì–¸ë˜ì–´ ìˆë‹¤.
- ë‹¨ì¼ ì¶”ìƒ ë©”ì„œë“œ(SAM)ì´ë‹¤. ì´ ì¸í„°í˜ì´ìŠ¤ì—ëŠ” ëŒë‹¤ë¥¼ í• ë‹¹í•  ìˆ˜ ìˆë‹¤.
```java
package lambda.lambda1;

public class SamMain {

    public static void main(String[] args) {
        SamInterface samInterface = () -> {
            System.out.println("sam");
        };

        samInterface.run();

        // ì»´íŒŒì¼ ì˜¤ë¥˜
        NotSamInterface notSamInterface = () -> {
            System.out.println("sam");
        };

        notSamInterface.go();
        notSamInterface.run();
    }
}
```
#### ì»´íŒŒì¼ ì˜¤ë¥˜ - ì‹¤í–‰ ê²°ê³¼
```
java: incompatible types: lambda.lambda1.NotSamInterface is not a functional 
interface
    multiple non-overriding abstract methods found in interface 
lambda.lambda1.NotSamInterface
```
- NotSamInterface ì´ í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ê°€ ì•„ë‹ˆë¼ëŠ” ì»´íŒŒì¼ ì˜¤ë¥˜ ë©”ì‹œì§€ê°€ ë‚˜ì˜¨ë‹¤.
- ì˜¤ë¥˜ë¥¼ í™•ì¸í–ˆìœ¼ë©´ ì»´íŒŒì¼ ì˜¤ë¥˜ ë¶€ë¶„ì„ ë‹¤ì‹œ ì£¼ì„ ì²˜ë¦¬í•˜ì.

#### ìë°”ëŠ” ì™œ ë‹¤ìŒ ì½”ë“œë¥¼ í—ˆìš©í•˜ì§€ ì•Šì„ê¹Œ?
```
NotSamInterface notSamInterface = () -> {
    System.out.println("not sam");
};

notSamInterface.go();
notSamInterface.run();
```
- ëŒë‹¤ëŠ” í•˜ë‚˜ì˜ í•¨ìˆ˜ì´ë‹¤. ë”°ë¼ì„œ ëŒë‹¤ë¥¼ ì¸í„°í˜ì´ìŠ¤ì— ë‹´ìœ¼ë ¤ë©´ í•˜ë‚˜ì˜ ë©”ì„œë“œ(í•¨ìˆ˜) ì„ ì–¸ë§Œ ì¡´ì¬í•´ì•¼ í•œë‹¤.
- ì¸í„°í˜ì´ìŠ¤ëŠ” ì—¬ëŸ¬ ë©”ì„œë“œ(í•¨ìˆ˜)ë¥¼ ì„ ì–¸í•  ìˆ˜ ìˆë‹¤. ì—¬ê¸°ì„œëŠ” run(), go() ë‘ ë©”ì„œë“œê°€ ì¡´ì¬í•œë‹¤.
- ì´ í•¨ìˆ˜ë¥¼ NoSamInterfaceì— ìˆëŠ” run() ë˜ëŠ” go() ë‘˜ ì¤‘ í•˜ë‚˜ì— í• ë‹¹í•´ì•¼ í•˜ëŠ” ë¬¸ì œê°€ ë°œìƒí•œë‹¤.

ìë°”ëŠ” ì´ëŸ¬í•œ ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´, ë‹¨ í•˜ë‚˜ì˜ ì¶”ìƒ ë©”ì„œë“œ(SAM: Single Abstract Method)ë§Œì„ í¬í•¨í•˜ëŠ” 
**í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ì—ë§Œ ëŒë‹¤ë¥¼ í• ë‹¹í•  ìˆ˜ ìˆë„ë¡ ì œí•œ**í–ˆë‹¤.
SamInterface ì€ run() ì´ë¼ëŠ” ë‹¨ í•˜ë‚˜ì˜ ì¶”ìƒ ë©”ì„œë“œë§Œì„ í¬í•¨í•œë‹¤. ë”°ë¼ì„œ ë¬¸ì œ ì—†ì´ ëŒë‹¤ë¥¼ í• ë‹¹í•˜ê³  ì‹¤í–‰í• 
ìˆ˜ ìˆë‹¤.

### @FunctionalInterface
```java
public class Car {
    public void move() {
        System.out.println("ì°¨ë¥¼ ì´ë™í•©ë‹ˆë‹¤.");
    }
}
```

```java
public class ElectricCar extends Car{
    @Override
    public void move() {
        System.out.println("ì „ê¸°ì°¨ë¥¼ ë¹ ë¥´ê²Œ ì´ë™í•©ë‹ˆë‹¤.");
    }
}
```
ë©”ì„œë“œë¥¼ ì¬ì •ì˜í•  ë•Œ ì‹¤ìˆ˜ë¡œ ì¬ì •ì˜í•  ë©”ì„œë“œ ì´ë¦„ì„ ë‹¤ë¥´ê²Œ ì ìœ¼ë©´ ì¬ì •ì˜ê°€ ë˜ì§€ ì•ŠëŠ”ë‹¤. ì´ ì˜ˆì œì—ì„œ ë¶€ëª¨ëŠ”
move() ì¸ë° ìì‹ì€ movee() ë¼ê³  e ë¥¼ í•˜ë‚˜ ë” ì˜ëª» ì ì—ˆë‹¤. ì´ëŸ° ë¬¸ì œë¥¼ ì»´íŒŒì¼ ë‹¨ê³„ì—ì„œ ì›ì²œì ìœ¼ë¡œ ë§‰ê¸° ìœ„í•´
@Override ì• ë…¸í…Œì´ì…˜ì„ ì‚¬ìš©í•œë‹¤. ì´ ì• ë…¸í…Œì´ì…˜ ë•ë¶„ì— ê°œë°œìê°€ í•  ìˆ˜ ìˆëŠ” ì‹¤ìˆ˜ë¥¼ ì»´íŒŒì¼ ë‹¨ê³„ì—ì„œ ë§‰ì„ ìˆ˜ ìˆ
ê³ , ë˜ ê°œë°œìëŠ” ì´ ë©”ì„œë“œê°€ ì¬ì •ì˜ ë©”ì„œë“œì¸ì§€ ëª…í™•í•˜ê²Œ ì¸ì§€í•  ìˆ˜ ìˆë‹¤.

í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ëŠ” ë‹¨ í•˜ë‚˜ì˜ ì¶”ìƒ ë©”ì„œë“œ(SAM: Single Abstract Method)ë§Œì„ í¬í•¨í•˜ëŠ” ì¸í„°í˜ì´ìŠ¤ì´ë‹¤.
ê·¸ë¦¬ê³  ëŒë‹¤ëŠ” í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ì—ë§Œ í• ë‹¹í•  ìˆ˜ ìˆë‹¤.
ê·¸ëŸ°ë° ë‹¨ í•˜ë‚˜ì˜ ì¶”ìƒ ë©”ì„œë“œë§Œì„ í¬í•¨í•œë‹¤ëŠ” ê²ƒì„ ì–´ë–»ê²Œ ë³´ì¥í•  ìˆ˜ ìˆì„ê¹Œ?
@FunctionalInterface ì• ë…¸í…Œì´ì…˜ì„ ë¶™ì—¬ì£¼ë©´ ëœë‹¤. ì´ ì• ë…¸í…Œì´ì…˜ì´ ìˆìœ¼ë©´ ë‹¨ í•˜ë‚˜ì˜ ì¶”ìƒ ë©”ì„œë“œê°€ ì•„ë‹ˆë©´
ì»´íŒŒì¼ ë‹¨ê³„ì—ì„œ ì˜¤ë¥˜ê°€ ë°œìƒí•œë‹¤. ë”°ë¼ì„œ í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ì„ì„ ë³´ì¥í•  ìˆ˜ ìˆë‹¤.

```java
@FunctionalInterface // ì• ë…¸í…Œì´ì…˜ ì¶”ê°€
public interface SamInterface {
    void run();
}
```
- @FunctionalInterface ì„ í†µí•´ í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ì„ì„ ì„ ì–¸í•´ë‘ë©´, ì´í›„ì— ëˆ„êµ°ê°€ ì‹¤ìˆ˜ë¡œ 
  ì¶”ìƒ ë©”ì„œë“œë¥¼ ì¶”ê°€í•  ë•Œ ì»´íŒŒì¼ ì˜¤ë¥˜ê°€ ë°œìƒí•œë‹¤
```java
@FunctionalInterface // ì• ë…¸í…Œì´ì…˜ ì¶”ê°€
public interface SamInterface {
    void run();
    void gogo(); // ì‹¤ìˆ˜ë¡œ ëˆ„êµ°ê°€ ì¶”ê°€ì‹œ ì»´íŒŒì¼ ì˜¤ë¥˜ ë°œìƒ
}
```
```
java: Unexpected @FunctionalInterface annotation
 lambda.lambda1.SamInterface is not a functional interface
 multiple non-overriding abstract methods found in interface 
lambda.lambda1.SamInterface
```
- í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ê°€ ì•„ë‹ˆë¼ëŠ” ì»´íŒŒì¼ ì˜¤ë¥˜ ë©”ì‹œì§€
- ì˜¤ë¥˜ë¥¼ í™•ì¸í–ˆìœ¼ë©´ gogo() ë©”ì„œë“œëŠ” ì‚­ì œí•˜ì

ë”°ë¼ì„œ ëŒë‹¤ë¥¼ ì‚¬ìš©í•  í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ë¼ë©´ @FunctionalInterface ë¥¼ í•„ìˆ˜ë¡œ ì¶”ê°€í•˜ëŠ” ê²ƒì„ ê¶Œì¥í•œë‹¤.

## ëŒë‹¤ì™€ ì‹œê·¸ë‹ˆì²˜
ëŒë‹¤ë¥¼ í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ì— í• ë‹¹í•  ë–„ëŠ” ë©”ì„œë“œì˜ í˜•íƒœë¥¼ ì •ì˜í•˜ëŠ” ìš”ì†Œì¸ ë©”ì„œë“œ ì‹œê·¸ë‹ˆì²˜ê°€ ë§ì•„ì•¼ í•œë‹¤.
ë©”ì„œë“œ ì‹œê·¸ë‹ˆì²˜ì˜ ì£¼ìš” êµ¬ì„± ìš”ì†ŒëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤.
1. ë©”ì„œë“œ ì´ë¦„
2. ë§¤ê°œë³€ìˆ˜ì˜ ìˆ˜ì™€ íƒ€ì…(ìˆœì„œ í¬í•¨)
3. ë°˜í™˜ íƒ€ì…

#### MyFucntion ì˜ˆì‹œ
ì˜ˆë¥¼ ë“¤ì–´ MyFucntionì˜ apply ë©”ì„œë“œë¥¼ ì‚´í´ë³´ì
```java
@FunctionalInterface
public interface MyFunction {
    int apply(int a, int b);
}
```
ì´ ë©”ì„œë“œì˜ ì‹œê·¸ë‹ˆì²˜
- ì´ë¦„: apply
- ë§¤ê°œë³€ìˆ˜: int , int
- ë°˜í™˜ íƒ€ì…: int
```
MyFunction myFunction = (int a, int b) -> {
     return a + b;
};
```
ëŒë‹¤ëŠ” ìµëª… í•¨ìˆ˜ì´ë¯€ë¡œ ì‹œê·¸ë‹ˆì²˜ì—ì„œ ì´ë¦„ì€ ì œì™¸í•˜ê³ , **ë§¤ê°œë³€ìˆ˜, ë°˜í™˜ íƒ€ì…ì´ í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ì— ì„ ì–¸í•œ ë©”ì„œë“œì™€
ë§ì•„ì•¼ í•œë‹¤.**
ì´ ëŒë‹¤ëŠ” ë§¤ê°œë³€ìˆ˜ë¡œ int a , int b , ê·¸ë¦¬ê³  ë°˜í™˜ ê°’ìœ¼ë¡œ a + b ì¸ int íƒ€ì…ì„ ë°˜í™˜í•˜ë¯€ë¡œ ì‹œê·¸ë‹ˆì²˜ê°€ ë§ë‹¤. ë”°
ë¼ì„œ ëŒë‹¤ë¥¼ í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ì— í• ë‹¹í•  ìˆ˜ ìˆë‹¤.

ì°¸ê³ ë¡œ ëŒë‹¤ì˜ ë§¤ê°œë³€ìˆ˜ ì´ë¦„ì€ í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ì— ìˆëŠ” ë©”ì„œë“œ ë§¤ê°œë³€ìˆ˜ì˜ ì´ë¦„ê³¼ ìƒê´€ì—†ì´ ììœ ë¡­ê²Œ ì‘ì„±í•´ë„ ëœ
ë‹¤. íƒ€ì…ê³¼ ìˆœì„œë§Œ ë§ìœ¼ë©´ ëœë‹¤.
```
MyFunction myFunction = (int xxx, int yyy) -> {return xxx + yyy;};
```
#### Procedure ì˜ˆì‹œ
```java
@FunctionalInterface
public interface Procedure {
    void run();
}
```
ì´ ë©”ì„œë“œì˜ ì‹œê·¸ë‹ˆì²˜
- ì´ë¦„: run
- ë§¤ê°œë³€ìˆ˜: ì—†ìŒ
- ë°˜í™˜ íƒ€ì…: ì—†ìŒ
```
Procedure procedure = () -> {
    System.out.println("hello! lambda");
};
```
ì´ ëŒë‹¤ëŠ” ë§¤ê°œë³€ìˆ˜ê°€ ì—†ê³ , ë°˜í™˜ íƒ€ì…ì´ ì—†ìœ¼ë¯€ë¡œ ì‹œê·¸ë‹ˆì²˜ê°€ ë§ë‹¤.   
ë”°ë¼ì„œ ëŒë‹¤ë¥¼ í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ì— í• ë‹¹í•  ìˆ˜ ìˆë‹¤.

## ëŒë‹¤ì™€ ìƒëµ
ëŒë‹¤ëŠ” ê°„ê²°í•œ ì½”ë“œ ì‘ì„±ì„ ìœ„í•´ ë‹¤ì–‘í•œ ë¬¸ë²• ìƒëµì„ ì§€ì›í•œë‹¤
#### ë‹¨ì¼ í‘œí˜„ì‹1
```java
package lambda.lambda1;

import lambda.MyFunction;

public class LambdaSimple1 {
    public static void main(String[] args) {
        // ê¸°ë³¸
        MyFunction function1 = (int a, int b) -> {
            return a + b;
        };
        System.out.println("function1: " + function1.apply(1, 2));

        // ë‹¨ì¼ í‘œí˜„ì‹ì¸ ê²½ìš° ì¤‘ê´„í˜¸ì™€ ë¦¬í„´ ìƒëµ ê°€ëŠ¥
        MyFunction function2 = (int a, int b) -> a + b;
        System.out.println("function2: " + function2.apply(1, 2));

        // ë‹¨ì¼ í‘œí˜„ì‹ì´ ì•„ë‹ ê²½ìš° ì¤‘ê´„í˜¸ì™€ ë¦¬í„´ ëª¨ë‘ í•„ìˆ˜
        MyFunction function3 = (int a, int b) -> {
            System.out.println("ëŒë‹¤ ì‹¤í–‰");
            return a + b;
        };
        System.out.println("function3: " + function3.apply(1, 2));
    }
}
```
#### ì‹¤í–‰ ê²°ê³¼
```
function1: 3
function2: 3
ëŒë‹¤ ì‹¤í–‰
function3: 3
```

#### ìƒëµ ì „
```
(int a, int b) -> {return a + b;};
```
- a + b ì™€ ê°™ì´ ê°„ë‹¨í•œ ë‹¨ì¼ í‘œí˜„ì‹ì€ ì¤‘ê´„í˜¸( {} )ì™€ return ì„ í•¨ê»˜ ìƒëµí•  ìˆ˜ ìˆë‹¤.

#### ìƒëµ í›„
```
(int a, int b) -> a + b;
```
- ìƒëµí•œ ì½”ë“œëŠ” ìƒëµ ì „ ì½”ë“œì™€ ê°™ì€ ì½”ë“œì´ë‹¤. retrun ë¬¸ì´ ë³´ì´ì§€ ì•Šì§€ë§Œ ê²°ê³¼ë¥¼ ë°˜í™˜í•œë‹¤.

### í‘œí˜„ì‹(expression)ì´ë€?
- í•˜ë‚˜ì˜ ê°’ìœ¼ë¡œ í‰ê°€ë˜ëŠ” ì½”ë“œ ì¡°ê°ì„ ì˜ë¯¸í•œë‹¤.
- í‘œí˜„ì‹ì€ ì‚°ìˆ  ë…¼ë¦¬ í‘œí˜„ì‹, ë©”ì„œë“œ í˜¸ì¶œ, ê°ì²´ ìƒì„±ë“±ì´ ìˆë‹¤. 
  - ì˜ˆ) x + y , price * quantity , calculateTotal() , age >= 18
- í‘œí˜„ì‹ì´ ì•„ë‹Œê²ƒì€ ì œì–´ë¬¸, ë©”ì„œë“œ ì„ ì–¸ ê°™ì€ ê²ƒì´ ìˆë‹¤.
  - ì˜ˆ) if (condition) { }

### ëŒë‹¤ - ë‹¨ì¼ í‘œí˜„ì‹(single expression)ì¸ ê²½ìš°
- ì¤‘ê´„í˜¸ {}ì™€ return í‚¤ì›Œë“œë¥¼ í•¨ê»˜ ìƒëµí•  ìˆ˜ ìˆìŒ
  - í‘œí˜„ì‹ì˜ ê²°ê³¼ê°€ ìë™ìœ¼ë¡œ ë°˜í™˜ê°’ì´ ë¨
- ì¤‘ê´„í˜¸ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²½ìš°ì—ëŠ” ë°˜ë“œì‹œ retrun ë¬¸ì„ í¬í•¨í•´ì•¼ í•œë‹¤.
  - return ë¬¸ì„ ëª…ì‹œì ìœ¼ë¡œ í¬í•¨í•˜ëŠ” ê²½ìš° ì¤‘ê´„í˜¸ë¥¼ ì‚¬ìš©í•´ì•¼ í•œë‹¤.
  - ë°˜í™˜ íƒ€ì…ì´ void ì¸ ê²½ìš° return ìƒëµ ê°€ëŠ¥
#### ë‹¨ì¼ í‘œí˜„ì‹ì´ ì•„ë‹Œ ê²½ìš°
```
(int a, int b) -> {
    System.out.println("ëŒë‹¤ ì‹¤í–‰");
    return a + b;
};
```
- ë‹¨ì¼ í‘œí˜„ì‹ì´ ì•„ë‹Œ ê²½ìš° ì¤‘ê´„í˜¸( {} )ë¥¼ ìƒëµí•  ìˆ˜ ì—†ë‹¤. ì´ ê²½ìš° ë°˜í™˜ ê°’ì´ ìˆìœ¼ë©´ return ë¬¸ë„ í¬í•¨í•´ì•¼ í•œë‹¤.


### ë‹¨ì¼ í‘œí˜„ì‹2
ì´ë²ˆì—ëŠ” ë§¤ê°œë³€ìˆ˜ì™€ ë°˜í™˜ ê°’ì´ ì—†ëŠ” ê²½ìš°ë¥¼ ì‚´í´ë³´ì
```java
package lambda.lambda1;

import lambda.Procedure;

public class LambdaSimple2 {
    public static void main(String[] args) {
        // ë§¤ê°œë³€ìˆ˜, ë°˜í™˜ ê°’ì´ ì—†ëŠ” ê²½ìš°
        Procedure procedure1 = () -> {
            System.out.println("hello! lambda");
        };
        procedure1.run();

        // ë‹¨ì¼ í‘œí˜„ì‹ì€ ì¤‘ê´„í˜¸ ìƒëµ ê°€ëŠ¥
        Procedure procedure2 = () -> System.out.println("hello! lambda");
        procedure2.run();
    }
}
```
#### ì‹¤í–‰ ê²°ê³¼
```
hello! lambda
hello! lambda
```

ë§¤ê°œë³€ìˆ˜ì™€ ë°˜í™˜ ê°’ì´ ì—†ëŠ” ê²½ìš°ë„ ë™ì¼í•˜ë‹¤.  
Procedure.run() ì˜ ê²½ìš° ë°˜í™˜ íƒ€ì…ì´ void ì´ê¸° ë•Œë¬¸ì— ì¤‘ê´„í˜¸ë¥¼ ì‚¬ìš©í•´ë„ return ì€ ìƒëµí•  ìˆ˜ ìˆë‹¤.

### íƒ€ì… ì¶”ë¡ 
ë‹¤ìŒê³¼ ê°™ì€ ëŒë‹¤ ì½”ë“œë¥¼ ì‘ì„±í•œë‹¤ê³  ìƒê°í•´ë³´ì.
```
MyFcuntion function1 = (int a, int b) -> a + b;
```
- ì—¬ê¸°ì„œ ë§¤ê°œë³€ìˆ˜ì— í•´ë‹¹í•˜ëŠ” (int a, int b) ë¶€ë¶„ì„ ì§‘ì¤‘í•´ë³´ì.
- í•¨ìˆ˜í˜• ì¸í„°íŒ¨ì´ìŠ¤ì¸ MyFcuntionì˜ apply() ë©”ì„œë“œë¥¼ ë³´ë©´ ì´ë¯¸ int a, int bë¡œ ë§¤ê°œë³€ìˆ˜ì˜ íƒ€ì…ì´
  ì •ì˜ë˜ì–´ ìˆë‹¤.
- ë”°ë¼ì„œ ì´ ì •ë³´ë¥¼ ì‚¬ìš©í•˜ë©´ ëŒë‹¤ì˜ (int a, int b) ì—ì„œ íƒ€ì… ì •ë³´ë¥¼ ìƒëµí•  ìˆ˜ ìˆë‹¤.
```java
@FunctionalInterface
public interface MyFunction {
    int apply(int a, int b);
}
```
ë‹¤ìŒ ì˜ˆì œ ì½”ë“œë¡œ í™•ì¸í•´ë³´ì.
```java
package lambda.lambda1;

import lambda.MyFunction;

public class LambdaSimple3 {
    public static void main(String[] args) {
        // íƒ€ì… ìƒëµ ì „
        MyFunction function1 = (int a, int b) -> a + b;

        // MyFunction íƒ€ì…ì„ í†µí•´ íƒ€ì… ì¶”ë¡  ê°€ëŠ¥, ëŒë‹¤ëŠ” íƒ€ì… ìƒëµ ê°€ëŠ¥
        MyFunction function2 = (a, b) -> a + b;

        int result = function2.apply(1, 2);
        System.out.println("result = " + result);
    }
}
```

#### ì‹¤í–‰ ê²°ê³¼
```
result = 3
```

#### íƒ€ì… ìƒëµ ì „í›„
```
MyFunction function1 = (int a, int b) -> a + b; // íƒ€ì… ì§ì ‘ ì…ë ¥
MyFunction function2 = (a, b) -> a + b; // íƒ€ì… ì¶”ë¡  ì‚¬ìš©
```
- ìë°” ì»´íŒŒì¼ëŸ¬ëŠ” ëŒë‹¤ê°€ ì‚¬ìš©ë˜ëŠ” í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ì˜ ë©”ì„œë“œ íƒ€ì…ì„ ê¸°ë°˜ìœ¼ë¡œ ëŒë‹¤ì˜ ë§¤ê°œë³€ìˆ˜ì™€ ë°˜í™˜ê°’ì˜  
  íƒ€ì…ì„ ì¶”ë¡ í•œë‹¤. ë”°ë¼ì„œ ëŒë‹¤ëŠ” íƒ€ì…ì„ ìƒëµí•  ìˆ˜ ìˆë‹¤.
- ë°˜í™˜ íƒ€ì…ì€ ë¬¸ë²•ì ìœ¼ë¡œ ëª…ì‹œí•  ìˆ˜ ì—†ë‹¤. ëŒ€ì‹ ì— ì»´íŒŒì¼ëŸ¬ê°€ ìë™ìœ¼ë¡œ ì¶”ë¡ í•œë‹¤.

### ë§¤ê°œë³€ìˆ˜ì˜ ê´„í˜¸ ìƒëµ
```java
package lambda.lambda1;

public class LambdaSimple4 {
    public static void main(String[] args) {
        MyCall call1 = (int value) -> value * 2;    // ê¸°ë³¸
        MyCall call2 = (value) -> value * 2;        // íƒ€ì… ì¶”ë¡ 
        MyCall call3 = value -> value * 2;          // ë§¤ê°œë³€ìˆ˜ 1ê°œ, () ìƒëµ ê°€ëŠ¥

        System.out.println("call3 = " + call3.call(10));
    }

    interface MyCall {
        int call(int value);
    }
}
```
- ë§¤ê°œë³€ìˆ˜ê°€ ì •í™•íˆ í•˜ë‚˜ì´ë©´ì„œ, íƒ€ì…ì„ ìƒëµí•˜ê³ , ì´ë¦„ë§Œ ìˆëŠ” ê²½ìš° ì†Œê´„í˜¸ () ë¥¼ ìƒëµí•  ìˆ˜ ìˆë‹¤.
- ë§¤ê°œë³€ìˆ˜ê°€ ì—†ëŠ” ê²½ìš°ì—ëŠ” () ê°€ í•„ìˆ˜ì´ë‹¤.
- ë§¤ê°œë³€ìˆ˜ê°€ ë‘˜ ì´ìƒì´ë©´ () ê°€ í•„ìˆ˜ì´ë‹¤.

#### ì •ë¦¬
- **ë§¤ê°œë³€ìˆ˜ íƒ€ì…**: ìƒëµ ê°€ëŠ¥í•˜ì§€ë§Œ í•„ìš”í•˜ë‹¤ë©´ ëª…ì‹œì ìœ¼ë¡œ ì‘ì„±í•  ìˆ˜ ìˆë‹¤.
- **ë°˜í™˜ íƒ€ì…**: ë¬¸ë²•ì ìœ¼ë¡œ ëª…ì‹œí•  ìˆ˜ ì—†ê³ , ì‹ì˜ ê²°ê³¼ë¥¼ ë³´ê³  ì»´íŒŒì¼ëŸ¬ê°€ í•­ìƒ ì¶”ë¡ í•œë‹¤.
- ëŒë‹¤ëŠ” ë³´í†µ ê°„ëµí•˜ê²Œ ì‚¬ìš©í•˜ëŠ” ê²ƒì„ ê¶Œì¥í•œë‹¤.
  - ë‹¨ì¼ í‘œí˜„ì‹ì´ë©´ ì¤‘ê´„í˜¸ì™€ ë¦¬í„´ì„ ìƒëµí•˜ì.
  - íƒ€ì… ì¶”ë¡ ì„ í†µí•´ ë§¤ê°œë³€ìˆ˜ì˜ íƒ€ì…ì„ ìƒëµí•˜ì. (ì»´íŒŒì¼ëŸ¬ê°€ ì¶”ë¡ í•  ìˆ˜ ìˆë‹¤ë©´, ìƒëµí•˜ì)

## ëŒë‹¤ì˜ ì „ë‹¬
ëŒë‹¤ëŠ” í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ë¥¼ í†µí•´ ë³€ìˆ˜ì— ëŒ€ì…í•˜ê±°ë‚˜, ë©”ì„œë“œì— ì „ë‹¬í•˜ê±°ë‚˜ ë°˜í™˜í•  ìˆ˜ ìˆë‹¤.

### ëŒë‹¤ë¥¼ ë³€ìˆ˜ì— ëŒ€ì…í•˜ê¸°
```java
package lambda.lambda2;

import lambda.MyFunction;

// 1. ëŒë‹¤ë¥¼ ë³€ìˆ˜ì— ëŒ€ì…í•˜ê¸°
public class LambdaPassMain1 {
    public static void main(String[] args) {
        MyFunction add = (a, b) -> a + b;
        MyFunction sub = (a, b) -> a - b;

        System.out.println("add.apply(1, 2) = " + add.apply(1, 2));
        System.out.println("sub.apply(1, 2) = " + sub.apply(1, 2));

        MyFunction cal = add;
        System.out.println("cal(add).apply(1, 2) = " + cal.apply(1, 2));

        cal = sub;
        System.out.println("cal(sub).apply(1, 2) = " + cal.apply(1, 2));
    }
}
```
#### ì‹¤í–‰ ê²°ê³¼
```
add.apply(1, 2) = 3
sub.apply(1, 2) = -1
cal(add).apply(1, 2) = 3
cal(sub).apply(1, 2) = -1
```
```
MyFunction add = (a, b) -> a + b;
```
- ì´ ëŒ€ì…ì‹ì—ì„œ ë³€ìˆ˜ addì˜ íƒ€ì…ì€ MyFunction í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ì´ë‹¤. ë”°ë¼ì„œ MyFunction í˜•ì‹ì— ë§ëŠ”  
  ëŒë‹¤ë¥¼ ëŒ€ì…í•  ìˆ˜ ìˆë‹¤.(ë©”ì„œë“œ ì‹œê·¸ë‹ˆì²˜ê°€ ì¼ì¹˜í•œë‹¤)

ìë°”ì—ì„œ ê¸°ë³¸í˜•ê³¼ ì°¸ì¡°í˜•ì€ ë‹¤ìŒê³¼ ê°™ì€ ë³€ìˆ˜ì— ê°’ì„ ëŒ€ì…í•  ìˆ˜ ìˆë‹¤.
#### ê¸°ë³¸í˜•ì˜ ê°’ ëŒ€ì…
```
int a = 10;
int c;
c = a;
```

#### ì°¸ì¡°í˜•ì˜ ê°’ ëŒ€ì…
```
Member newMember = new Member();
Member target;
target = newMember;
```
í´ë˜ìŠ¤ë‚˜ ì¸í„°í˜ì´ìŠ¤ë¡œ ì„ ì–¸í•œ ë³€ìˆ˜ì— ê°’ì„ ëŒ€ì…í•˜ëŠ” ê²ƒì€ ì¸ìŠ¤í„´ìŠ¤ì˜ ì°¸ì¡°ê°’ì„ ëŒ€ì…í•˜ëŠ” ê²ƒì´ë‹¤.

#### ëŒë‹¤ì˜ ëŒ€ì…
```
MyFunction add = (a, b) -> a + b;
MyFunction cal = add;
```
```
// ëŒë‹¤ì˜ ëŒ€ì… ë¶„ì„
MyFunction add = (a, b) -> a + b; // 1. ëŒë‹¤ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
MyFunction add = x001; // 2. ì°¸ì¡°ê°’ ë°˜í™˜, addì— x001 ëŒ€ì…
MyFunction cal = add;
MyFunction cal = x001; // 3. calì— ì°¸ì¡°ê°’ ëŒ€ì…
```
ëŒë‹¤ë„ ë§ˆì°¬ê°€ì§€ë‹¤. í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ë¡œ ì„ ì–¸í•œ ë³€ìˆ˜ì— ëŒë‹¤ë¥¼ ëŒ€ì…í•˜ëŠ” ê²ƒì€ ëŒë‹¤ ì¸ìŠ¤í„´ìŠ¤ì˜ ì°¸ì¡°ê°’ì„ ëŒ€ì…í•˜ëŠ” ê²ƒ
ì´ë‹¤.
ì´í•´ê°€ ì˜ ì•ˆëœë‹¤ë©´ ìµëª… í´ë˜ìŠ¤ì˜ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•˜ê³  ëŒ€ì…í•œë‹¤ê³  ìƒê°í•´ë³´ì.
ì°¸ê³ ë¡œ í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ë„ ì¸í„°í˜ì´ìŠ¤ì´ë‹¤.

ëŒë‹¤ë„ ì¸í„°í˜ì´ìŠ¤(í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤)ë¥¼ ì‚¬ìš©í•˜ë¯€ë¡œ, ëŒë‹¤ ì¸ìŠ¤í„´ìŠ¤ì˜ ì°¸ì¡°ê°’ì„ ë³€ìˆ˜ì— ì „ë‹¬í•  ìˆ˜ ìˆë‹¤.
ë³€ìˆ˜ì— ì°¸ì¡°ê°’ì„ ì „ë‹¬í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ ë‹¤ìŒê³¼ ê°™ì´ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.
- ë§¤ê°œë³€ìˆ˜ë¥¼ í†µí•´ ë©”ì„œë“œ(í•¨ìˆ˜)ì— ëŒë‹¤ë¥¼ ì „ë‹¬í•  ìˆ˜ ìˆë‹¤. (ì •í™•íˆëŠ” ëŒë‹¤ ì¸ìŠ¤í„´ìŠ¤ì˜ ì°¸ì¡°ê°’ì„ ì „ë‹¬)
- ë©”ì„œë“œê°€ ëŒë‹¤ë¥¼ ë°˜í™˜í•  ìˆ˜ ìˆë‹¤. (ì •í™•íˆëŠ” ëŒë‹¤ ì¸ìŠ¤í„´ìŠ¤ì˜ ì°¸ì¡°ê°’ì„ ë°˜í™˜)

### ëŒë‹¤ë¥¼ ë©”ì„œë“œ(í•¨ìˆ˜)ì— ì „ë‹¬í•˜ê¸°
ì•ì„œ ë³¸ ê²ƒê³¼ ê°™ì´ ëŒë‹¤ëŠ” ë³€ìˆ˜ì— ì „ë‹¬í•  ìˆ˜ ìˆë‹¤.  
ê°™ì€ ì›ë¦¬ë¡œ ëŒë‹¤ë¥¼ ë§¤ê°œë³€ìˆ˜ë¥¼ í†µí•´ ë©”ì„œë“œ(í•¨ìˆ˜)ì— ì „ë‹¬í•  ìˆ˜ ìˆë‹¤.
```java
import lambda.MyFunction;

// 2. ëŒë‹¤ë¥¼ ë©”ì„œë“œ(í•¨ìˆ˜)ì— ì „ë‹¬í•˜ê¸°
public class LambdaPassMain2 {
    public static void main(String[] args) {
        MyFunction add = (a, b) -> a + b;
        MyFunction sub = (a, b) -> a - b;

        System.out.println("ë³€ìˆ˜ë¥¼ í†µí•´ ì „ë‹¬");
        calculate(add);
        calculate(sub);

        System.out.println("ëŒë‹¤ë¥¼ ì§ì ‘ ì „ë‹¬");
        calculate((a, b) -> a + b);
        calculate((a, b) -> a - b);
    }

    static void calculate(MyFunction function) {
        int a = 1;
        int b = 2;
        System.out.println("ê³„ì‚° ì‹œì‘");
        int result = function.apply(a, b);
        System.out.println("ê³„ì‚° ê²°ê³¼: " + result);
    }
}
```
#### ì‹¤í–‰ ê²°ê³¼
```
ë³€ìˆ˜ë¥¼ í†µí•´ ì „ë‹¬
ê³„ì‚° ì‹œì‘
ê³„ì‚° ê²°ê³¼: 3
ê³„ì‚° ì‹œì‘
ê³„ì‚° ê²°ê³¼: -1
ëŒë‹¤ë¥¼ ì§ì ‘ ì „ë‹¬
ê³„ì‚° ì‹œì‘
ê³„ì‚° ê²°ê³¼: 3
ê³„ì‚° ì‹œì‘
ê³„ì‚° ê²°ê³¼: -1
```
```

```
- calcualte() ë©”ì„œë“œì˜ ë§¤ê°œë³€ìˆ˜ëŠ” MyFucntion í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ì´ë‹¤. ë”°ë¼ì„œ ëŒë‹¤ë¥¼ ì „ë‹¬í•  ìˆ˜ ìˆë‹¤.
#### ëŒë‹¤ë¥¼ ë³€ìˆ˜ì— ë‹´ì€ í›„ì— ë§¤ê°œë³€ìˆ˜ì— ì „ë‹¬
```
MyFunction add = (a, b) -> a + b;
calculate(add);
```
```
// ëŒë‹¤ë¥¼ ë³€ìˆ˜ì— ë‹´ì€ í›„ì— ë§¤ê°œë³€ìˆ˜ì— ì „ë‹¬ ë¶„ì„
MyFunction add = (a, b) -> a + b; // 1. ëŒë‹¤ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
MyFunction add = x001; // 2. ì°¸ì¡°ê°’ ë°˜í™˜
add = x001; // 3. ì°¸ì¡°ê°’ ëŒ€ì…

calculate(add);
calculate(x001);

// ë©”ì„œë“œ í˜¸ì¶œ, ë§¤ê°œë³€ìˆ˜ì— ì°¸ì¡°ê°’ ëŒ€ì…
void calculate(MyFunction function = x001)
```

#### ëŒë‹¤ë¥¼ ì§ì ‘ ì „ë‹¬
```
calculate((a, b) -> a + b);
```
```
// ëŒë‹¤ë¥¼ ì§ì ‘ ì „ë‹¬ ë¶„ì„
calculate((a, b) -> a + b); // 1. ëŒë‹¤ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
calculate(x001); // 2. ì°¸ì¡°ê°’ ë°˜í™˜ ë° ë§¤ê°œë³€ìˆ˜ì— ì „ë‹¬

// ë©”ì„œë“œ í˜¸ì¶œ, ë§¤ê°œë³€ìˆ˜ì— ì°¸ì¡°ê°’ ëŒ€ì…
void calculate(MyFunction function = x001)
```
- ëŒë‹¤ ì¸ìŠ¤í„´ìŠ¤ì˜ ì°¸ì¡°ë¥¼ ë§¤ê°œë³€ìˆ˜ì— ì „ë‹¬í•˜ëŠ” ê²ƒì´ê¸° ë•Œë¬¸ì— ì´í•´í•˜ëŠ”ë° ì–´ë ¤ì›€ì€ ì—†ì„ ê²ƒì´ë‹¤.
- ì¼ë°˜ì ì¸ ì°¸ì¡°ë¥¼ ë§¤ê°œë³€ìˆ˜ì— ì „ë‹¬í•˜ëŠ” ê²ƒê³¼ ê°™ë‹¤.

#### ëŒë‹¤ë¡œ ë°”ê¾¸ê¸° ì „(ìµëª… í´ë˜ìŠ¤ ë²„ì „)
```java
package lambda.lambda2;

import lambda.MyFunction;

public class LambdaPassMain3 {
    public static void main(String[] args) {
        MyFunction add = getOperation("add");
        System.out.println("add.apply(1, 2) = " + add.apply(1, 2));

        MyFunction sub = getOperation("sub");
        System.out.println("sub.apply(1, 2) = " + sub.apply(1, 2));

        MyFunction xxx = getOperation("xxx");
        System.out.println("xxx.apply(1, 2) = " + xxx.apply(1, 2));
    }

    // ëŒë‹¤ë¥¼ ë°˜í™˜í•˜ëŠ” ë©”ì„œë“œ
    static MyFunction getOperation(String operator) {
        switch (operator) {
            case "add":
                return new MyFunction() {
                    @Override
                    public int apply(int a, int b) {
                        return a + b;
                    }
                };
            case "sub":
                return new MyFunction() {
                    @Override
                    public int apply(int a, int b) {
                        return a - b;
                    }
                };
            default:
                return new MyFunction() {
                    @Override
                    public int apply(int a, int b) {
                        return 0;
                    }
                };
        }
    }
}
```


#### ëŒë‹¤ë¥¼ ë°˜í™˜í•˜ê¸°
```java
package lambda.lambda2;

import lambda.MyFunction;

// 3. ëŒë‹¤ë¥¼ ë°˜í™˜í•˜ê¸°
public class LambdaPassMain3 {
    public static void main(String[] args) {
        MyFunction add = getOperation("add");
        System.out.println("add.apply(1, 2) = " + add.apply(1, 2));

        MyFunction sub = getOperation("sub");
        System.out.println("sub.apply(1, 2) = " + sub.apply(1, 2));

        MyFunction xxx = getOperation("xxx");
        System.out.println("xxx.apply(1, 2) = " + xxx.apply(1, 2));
    }

    // ëŒë‹¤ë¥¼ ë°˜í™˜í•˜ëŠ” ë©”ì„œë“œ
    static MyFunction getOperation(String operator) {
        switch (operator) {
            case "add":
                return (a, b) -> a + b;
            case "sub":
                return (a, b) -> a - b;
            default:
                return (a, b) -> 0;
        }
    }
}
```

#### ì‹¤í–‰ ê²°ê³¼
```
add.apply(1, 2) = 3
sub.apply(1, 2) = -1
xxx.apply(1, 2) = 0
```
```
MyFunction getOperation(String operator){}
```
- getOperation ë©”ì„œë“œëŠ” ë°˜í™˜ íƒ€ì…ì´ MyFunction í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ì´ë‹¤. ë”°ë¼ì„œ ëŒë‹¤ë¥¼ ë°˜í™˜í•  ìˆ˜ ìˆë‹¤.

#### ë¶„ì„
```
// 1. ë©”ì„œë“œë¥¼ í˜¸ì¶œí•œë‹¤.
MyFunction add = getOperation("add");

// 2. getOperation() ë©”ì„œë“œ ì•ˆì—ì„œ ë‹¤ìŒ ì½”ë“œê°€ í˜¸ì¶œëœë‹¤.
MyFunction getOperation(String operator) {} // ë°˜í™˜ íƒ€ì…ì´ MyFunction í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ì´ë‹¤.

return (a, b) -> a + b; // 2-1. ëŒë‹¤ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•œë‹¤.
return x001; // 2-2. ëŒë‹¤ ì¸ìŠ¤í„´ìŠ¤ì˜ ì°¸ì¡°ê°’ì„ ë°˜í™˜í•œë‹¤.

// 3. main ë©”ì„œë“œë¡œ ëŒë‹¤ ì¸ìŠ¤í„´ìŠ¤ì˜ ì°¸ì¡°ê°’ì´ ë°˜í™˜ëœë‹¤.
MyFunction add = x001; // 3-1. ëŒë‹¤ ì¸ìŠ¤í„´ìŠ¤ì˜ ì°¸ì¡°ê°’ì„ addì— ëŒ€ì…í•œë‹¤.
```

## ê³ ì°¨ í•¨ìˆ˜
ëŒë‹¤ì˜ ì „ë‹¬ ì •ë¦¬
ì•ì„œ ë°°ìš´ ë‚´ìš©ì„ ë‹¤ì‹œ í•œë²ˆ ì •ë¦¬í•´ë³´ì.
ëŒë‹¤ëŠ” í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„í•œ ìµëª… í´ë˜ìŠ¤ ì¸ìŠ¤í„´ìŠ¤ì™€ ê°™ì€ ê°œë…ìœ¼ë¡œ ì´í•´í•˜ë©´ ëœë‹¤. ì¦‰, ëŒë‹¤ë¥¼ ë³€ìˆ˜ì— ëŒ€ì…í•œë‹¤.
ëŠ” ê²ƒì€ ëŒë‹¤ ì¸ìŠ¤í„´ìŠ¤ì˜ ì°¸ì¡°ê°’ì„ ëŒ€ì…í•˜ëŠ” ê²ƒì´ê³ , ëŒë‹¤ë¥¼ ë©”ì„œë“œ(í•¨ìˆ˜)ì˜ ë§¤ê°œë³€ìˆ˜ë‚˜ ë°˜í™˜ê°’ìœ¼ë¡œ ë„˜ê¸´ë‹¤ëŠ” ê²ƒ ì—­ì‹œ  
**ëŒë‹¤ ì¸ìŠ¤í„´ìŠ¤ì˜ ì°¸ì¡°ê°’ì„ ì „ë‹¬, ë°˜í™˜**í•˜ëŠ” ê²ƒì´ë‹¤.

- **ëŒë‹¤ë¥¼ ë³€ìˆ˜ì— ëŒ€ì…**: MyFunction add = (a, b) -> a + b; ì²˜ëŸ¼ í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ íƒ€ì…ì˜ ë³€ìˆ˜ì— ëŒë‹¤   
  ì¸ìŠ¤í„´ìŠ¤ì˜ ì°¸ì¡°ë¥¼ ëŒ€ì…í•œë‹¤.
- **ëŒë‹¤ë¥¼ ë©”ì„œë“œ ë§¤ê°œë³€ìˆ˜ì— ì „ë‹¬**: ë©”ì„œë“œ í˜¸ì¶œ ì‹œ ëŒë‹¤ ì¸ìŠ¤í„´ìŠ¤ì˜ ì°¸ì¡°ë¥¼ ì§ì ‘ ë„˜ê¸°ê±°ë‚˜, ì´ë¯¸ ëŒë‹¤ ì¸ìŠ¤í„´ìŠ¤ë¥¼   
  ë‹´ê³  ìˆëŠ” ë³€ìˆ˜ë¥¼ ì „ë‹¬í•œë‹¤.

```
// ë³€ìˆ˜ì— ë‹´ì€ í›„ ì „ë‹¬
MyFunction add = (a, b) -> a + b;
calculate(add);

// ì§ì ‘ ì „ë‹¬
calculate((a, b) -> a + b);
```
- **ëŒë‹¤ë¥¼ ë©”ì„œë“œì—ì„œ ë°˜í™˜**: return (a, b) -> a + b; ì²˜ëŸ¼ í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ íƒ€ì…ì„ ë°˜í™˜ê°’ìœ¼ë¡œ ì§€ì •í•´  
  ëŒë‹¤ ì¸ìŠ¤í„´ìŠ¤ì˜ ì°¸ì¡°ë¥¼ ëŒë ¤ì¤„ ìˆ˜ ìˆë‹¤.

ì´ëŸ° ë°©ì‹ìœ¼ë¡œ ëŒë‹¤ë¥¼ ììœ ë¡­ê²Œ ì „ë‹¬í•˜ê±°ë‚˜ ë°˜í™˜í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì—, ì½”ë“œì˜ ê°„ê²°ì„±ê³¼ ìœ ì—°ì„±ì´ ë†’ì•„ì§„ë‹¤. ë§Œì•½ ìµëª…   
í´ë˜ìŠ¤ë¥¼ ì‘ì„±í•˜ê³  ì „ë‹¬í–ˆë‹¤ë©´ ë§¤ìš° ë²ˆì¡í–ˆì„ ê²ƒì´ë‹¤.

### ê³ ì°¨ í•¨ìˆ˜(Higher-Order Function)
ê³ ì°¨ í•¨ìˆ˜ëŠ” í•¨ìˆ˜ë¥¼ ê°’ì²˜ëŸ¼ ë‹¤ë£¨ëŠ” í•¨ìˆ˜ë¥¼ ëœ»í•œë‹¤.
ì¼ë°˜ì ìœ¼ë¡œ ë‹¤ìŒ ë‘ ê°€ì§€ ì¤‘ í•˜ë‚˜ë¥¼ ë§Œì¡±í•˜ë©´ ê³ ì°¨ í•¨ìˆ˜ë¼ í•œë‹¤.
- í•¨ìˆ˜ë¥¼ ì¸ìë¡œ ë°›ëŠ” í•¨ìˆ˜(ë©”ì„œë“œ)
- í•¨ìˆ˜ë¥¼ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜(ë©”ì„œë“œ)

#### í•¨ìˆ˜ë¥¼ ì¸ìë¡œ ë°›ëŠ” ê²½ìš°
```
// í•¨ìˆ˜(ëŒë‹¤)ë¥¼ ë§¤ê°œë³€ìˆ˜ë¡œ ë°›ìŒ
static void calculate(MyFunction function) {
    // ...
}
```

#### í•¨ìˆ˜ë¥¼ ë°˜í™˜í•˜ëŠ” ê²½ìš°
```
// í•¨ìˆ˜(ëŒë‹¤)ë¥¼ ë°˜í™˜
static MyFunction getOperation(String operator) {
    // ...
    return (a, b) -> a + b;
}
```
- ì¦‰, ë§¤ê°œë³€ìˆ˜ë‚˜ ë°˜í™˜ê°’ì— í•¨ìˆ˜(ë˜ëŠ” ëŒë‹¤)ë¥¼ í™œìš©í•˜ëŠ” í•¨ìˆ˜ê°€ ê³ ì°¨ í•¨ìˆ˜ì— í•´ë‹¹í•œë‹¤.
- ìë°”ì—ì„œ ëŒë‹¤(ìµëª… í•¨ìˆ˜)ëŠ” í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ë¥¼ í†µí•´ì„œë§Œ ì „ë‹¬í•  ìˆ˜ ìˆë‹¤.
- **ìë°”ì—ì„œ í•¨ìˆ˜ë¥¼ ì£¼ê³ ë°›ëŠ”ë‹¤ëŠ” ê²ƒ**ì€ "í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„í•œ ì–´ë–¤ ê°ì²´(ëŒë‹¤ë“  ìµëª… í´ë˜ìŠ¤ë“ )ë¥¼ ì£¼ê³ ë°›ëŠ”  
  ê²ƒ"ê³¼ ë™ì˜ì–´ì´ë‹¤. (í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ëŠ” ì¸í„°í˜ì´ìŠ¤ì´ë¯€ë¡œ ìµëª… í´ë˜ìŠ¤, ëŒë‹¤ ë‘˜ë‹¤ ëŒ€ì…í•  ìˆ˜ ìˆë‹¤. í•˜ì§€ë§Œ ì‹¤ì§ˆ  
  ì ìœ¼ë¡œ í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ì—ëŠ” ëŒë‹¤ë¥¼ ì£¼ë¡œ ì‚¬ìš©í•œë‹¤.)

### ìš©ì–´ - ê³ ì°¨ í•¨ìˆ˜
***ê³ ì°¨ í•¨ìˆ˜(Higher-Order Function)*** ë¼ëŠ” ì´ë¦„ì€ **í•¨ìˆ˜ë¥¼ ë‹¤ë£¨ëŠ” ì¶”ìƒí™” ìˆ˜ì¤€**ì´ ë” ë†’ë‹¤ëŠ” ë°ì—ì„œ ìœ ë˜í–ˆë‹¤.
- ë³´í†µì˜ (ì¼ë°˜ì ì¸) í•¨ìˆ˜ëŠ” **ë°ì´í„°(ê°’)**ë¥¼ ì…ë ¥ìœ¼ë¡œ ë°›ê³ , ê°’ì„ ë°˜í™˜í•œë‹¤.
- ì´ì— ë°˜í•´, ê³ ì°¨ í•¨ìˆ˜ëŠ” **í•¨ìˆ˜ë¥¼ ì¸ìë¡œ ë°›ê±°ë‚˜ í•¨ìˆ˜ë¥¼ ë°˜í™˜**í•œë‹¤.
- ì‰½ê²Œ ì´ì•¼ê¸°í•˜ë©´ ì¼ë°˜ í•¨ìˆ˜ëŠ” ê°’ì„ ë‹¤ë£¨ì§€ë§Œ, ê³ ì°¨ í•¨ìˆ˜ëŠ” í•¨ìˆ˜ ìì²´ë¥¼ ë‹¤ë£¬ë‹¤.

ì¦‰, "ê°’"ì„ ë‹¤ë£¨ëŠ” ê²ƒì„ ë„˜ì–´, "í•¨ìˆ˜"ë¼ëŠ” ê°œë… ìì²´ë¥¼ ê°’ì²˜ëŸ¼ ë‹¤ë£¬ë‹¤ëŠ” ì ì—ì„œ ì¶”ìƒí™”ì˜ ìˆ˜ì¤€(ê³„ì¸µ, order)ì´ í•œ ë‹¨ê³„
ë†’ì•„ì§„ë‹¤ê³  í•´ì„œ Higher-Order(ë” ë†’ì€ ì°¨ì›ì˜) í•¨ìˆ˜ë¼ê³  ë¶€ë¥¸ë‹¤.

## ë¬¸ì œì™€ í’€ì´1
### ë¬¸ì œ 1. ì¤‘ë³µë˜ëŠ” ë©”ì‹œì§€ ì¶œë ¥ ë¡œì§ ë¦¬íŒ©í† ë§
#### ë¬¸ì œ ì„¤ëª…

ë‹¤ìŒ ì½”ë“œëŠ” í™”ë©´ì— ì—¬ëŸ¬ ì¢…ë¥˜ì˜ ì¸ì‚¿ë§ ë©”ì‹œì§€ë¥¼ ì¶œë ¥í•˜ì§€ë§Œ, ëª¨ë“  ë©”ì„œë“œë§ˆë‹¤ === ì‹œì‘ === ê³¼ === ë === ì„ ì¶œë ¥í•˜ëŠ”   
ë¡œì§ì´ ì¤‘ë³µë˜ì–´ ìˆë‹¤. ì¤‘ë³µë˜ëŠ” ì½”ë“œë¥¼ ì œê±°í•˜ê³ , **ë³€í•˜ëŠ” ë¶€ë¶„(ì¸ì‚¿ë§ ë©”ì‹œì§€)** ë§Œ ë§¤ê°œë³€ìˆ˜ë¡œ ë°›ë„ë¡ ë¦¬íŒ©í† ë§ í•´ë¼.

#### ì˜ˆì‹œ ì½”ë“œ
```java
package lambda.ex1;

public class M1Before {
    public static void greetMorning() {
        System.out.println("=== ì‹œì‘ ===");
        System.out.println("Good Morning!");
        System.out.println("=== ë ===");
    }

    public static void greetAfternoon() {
        System.out.println("=== ì‹œì‘ ===");
        System.out.println("Good Afternoon!");
        System.out.println("=== ë ===");
    }

    public static void greetEvening() {
        System.out.println("=== ì‹œì‘ ===");
        System.out.println("Good Evening!");
        System.out.println("=== ë ===");
    }

    public static void main(String[] args) {
        greetMorning();
        greetAfternoon();
        greetEvening();
    }
}
```
```
=== ì‹œì‘ ===
Good Morning!
=== ë ===
=== ì‹œì‘ ===
Good Afternoon!
=== ë ===
=== ì‹œì‘ ===
Good Evening!
=== ë ===
```

#### ì •ë‹µ
```java
package lambda.ex1;

public class M1After {
    
    public static void greet(String message) {
        System.out.println("=== ì‹œì‘ ===");
        System.out.println(message);
        System.out.println("=== ë ===");
    }
    public static void main(String[] args) {
        greet("Good Morning!");
        greet("Good Afternoon!");
        greet("Good Evening!");
    }
}
```

### ë¬¸ì œ 2. ê°’ ë§¤ê°œë³€ìˆ˜í™” - ë‹¤ì–‘í•œ ë‹¨ìœ„ë¥¼ ë§¤ê°œë³€ìˆ˜ë¡œ ë°›ê¸°
#### ë¬¸ì œ ì„¤ëª…
ë‹¤ìŒ ì½”ë“œëŠ”, ì£¼ì–´ì§„ ìˆ«ì(ì˜ˆ: 10)ë¥¼ íŠ¹ì • ë‹¨ìœ„(ì˜ˆ: "kg")ë¡œ ì¶œë ¥í•˜ëŠ” ê°„ë‹¨í•œ ë©”ì„œë“œë¥¼ ì‘ì„±í•œ ì˜ˆì‹œì´ë‹¤.
ìˆ«ìì™€ ë‹¨ìœ„ë¥¼ ë‚˜ëˆ„ê³  ì¬ì‚¬ìš© ê°€ëŠ¥í•œ ë©”ì„œë“œë¥¼ ì‚¬ìš©í•˜ë„ë¡ ì½”ë“œë¥¼ ìˆ˜ì •í•´ë¼.

#### ì˜ˆì‹œ ì½”ë“œ
```java
public class M2Before {
    public static void print1() {
        System.out.println("ë¬´ê²Œ: 10kg");
    }

    public static void print2() {
        System.out.println("ë¬´ê²Œ: 50kg");
    }

    public static void print3() {
        System.out.println("ë¬´ê²Œ: 200g");
    }

    public static void print4() {
        System.out.println("ë¬´ê²Œ: 40g");
    }

    public static void main(String[] args) {
        print1();
        print2();
        print3();
        print4();
    }
}
```
```
ë¬´ê²Œ: 10kg
ë¬´ê²Œ: 50kg
ë¬´ê²Œ: 200g
ë¬´ê²Œ: 40g
```
#### ì •ë‹µ
```java
package lambda.ex1;

public class M2After {

    public static void print(int weight, String unit) {
        System.out.println("ë¬´ê²Œ: " + weight + unit);
    }
    public static void main(String[] args) {
        print(10, "kg");
        print(50, "kg");
        print(200, "g");
        print(40, "g");
    }
}
```

### ë¬¸ì œ 3. ë™ì‘ ë§¤ê°œë³€ìˆ˜í™” - ìµëª… í´ë˜ìŠ¤ë¡œ ë‹¤ë¥¸ ë¡œì§ ì „ë‹¬
#### ë¬¸ì œ ì„¤ëª…
1ë¶€í„° Nê¹Œì§€ ë”í•˜ëŠ” ë¡œì§ê³¼, ë°°ì—´ì„ ì •ë ¬í•˜ëŠ”( Arrays.sort() ) ë¡œì§ì„ ê°ê° ì‹¤í–‰í•˜ê³ , ì´ ë‘ ê°€ì§€ ë¡œì§ ëª¨ë‘   
"ì‹¤í–‰ì— ê±¸ë¦° ì‹œê°„ì„ ì¸¡ì •"í•˜ê³  ì‹¶ë‹¤.

- "ì‹¤í–‰ ì‹œê°„ ì¸¡ì •" ë¡œì§ì€ ë³€í•˜ì§€ ì•ŠëŠ” ë¶€ë¶„
- "ì‹¤í–‰í•  ë¡œì§"ì€ ë°”ë€ŒëŠ” ë¶€ë¶„(1ë¶€í„° N í•© êµ¬í•˜ê¸° vs ë°°ì—´ ì •ë ¬)

**ì´ ë¬¸ì œëŠ” ëŒë‹¤ë¥¼ ì‚¬ìš©í•˜ì§€ ë§ê³  ìµëª… í´ë˜ìŠ¤ë¥¼ ì‚¬ìš©í•´ì„œ í’€ì–´ë¼**

#### ë¬¸ì œ
1. ì•ì„œ ì •ì˜í•œ `Procedure` (ì¶”ìƒ ë©”ì„œë“œ `run()` ) í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ë¥¼ ì‚¬ìš©í•´ë¼.

2. `measure(Procedure p)` ë©”ì„œë“œ ì•ˆì—ì„œ
  - ì‹¤í–‰ ì „ ì‹œê°„ ê¸°ë¡
  - `p.run()` ì‹¤í–‰
  - ì‹¤í–‰ í›„ ì‹œê°„ ê¸°ë¡
  - ê±¸ë¦° ì‹œê°„ ì¶œë ¥
3. `main()` ì—ì„œ ìµëª… í´ë˜ìŠ¤ ë‘ ê°€ì§€ë¥¼ ë§Œë“¤ì–´ ê°ê° ì‹¤í–‰ ì‹œê°„ì„ ì¸¡ì •í•´ë¼.
  - (1) 1ë¶€í„° Nê¹Œì§€ í•©ì„ êµ¬í•˜ëŠ” ë¡œì§ ( `measure` ë©”ì„œë“œ í˜¸ì¶œ)
  - (2) ë°°ì—´ì„ ì •ë ¬í•˜ëŠ” ë¡œì§ ( `measure` ë©”ì„œë“œ í˜¸ì¶œ)
  - `measure` ë©”ì„œë“œëŠ” ì´ **2ë²ˆ** í˜¸ì¶œëœë‹¤.

#### (1) 1ë¶€í„° Nê¹Œì§€ í•©ì„ êµ¬í•˜ëŠ” ë¡œì§ ( measure ë©”ì„œë“œ í˜¸ì¶œ)
```
int N = 100;
long sum = 0;
for (int i = 1; i <= N; i++) {
   sum += i;
}
```
#### (2) ë°°ì—´ì„ ì •ë ¬í•˜ëŠ” ë¡œì§ ( measure ë©”ì„œë“œ í˜¸ì¶œ)
```
int[] arr = { 4, 3, 2, 1 };
System.out.println("ì›ë³¸ ë°°ì—´: " + Arrays.toString(arr));
Arrays.sort(arr);
System.out.println("ë°°ì—´ ì •ë ¬: " + Arrays.toString(arr));
```

#### ì˜ˆì‹œ ì¶œë ¥
```
[1ë¶€í„° 100ê¹Œì§€ í•©] ê²°ê³¼: 5050
ì‹¤í–‰ ì‹œê°„: 4592542ns
ì›ë³¸ ë°°ì—´: [4, 3, 2, 1]
ë°°ì—´ ì •ë ¬: [1, 2, 3, 4]
ì‹¤í–‰ ì‹œê°„: 301083ns
```

#### ì •ë‹µ
ì˜ˆì‹œ í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤
```java
package lambda.ex1;

import lambda.Procedure;

import java.util.Arrays;

public class M3MeasureTime {

    // ê³µí†µ: ì‹¤í–‰ ì‹œê°„ ì¸¡ì • ë©”ì„œë“œ
    public static void measure(Procedure procedure) {
        long startNs = System.nanoTime();
        procedure.run();
        long endNs = System.nanoTime();
        System.out.println("ì‹¤í–‰ ì‹œê°„: " + (endNs - startNs) + "ns");
    }

    public static void main(String[] args) {
        // 1. ìµëª… í´ë˜ìŠ¤ë¡œ 1ë¶€í„° Nê¹Œì§€ í•©
        measure(new Procedure() {
            @Override
            public void run() {
                int N = 100;
                long sum = 0;
                for (int i = 0; i < N; i++) {
                    sum += i;

                }
                System.out.println("1[ë¶€í„° " + N + " ê¹Œì§€ í•©] ê²°ê³¼: "+ sum);
            }
        });

        // 2. ìµëª… í´ë˜ìŠ¤ë¡œ ë°°ì—´ ì •ë ¬
        measure(new Procedure() {
            @Override
            public void run() {
                int[] arr = {4, 3, 2, 1};
                System.out.println("ì›ë³¸ ë°°ì—´: " + Arrays.toString(arr));
                Arrays.sort(arr);
                System.out.println("ì›ë³¸ ë°°ì—´: " + Arrays.toString(arr));
            }
        });
    }
}
```

### ë¬¸ì œ 4. ëŒë‹¤ë¡œ ë³€ê²½ - ê°„ê²°í•˜ê²Œ ì½”ë“œ ì‘ì„±í•˜ê¸°
#### ë¬¸ì œ ì„¤ëª…
ì´ì „ ë¬¸ì œì—ì„œ ìµëª… í´ë˜ìŠ¤ë¡œ ì‘ì„±í•œ ë¶€ë¶„ì„ ëŒë‹¤ë¡œ ë³€ê²½í•´ë¼.
- measure() ë©”ì„œë“œì™€ Procedure ì¸í„°í˜ì´ìŠ¤ëŠ” ê·¸ëŒ€ë¡œ ë‘”ë‹¤.
- main() ì—ì„œ ìµëª… í´ë˜ìŠ¤ë¥¼ ì‚¬ìš©í•˜ì§€ ë§ê³ , ëŒë‹¤ë¥¼ ì´ìš©í•˜ì—¬ ë”ìš± ê°„ê²°í•˜ê²Œ ì½”ë“œë¥¼ ì‘ì„±í•´ë¼.

#### ì •ë‹µ
```java
package lambda.ex1;

import lambda.Procedure;

import java.util.Arrays;

public class M4MeasureTime {

    // ê³µí†µ: ì‹¤í–‰ ì‹œê°„ ì¸¡ì • ë©”ì„œë“œ
    public static void measure(Procedure procedure) {
        long startNs = System.nanoTime();
        procedure.run();
        long endNs = System.nanoTime();
        System.out.println("ì‹¤í–‰ ì‹œê°„: " + (endNs - startNs) + "ns");
    }

    public static void main(String[] args) {
        // 1. ìµëª… í´ë˜ìŠ¤ë¡œ 1ë¶€í„° Nê¹Œì§€ í•©
        measure(() -> {
            int N = 100;
            long sum = 0;
            for (int i = 0; i < N; i++) {
                sum += i;

            }
            System.out.println("1[ë¶€í„° " + N + " ê¹Œì§€ í•©] ê²°ê³¼: " + sum);
        });

        // 2. ìµëª… í´ë˜ìŠ¤ë¡œ ë°°ì—´ ì •ë ¬
        measure(() -> {
            int[] arr = {4, 3, 2, 1};
            System.out.println("ì›ë³¸ ë°°ì—´: " + Arrays.toString(arr));
            Arrays.sort(arr);
            System.out.println("ì›ë³¸ ë°°ì—´: " + Arrays.toString(arr));

        });
    }
}
```

### ë¬¸ì œ 5. ê³ ì°¨ í•¨ìˆ˜(High-Order Function) - í•¨ìˆ˜ë¥¼ ë°˜í™˜í•˜ê¸°
#### ë¬¸ì œ ì„¤ëª…
"í•¨ìˆ˜ë¥¼ ë°˜í™˜"í•˜ëŠ” ë°©ì‹ë„ ì—°ìŠµí•´ë³´ì. ë‘ ì •ìˆ˜ë¥¼ ë°›ì•„ì„œ ì—°ì‚°í•˜ëŠ” MyFunction ì¸í„°í˜ì´ìŠ¤ë¥¼ ì‚¬ìš©í•´ë³´ì.
```java
package lambda;

@FunctionalInterface
public interface MyFunction {
     int apply(int a, int b);
}
```
- static MyFunction getOperation(String operator) ë¼ëŠ” ì •ì  ë©”ì„œë“œë¥¼ ë§Œë“¤ì–´ë¼.
- ë§¤ê°œë³€ìˆ˜ì¸ operator ì— ë”°ë¼ ë‹¤ìŒê³¼ ê°™ì€ ë‚´ìš©ì„ ì „ë‹¬í•˜ê³  ë°˜í™˜í•´ë¼.
  - operator ê°€ "add"ë©´, (a, b) ë¥¼ ë°›ì•„ a + b ë¥¼ ë¦¬í„´í•˜ëŠ” ëŒë‹¤ë¥¼ ë°˜í™˜í•´ë¼.
  - "sub"ë©´, a - b ë¥¼ ë¦¬í„´í•˜ëŠ” ëŒë‹¤ë¥¼ ë°˜í™˜í•´ë¼.
  - ê·¸ ì™¸ì˜ ê²½ìš°ëŠ” í•­ìƒ 0ì„ ë¦¬í„´í•˜ëŠ” ëŒë‹¤ë¥¼ ë°˜í™˜í•´ë¼.
- main() ë©”ì„œë“œì—ì„œ getOperation("add") , getOperation("sub") , getOperation("xxx") ë¥¼
  ê°ê° í˜¸ì¶œí•´ì„œ ë°˜í™˜ëœ ëŒë‹¤ë¥¼ ì‹¤í–‰í•´ë¼.

#### ì˜ˆì‹œ ì¶œë ¥
```
add(1, 2) = 3
sub(1, 2) = -1
xxx(1, 2) = 0 // ê·¸ ì™¸ì˜ ê²½ìš°
```

#### ì •ë‹µ ì˜ˆì‹œ
```java
package lambda.ex1;

import lambda.MyFunction;

public class M5Return {

    public static void main(String[] args) {
        MyFunction add = getOperation("add");
        System.out.println("add(1, 2) = " + add.apply(1, 2));

        MyFunction sub = getOperation("sub");
        System.out.println("sub.apply(1, 2) = " + sub.apply(1, 2));

        MyFunction xxx = getOperation("xxx");
        System.out.println("xxx.apply(1,2) = " + xxx.apply(1, 2));
    }

    public static MyFunction getOperation(String operator) {
        switch (operator) {
            case "add":
                return (a, b) -> a + b;
            case "sub":
                return (a, b) -> a - b;
            default:
                return (a, b) -> 0;  // ì˜ëª»ëœ ì—°ì‚°ìì¼ ê²½ìš° 0 ë°˜í™˜
        }
    }
}
```

> ğŸ’¡[ì´ê²ƒë§Œì€ ê¸°ì–µí•´ë‘ì!]
> sub.apply(1, 2).soutv ëª…ë ¹ì–´ì‹œ
> System.out.println("sub.apply(1, 2) = " + sub.apply(1, 2)); ìë™ì™„ì„±


## ë¬¸ì œì™€ í’€ì´2
ì´ë²ˆ ë¬¸ì œë“¤ì€ ì´í›„ì— ì„¤ëª…í•  ìŠ¤íŠ¸ë¦¼ì€ ë¬¼ë¡ ì´ê³ , í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì˜ ê°œë…ì„ ì´í•´í•˜ê¸° ìœ„í•´ **ë°˜ë“œì‹œ ë°˜ë³µí•´ì„œ 
í’€ì–´ë³´ê³ , ë˜ ì´í•´í•´ì•¼ í•œë‹¤.**
ì´ë²ˆ ë¬¸ì œë“¤ì€ ê³ ì°¨ í•¨ìˆ˜(Higher-Order Function) ê°œë…ì„ ì§ì ‘ ì‹¤ìŠµí•´ë³¼ ìˆ˜ ìˆë„ë¡ êµ¬ì„±í–ˆë‹¤. ê° ë¬¸ì œì—ì„œ ìš”êµ¬í•˜ëŠ”
í•µì‹¬ ì‚¬í•­ì€ "í•¨ìˆ˜ë¥¼ ë§¤ê°œë³€ìˆ˜ë¡œ ë°›ê±°ë‚˜, í•¨ìˆ˜ë¥¼ ë°˜í™˜" í•˜ëŠ” êµ¬ì¡°ë¥¼ êµ¬í˜„í•˜ëŠ” ê²ƒì´ë‹¤. ëŒë‹¤ê°€ ì•„ì§ ìµìˆ™í•˜ì§€ ì•Šì„ ê²ƒì´
ë‹ˆ ë¨¼ì € ìµëª… í´ë˜ìŠ¤ë¡œ êµ¬í˜„í•´ë³´ê³  ê·¸ ë‹¤ìŒì— ëŒë‹¤ë¡œ êµ¬í˜„í•´ë³´ì.

ì°¸ê³ : ê³ ì°¨ í•¨ìˆ˜(Higher-Order Function)ë€?
- í•¨ìˆ˜ë¥¼ ì¸ìë¡œ ë°›ê±°ë‚˜, í•¨ìˆ˜ë¥¼ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜
- ìë°”ì—ì„œëŠ” **í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤**ì— ìµëª… í´ë˜ìŠ¤ë‚˜ ëŒë‹¤ë¥¼ ë‹´ì•„ì„œ ì£¼ê³ ë°›ìŒìœ¼ë¡œì¨ ê³ ì°¨ í•¨ìˆ˜ë¥¼ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤.


### ë¬¸ì œ 1. filter í•¨ìˆ˜ êµ¬í˜„í•˜ê¸°
#### ìš”êµ¬ì‚¬í•­
1. ì •ìˆ˜ ë¦¬ìŠ¤íŠ¸ê°€ ì£¼ì–´ì¡Œì„ ë•Œ, íŠ¹ì • ì¡°ê±´ì— ë§ëŠ” ìš”ì†Œë“¤ë§Œ ë½‘ì•„ë‚´ëŠ” filter í•¨ìˆ˜ë¥¼ ì§ì ‘ ë§Œë“¤ì–´ë³´ì.
2. filter(List<Integer> list, MyPredicate predicate) í˜•ì‹ì˜ ì •ì  ë©”ì„œë“œë¥¼ í•˜ë‚˜ ì‘ì„±í•œë‹¤.
   MyPredicate ëŠ” í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ì´ë©°, boolean test(int value); ê°™ì€ ë©”ì„œë“œë¥¼ ê°€ì§„ë‹¤.
3. main() ì—ì„œ ì˜ˆì‹œë¡œ ë‹¤ìŒê³¼ ê°™ì€ ìƒí™©ì„ ì‹¤ìŠµí•´ë³´ì.
   ë¦¬ìŠ¤íŠ¸: [-3, -2, -1, 1, 2, 3, 5]
   ì¡°ê±´ 1: ìŒìˆ˜(negative)ë§Œ ê³¨ë¼ë‚´ê¸°
   ì¡°ê±´ 2: ì§ìˆ˜(even)ë§Œ ê³¨ë¼ë‚´ê¸°

#### ì—ì‹œ ì‹¤í–‰
```
ì›ë³¸ ë¦¬ìŠ¤íŠ¸: [-3, -2, -1, 1, 2, 3, 5]
ìŒìˆ˜ë§Œ: [-3, -2, -1]
ì§ìˆ˜ë§Œ: [-2, 2]
```
#### í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ ì˜ˆì‹œ
```java
package lambda.ex2;

@FunctionalInterface
public interface MyPredicate {
    boolean test(int value);
}
```
#### ê¸°ë³¸ ì½”ë“œ ì˜ˆì‹œ
```java
package lambda.ex2;

import java.util.ArrayList;
import java.util.List;

public class FilterExample {
    // ê³ ì°¨ í•¨ìˆ˜, í•¨ìˆ˜ë¥¼ ì¸ìë¡œ ë°›ì•„ì„œ ì¡°ê±´ì— ë§ëŠ” ìš”ì†Œë§Œ ë½‘ì•„ë‚´ëŠ” filter
    public static List<Integer> filter(List<Integer> list, MyPredicate predicate) {
        List<Integer> result = new ArrayList<>();
        for (int val : list) {
            if (predicate.test(val)) {
                result.add(val);
            }
        }
        return result;
    }

    public static void main(String[] args) {
        List<Integer> numbers = List.of(-3, -2, -1, 1, 2, 3, 5);
        System.out.println("ì›ë³¸ ë¦¬ìŠ¤íŠ¸: " + numbers);

        // 1. ìŒìˆ˜(negative)ë§Œ ë½‘ì•„ë‚´ê¸°
        // ì½”ë“œ ì‘ì„±

        // 2. ì§ìˆ˜(even)ë§Œ ë½‘ì•„ë‚´ê¸°
        // ì½”ë“œ ì‘ì„±
    }
}
```

#### ìµëª… í´ë˜ìŠ¤
```java
package lambda.ex2;

import java.util.ArrayList;
import java.util.List;

public class FilterExampleEx1 {
    // ê³ ì°¨ í•¨ìˆ˜, í•¨ìˆ˜ë¥¼ ì¸ìë¡œ ë°›ì•„ì„œ ì¡°ê±´ì— ë§ëŠ” ìš”ì†Œë§Œ ë½‘ì•„ë‚´ëŠ” filter
    public static List<Integer> filter(List<Integer> list, MyPredicate predicate) {
        List<Integer> result = new ArrayList<>();
        for (int val : list) {
            if (predicate.test(val)) {
                result.add(val);
            }
        }
        return result;
    }

    public static void main(String[] args) {
        List<Integer> numbers = List.of(-3, -2, -1, 1, 2, 3, 5);
        System.out.println("ì›ë³¸ ë¦¬ìŠ¤íŠ¸: " + numbers);

        // 1. ìŒìˆ˜(negative)ë§Œ ë½‘ì•„ë‚´ê¸°
        List<Integer> negatives = filter(numbers, new MyPredicate() {
            @Override
            public boolean test(int value) {
                return value < 0;
            }
        });
        System.out.println("ìŒìˆ˜ë§Œ: " + negatives);

        // 2. ì§ìˆ˜(even)ë§Œ ë½‘ì•„ë‚´ê¸°
        List<Integer> evens = filter(numbers, new MyPredicate() {
            @Override
            public boolean test(int value) {
                return value % 2 == 0;
            }
        });
        System.out.println("ì§ìˆ˜ë§Œ: " + evens);
    }
}

```
#### ëŒë‹¤ í‘œí˜„ì‹
```java
package lambda.ex2;

import java.util.ArrayList;
import java.util.List;

public class FilterExampleEx2 {
    // ê³ ì°¨ í•¨ìˆ˜, í•¨ìˆ˜ë¥¼ ì¸ìë¡œ ë°›ì•„ì„œ ì¡°ê±´ì— ë§ëŠ” ìš”ì†Œë§Œ ë½‘ì•„ë‚´ëŠ” filter
    public static List<Integer> filter(List<Integer> list, MyPredicate predicate) {
        List<Integer> result = new ArrayList<>();
        for (int val : list) {
            if (predicate.test(val)) {
                result.add(val);
            }
        }
        return result;
    }

    public static void main(String[] args) {
        List<Integer> numbers = List.of(-3, -2, -1, 1, 2, 3, 5);
        System.out.println("ì›ë³¸ ë¦¬ìŠ¤íŠ¸: " + numbers);

        // 1. ìŒìˆ˜(negative)ë§Œ ë½‘ì•„ë‚´ê¸°
        // ì½”ë“œ ì‘ì„±
        List<Integer> negative = filter(numbers, value -> value < 0);
        System.out.println("ìŒìˆ˜ë§Œ = " + negative);

        // 2. ì§ìˆ˜(even)ë§Œ ë½‘ì•„ë‚´ê¸°
        // ì½”ë“œ ì‘ì„±
        List<Integer> even = filter(numbers, value -> value % 2 == 0);
        System.out.println("ì§ìˆ˜ë§Œ = " + even);
    }
}
```
- filter() ë©”ì„œë“œê°€ MyPredicate ë¼ëŠ” "ì¡°ê±´ í•¨ìˆ˜"ë¥¼ ë°›ì•„ì„œ, test() ê°€ true ì¼ ë•Œë§Œ ê²°ê³¼ ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€í•œë‹¤.
- ì´ì²˜ëŸ¼ **í•¨ìˆ˜ë¥¼ ì¸ìë¡œ ë°›ì•„ì„œ ë¡œì§ì„ ê²°ì •**í•˜ëŠ” í˜•íƒœê°€ ì „í˜•ì ì¸ ê³ ì°¨ í•¨ìˆ˜ì´ë‹¤.

### ë¬¸ì œ 2. map í•¨ìˆ˜ êµ¬í˜„í•˜ê¸°

#### ìš”êµ¬ ì‚¬í•­
- 1. ë¬¸ìì—´ ë¦¬ìŠ¤íŠ¸ë¥¼ ì…ë ¥ë°›ì•„, ê° ë¬¸ìì—´ì„ ì–´ë–¤ ë°©ì‹ìœ¼ë¡œ ë³€í™˜(map, mapping)í• ì§€ ê²°ì •í•˜ëŠ” í•¨ìˆ˜( map )ë¥¼ ë§Œë“¤ì–´ë³´ì
- 2. map(List<String> list, StringFunction func) í˜•íƒœë¡œ êµ¬í˜„í•œë‹¤.  
  - StringFunction ì€ í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ì´ë©°, String apply(String s); ê°™ì€ ë©”ì„œë“œë¥¼ ê°€ì§„ë‹¤.
- 3. main() ì—ì„œ ë‹¤ìŒ ë³€í™˜ ë¡œì§ë“¤ì„ í…ŒìŠ¤íŠ¸í•´ë³´ì.
  - ë³€í™˜ 1: ëª¨ë“  ë¬¸ìì—´ì„ ëŒ€ë¬¸ìë¡œ ë³€ê²½
  - ë³€í™˜ 2: ë¬¸ìì—´ ì• ë’¤ì— *** ë¥¼ ë¶™ì—¬ì„œ ë°˜í™˜(ì˜ˆ: "hello" â†’ "***hello***" )
#### ì˜ˆì‹œ ì‹¤í–‰
```
ì›ë³¸ ë¦¬ìŠ¤íŠ¸: [hello, java, lambda]
ëŒ€ë¬¸ì ë³€í™˜ ê²°ê³¼: [HELLO, JAVA, LAMBDA]
íŠ¹ìˆ˜ë¬¸ì ë°ì½” ê²°ê³¼: [***hello***, ***java***, ***lambda***]
```

#### í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤
```java
@FunctionalInterface
public interface StringFunction {
    String apply(String s);
}
```

#### ìµëª… í´ë˜ìŠ¤
```java
import java.util.ArrayList;
import java.util.List;

public class MapExample {

    // ê³ ì°¨ í•¨ìˆ˜, í•¨ìˆ˜ë¥¼ ì¸ìë¡œ ë°›ì•„, ë¦¬ìŠ¤íŠ¸ì˜ ê° ìš”ì†Œë¥¼ ë³€í™˜
    public static List<String> map(List<String> list, StringFunction stringFunction) {
        List<String> result = new ArrayList<>();
        for (String s : list) {
            String str = stringFunction.apply(s);
            result.add(str);
        }

        return result;
    }

    public static void main(String[] args) {
        List<String> words = List.of("hello", "java", "lambda");
        System.out.println("ì›ë³¸ ë¦¬ìŠ¤íŠ¸: " + words);

        // 1. ëª¨ë“  ë¬¸ìì—´ì„ ëŒ€ë¬¸ìë¡œ ë³€ê²½
        List<String> upperList = map(words, new StringFunction() {
            @Override
            public String apply(String s) {
                return s.toUpperCase();
            }
        });

        System.out.println("ëŒ€ë¬¸ì ë³€í™˜ ê²°ê³¼: " + upperList);

        // 2. ì•ë’¤ì— *** ë¶™ì´ê¸° (ëŒë‹¤ë¡œ ì‘ì„±)
        List<String> decoratedList = map(words, new StringFunction() {
            @Override
            public String apply(String s) {
                return "***" + s + "***";
            }
        });

        System.out.println("íŠ¹ìˆ˜ë¬¸ì ë°ì½” ê²°ê³¼: " + decoratedList);
    }
}
```
#### ëŒë‹¤ í‘œí˜„ì‹
```java
import java.util.ArrayList;
import java.util.List;

public class MapExample {

    // ê³ ì°¨ í•¨ìˆ˜, í•¨ìˆ˜ë¥¼ ì¸ìë¡œ ë°›ì•„, ë¦¬ìŠ¤íŠ¸ì˜ ê° ìš”ì†Œë¥¼ ë³€í™˜
    public static List<String> map(List<String> list, StringFunction stringFunction) {
        List<String> result = new ArrayList<>();
        for (String s : list) {
            String str = stringFunction.apply(s);
            result.add(str);
        }

        return result;
    }

    public static void main(String[] args) {
        List<String> words = List.of("hello", "java", "lambda");
        System.out.println("ì›ë³¸ ë¦¬ìŠ¤íŠ¸: " + words);

        // 1. ëª¨ë“  ë¬¸ìì—´ì„ ëŒ€ë¬¸ìë¡œ ë³€ê²½
        List<String> upperList = map(words, s -> s.toUpperCase());

        System.out.println("ëŒ€ë¬¸ì ë³€í™˜ ê²°ê³¼: " + upperList);

        // 2. ì•ë’¤ì— *** ë¶™ì´ê¸° (ëŒë‹¤ë¡œ ì‘ì„±)
        List<String> decoratedList = map(words, s -> "***" + s + "***");

        System.out.println("íŠ¹ìˆ˜ë¬¸ì ë°ì½” ê²°ê³¼: " + decoratedList);
    }
}
```

## ë¬¸ì œì™€ í’€ì´3

### ë¬¸ì œ 3. reduce(ë˜ëŠ” fold) í•¨ìˆ˜ êµ¬í˜„í•˜ê¸°
#### ìš”êµ¬ ì‚¬í•­
- 1. ì •ìˆ˜ ë¦¬ìŠ¤íŠ¸ë¥¼ ë°›ì•„ì„œ, ëª¨ë“  ê°’ì„ í•˜ë‚˜ë¡œ **ëˆ„ì (reduce)**í•˜ëŠ” í•¨ìˆ˜ë¥¼ ë§Œë“¤ì–´ë³´ì.
- 2. reduce(List<Integer> list, int initial, MyReducer reducer) í˜•íƒœë¡œ êµ¬í˜„í•œë‹¤.
  - MyReducer ëŠ” int reduce(int a, int b); ê°™ì€ ë©”ì„œë“œë¥¼ ì œê³µí•˜ëŠ” í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ì´ë‹¤.
  - initial ì€ ëˆ„ì  ê³„ì‚°ì˜ ì´ˆê¹ƒê°’(ì˜ˆ: 0 ë˜ëŠ” 1 ë“±)ì„ ì§€ì •í•œë‹¤.
- 3. main() ì—ì„œ ë‹¤ìŒ ì—°ì‚°ì„ í…ŒìŠ¤íŠ¸ í•´ë³´ì.
  - ì—°ì‚° 1: ë¦¬ìŠ¤íŠ¸ [1, 2, 3, 4] ë¥¼ ëª¨ë‘ ë”í•˜ê¸°(+)
  - ì—°ì‚° 2: ë¦¬ìŠ¤íŠ¸ [1, 2, 3, 4] ë¥¼ ëª¨ë‘ ê³±í•˜ê¸°(*)

#### ì˜ˆì‹œ ì‹¤í–‰
```
ë¦¬ìŠ¤íŠ¸: [1, 2, 3, 4]
í•©(ëˆ„ì  +): 10
ê³±(ëˆ„ì  *): 24
```

#### í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤
```
@FunctionalInterface
public interface MyReducer {
    int reduce(int a, int b);
}
```

#### ìµëª… í´ë˜ìŠ¤
```java
import java.util.List;

public class ReduceExample {
    // í•¨ìˆ˜ë¥¼ ì¸ìë¡œ ë°›ì•„, ë¦¬ìŠ¤íŠ¸ ìš”ì†Œë¥¼ í•˜ë‚˜ë¡œ ì¶•ì•½(reduce)í•˜ëŠ” ê³ ì°¨ í•¨ìˆ˜
    public static int reduce(List<Integer> list, int initial, MyReducer reducer) {
        int result = initial;
        for (int val : list) {
            result = reducer.reduce(result, val);
        }

        // ì½”ë“œ ì‘ì„±
        return result; // ì ì ˆí•œ ê°’ìœ¼ë¡œ ë³€ê²½
    }

    public static void main(String[] args) {
        List<Integer> numbers = List.of(1, 2, 3, 4);
        System.out.println("ë¦¬ìŠ¤íŠ¸: " + numbers);

        // 1. í•© êµ¬í•˜ê¸° (ì´ˆê¹ƒê°’ 0, ë§ì…ˆ ë¡œì§)
        int sum = reduce(numbers, 0, new MyReducer() {
            @Override
            public int reduce(int a, int b) {
                return a + b;
            }
        });

        System.out.println("í•©(ëˆ„ì  +): " + sum);

        // 2. ê³± êµ¬í•˜ê¸° (ì´ˆê¹ƒê°’ 1, ê³±ì…ˆ ë¡œì§)
        int product = reduce(numbers, 1, new MyReducer() {
            @Override
            public int reduce(int a, int b) {
                return a * b;
            }
        });

        System.out.println("ê³±(ëˆ„ì  *): " + product);
    }
}
```
#### ëŒë‹¤ í‘œí˜„ì‹
```java
import java.util.List;

public class ReduceExample {
    // í•¨ìˆ˜ë¥¼ ì¸ìë¡œ ë°›ì•„, ë¦¬ìŠ¤íŠ¸ ìš”ì†Œë¥¼ í•˜ë‚˜ë¡œ ì¶•ì•½(reduce)í•˜ëŠ” ê³ ì°¨ í•¨ìˆ˜
    public static int reduce(List<Integer> list, int initial, MyReducer reducer) {
        int result = initial;
        for (int val : list) {
            result = reducer.reduce(result, val);
        }

        // ì½”ë“œ ì‘ì„±
        return result; // ì ì ˆí•œ ê°’ìœ¼ë¡œ ë³€ê²½
    }

    public static void main(String[] args) {
        List<Integer> numbers = List.of(1, 2, 3, 4);
        System.out.println("ë¦¬ìŠ¤íŠ¸: " + numbers);

        // 1. í•© êµ¬í•˜ê¸° (ì´ˆê¹ƒê°’ 0, ë§ì…ˆ ë¡œì§)
        int sum = reduce(numbers, 0, (a, b) -> a + b);

        System.out.println("í•©(ëˆ„ì  +): " + sum);

        // 2. ê³± êµ¬í•˜ê¸° (ì´ˆê¹ƒê°’ 1, ê³±ì…ˆ ë¡œì§)
        int product = reduce(numbers, 1, (a, b) -> a * b);

        System.out.println("ê³±(ëˆ„ì  *): " + product);
    }
}
```

#### ìš©ì–´ - reduce, fold
ì´ë ‡ê²Œ ì—¬ëŸ¬ ê°’ì„ ê³„ì‚°í•´ì„œ í•˜ë‚˜ì˜ ìµœì¢… ê°’ì„ ë°˜í™˜í•˜ëŠ” ê²½ìš° reduce(ì¶•ì•½í•˜ë‹¤) , fold(ì ‘ëŠ”ë‹¤) ê°™ì€ ë‹¨ì–´ë¥¼ ì‚¬ìš©í•œë‹¤.
- reduce : 1, 2, 3, 4ë¼ëŠ” ìˆ«ìë¥¼ í•˜ë‚˜ì”© ê³„ì‚°í•˜ë©´ì„œ ì¶•ì•½í•˜ê¸° ë•Œë¬¸ì— ì¶•ì•½í•˜ë‹¤ëŠ” ì˜ë¯¸ì˜ reduce ë¥¼ ì‚¬ìš©í•œë‹¤.
- fold : ë§ˆì¹˜ ì¢…ì´ë¥¼ ì—¬ëŸ¬ ë²ˆ ì ‘ì–´ì„œ í•˜ë‚˜ì˜ ì‘ì€ ë­‰ì¹˜ë¡œ ë§Œë“œëŠ” ê²ƒì²˜ëŸ¼, ì´ˆê¹ƒê°’ê³¼ ì—°ì‚°ì„ í†µí•´ ë¦¬ìŠ¤íŠ¸ì˜ ìš”ì†Œë¥¼  
  í•˜ë‚˜ì”© ì ‘ì–´ì„œ ìµœì¢…ì ìœ¼ë¡œ í•˜ë‚˜ì˜ ê°’ìœ¼ë¡œ ì¶•ì•½í•œë‹¤ëŠ” ì˜ë¯¸ì´ë‹¤.

### ë¬¸ì œ 4. í•¨ìˆ˜ë¥¼ ë°˜í™˜í•˜ëŠ” buildGreeter ë§Œë“¤ê¸°
#### ìš”êµ¬ ì‚¬í•­
- 1. ë¬¸ìì—´ì„ ì…ë ¥ë°›ì•„, **ìƒˆë¡œìš´ í•¨ìˆ˜ë¥¼ ë°˜í™˜**í•´ì£¼ëŠ” buildGreeter(String greeting)ë¼ëŠ” ë©”ì„œë“œë¥¼ ì‘ì„±í•˜ì.
  - ì˜ˆ) buildGreeter("Hello") "Hello" ë¥¼ ì‚¬ìš©í•˜ëŠ” ìƒˆë¡œìš´ í•¨ìˆ˜ ë°˜í™˜
  - ìƒˆë¡œìš´ í•¨ìˆ˜ëŠ” ì…ë ¥ë°›ì€ ë¬¸ìì—´ì— ëŒ€í•´ "Hello"(greeting) + ", " + (ì…ë ¥ë°›ì€ ë¬¸ìì—´) í˜•íƒœë¡œ ê²°ê³¼ë¥¼ ë°˜í™˜
- 2. í•¨ìˆ˜ë¥¼ ë°˜í™˜ë°›ì€ ë’¤ì—, ì‹¤ì œë¡œ ê·¸ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•´ ê²°ê³¼ë¥¼ í™•ì¸í•´ë³´ì.

#### í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ - ì´ì „ì— ì‘ì„±í•œ ì½”ë“œë¥¼ ì‚¬ìš©í•˜ì.
```java
@FunctionalInterface
public interface StringFunction {
    String apply(String s);
}
```

#### ë¬¸ì œ ì˜ˆì‹œ
```java
public class BuildGreeterExample {
    // ê³ ì°¨ í•¨ìˆ˜, greeting ë¬¸ìì—´ì„ ë°›ì•„, "ìƒˆë¡œìš´ í•¨ìˆ˜ë¥¼" ë°˜í™˜
    public static StringFunction buildGreeter(String greeting) {
        // ì½”ë“œ ì‘ì„±
        return null; // ì ì ˆí•œ ëŒë‹¤ ë°˜í™˜
    }

    public static void main(String[] args) {
        // ì½”ë“œ ì‘ì„±
    }
}
```

#### ìµëª… í´ë˜ìŠ¤
```java
package lambda.ex2;

public class BuildGreeterExample {
    // ê³ ì°¨ í•¨ìˆ˜, greeting ë¬¸ìì—´ì„ ë°›ì•„, "ìƒˆë¡œìš´ í•¨ìˆ˜ë¥¼" ë°˜í™˜
    public static StringFunction buildGreeter(String greeting) {
        // ì½”ë“œ ì‘ì„±
        return new StringFunction() {
            @Override
            public String apply(String name) {
                return greeting + ", " + name;
            }
        };
    }

    public static void main(String[] args) {
        // ì½”ë“œ ì‘ì„±
        StringFunction helloGreeter = buildGreeter("Hello");
        StringFunction hiGreeter = buildGreeter("Hi");

        // í•¨ìˆ˜ê°€ ë°˜í™˜ë˜ì—ˆìœ¼ë¯€ë¡œ, apply()ë¥¼ í˜¸ì¶œí•´ ì‹¤ì œë¡œ ì‚¬ìš©
        System.out.println(helloGreeter.apply("Java")); // Hello, Java
        System.out.println(hiGreeter.apply("Lambda")); // Hi, Lambda
    }
}
```

#### ëŒë‹¤ í‘œí˜„ì‹
```java
package lambda.ex2;

public class BuildGreeterExample {
    // ê³ ì°¨ í•¨ìˆ˜, greeting ë¬¸ìì—´ì„ ë°›ì•„, "ìƒˆë¡œìš´ í•¨ìˆ˜ë¥¼" ë°˜í™˜
    public static StringFunction buildGreeter(String greeting) {
        // ëŒë‹¤ë¡œ í•¨ìˆ˜ ë°˜í™˜
        return name -> greeting + ", " + name;
    }

    public static void main(String[] args) {
        // ì½”ë“œ ì‘ì„±
        StringFunction helloGreeter = buildGreeter("Hello");
        StringFunction hiGreeter = buildGreeter("Hi");

        // í•¨ìˆ˜ê°€ ë°˜í™˜ë˜ì—ˆìœ¼ë¯€ë¡œ, apply()ë¥¼ í˜¸ì¶œí•´ ì‹¤ì œë¡œ ì‚¬ìš©
        System.out.println(helloGreeter.apply("Java")); // Hello, Java
        System.out.println(hiGreeter.apply("Lambda")); // Hi, Lambda
    }
}
```

### ë¬¸ì œ 5. í•¨ìˆ˜ í•©ì„±í•˜ê¸° ( compose )
ì´ë²ˆì—ëŠ” ëŒë‹¤ë¥¼ ì „ë‹¬í•˜ê³  ë˜ ëŒë‹¤ë¥¼ ë°˜í™˜ê¹Œì§€ í•˜ëŠ” ë³µì¡í•œ ë¬¸ì œë¥¼ í’€ì–´ë³´ì.
#### ìš”êµ¬ ì‚¬í•­
- 1. ë¬¸ìì—´ì„ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜ ë‘ ê°œ(MyTransFormer íƒ€ì…)ì„ ë°›ì•„ì„œ, **f1ì„ ë¨¼ì € ì ìš©**í•˜ê³ , ê·¸ ê²°ê³¼ì— **f2ë¥¼ ì ìš©**í•˜ëŠ”  
     ìƒˆë¡œìš´ í•¨ìˆ˜ë¥¼ ë°˜í™˜í•˜ëŠ” compose ë©”ì„œë“œë¥¼ ë§Œë“¤ì–´ë³´ì. ì˜ˆ) f2(f1(x))
- 2. ì˜ˆì‹œ ìƒí™©:
  - f1: ëŒ€ë¬¸ìë¡œ ë°”ê¿ˆ
  - f2: ë¬¸ì ì• ë’¤ì— "**"ì„ ë¶™ì„
  - í•©ì„± í•¨ìˆ˜(compose())ë¥¼ "hello"ì— ì ìš©í•˜ë©´ -> "**HELLO**"
  
#### í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤
```java
package lambda.ex2;

@FunctionalInterface
public interface MyTransformer {
    String transform(String s);
}
```

```java
package lambda.ex2;

public class ComposeExample {
    // ê³ ì°¨ í•¨ìˆ˜, f1, f2ë¼ëŠ” ë‘ í•¨ìˆ˜ë¥¼ ì¸ìë¡œ ë°›ì•„, "f1ì„ ë¨¼ì €, f2ë¥¼ ë‚˜ì¤‘"ì— ì ìš©í•˜ëŠ” ìƒˆ í•¨ìˆ˜ ë°˜í™˜
    public static MyTransformer compose(MyTransformer f1, MyTransformer f2) {
        // ì½”ë“œ ì‘ì„±
        return null; // ì ì ˆí•œ ëŒë‹¤ ë°˜í™˜
    }

    public static void main(String[] args) {
        // f1: ëŒ€ë¬¸ìë¡œ ë³€í™˜
        MyTransformer toUpper = s -> s.toUpperCase();

        // f2: ì• ë’¤ì— "**" ë¶™ì´ê¸°
        MyTransformer addDeco = s -> "**" + s + "**";

        // í•©ì„±: f1 â†’ f2 ìˆœì„œë¡œ ì ìš©í•˜ëŠ” í•¨ìˆ˜
        MyTransformer composeFunc = compose(toUpper, addDeco);

        // ì‹¤í–‰
        String result = composeFunc.transform("hello");
        System.out.println(result); // "**HELLO**"
    }
}
```
#### ì‹¤í–‰ ê²°ê³¼
```
**HELLO**
```
ì´ë²ˆì— ë§Œë‚˜ë³¼ ê³ ì°¨ í•¨ìˆ˜ëŠ” í•¨ìˆ˜ë¥¼ ì¸ìë¡œ ë°›ì•„ì„œ, ë˜ ë‹¤ë¥¸ í•¨ìˆ˜ë¥¼ ë°˜í™˜í•˜ëŠ” í˜•íƒœì´ë‹¤.

#### íŒíŠ¸
ë¬¸ì œë¥¼ í’€ê¸° ì‰½ì§€ ì•Šì„ ê²ƒì´ë‹¤. compose() ë©”ì„œë“œ ì•ˆì—ì„œ MyTransformer ë¥¼ ë°˜í™˜í•´ì•¼ í•œë‹¤. ì²˜ìŒì—ëŠ” ìµëª… í´ë˜ìŠ¤ë¥¼ ì‚¬ìš©í•´ë³´ì

#### ìµëª… í´ë˜ìŠ¤
```java
package lambda.ex2;

public class ComposeExample {
    // ê³ ì°¨ í•¨ìˆ˜, f1, f2ë¼ëŠ” ë‘ í•¨ìˆ˜ë¥¼ ì¸ìë¡œ ë°›ì•„, "f1ì„ ë¨¼ì €, f2ë¥¼ ë‚˜ì¤‘"ì— ì ìš©í•˜ëŠ” ìƒˆ í•¨ìˆ˜ ë°˜í™˜
    public static MyTransformer compose(MyTransformer f1, MyTransformer f2) {
        // ì½”ë“œ ì‘ì„±
        return new MyTransformer() {
            @Override
            public String transform(String s) {
                String intermediate = f1.transform(s);
                return f2.transform(intermediate);
            }
        };
    }

    public static void main(String[] args) {
        // f1: ëŒ€ë¬¸ìë¡œ ë³€í™˜
        MyTransformer toUpper = s -> s.toUpperCase();

        // f2: ì• ë’¤ì— "**" ë¶™ì´ê¸°
        MyTransformer addDeco = s -> "**" + s + "**";

        // í•©ì„±: f1 â†’ f2 ìˆœì„œë¡œ ì ìš©í•˜ëŠ” í•¨ìˆ˜
        MyTransformer composeFunc = compose(toUpper, addDeco);

        // ì‹¤í–‰
        String result = composeFunc.transform("hello");
        System.out.println(result); // "**HELLO**"
    }
}
```
#### ëŒë‹¤ í‘œí˜„ì‹
```java
package lambda.ex2;

public class ComposeExample {
    // ê³ ì°¨ í•¨ìˆ˜, f1, f2ë¼ëŠ” ë‘ í•¨ìˆ˜ë¥¼ ì¸ìë¡œ ë°›ì•„, "f1ì„ ë¨¼ì €, f2ë¥¼ ë‚˜ì¤‘"ì— ì ìš©í•˜ëŠ” ìƒˆ í•¨ìˆ˜ ë°˜í™˜
    public static MyTransformer compose(MyTransformer f1, MyTransformer f2) {
        // ì½”ë“œ ì‘ì„±
        return s -> {
            String intermediate = f1.transform(s);
            return f2.transform(intermediate);
        };
    }

    public static void main(String[] args) {
        // f1: ëŒ€ë¬¸ìë¡œ ë³€í™˜
        MyTransformer toUpper = s -> s.toUpperCase();

        // f2: ì• ë’¤ì— "**" ë¶™ì´ê¸°
        MyTransformer addDeco = s -> "**" + s + "**";

        // í•©ì„±: f1 â†’ f2 ìˆœì„œë¡œ ì ìš©í•˜ëŠ” í•¨ìˆ˜
        MyTransformer composeFunc = compose(toUpper, addDeco);

        // ì‹¤í–‰
        String result = composeFunc.transform("hello");
        System.out.println(result); // "**HELLO**"
    }
}
```
#### ì •ë¦¬
ì§€ê¸ˆê¹Œì§€ ì§„í–‰í•œ **5ê°€ì§€ ë¬¸ì œ**ëŠ” ìë°”ì—ì„œ ê³ ì°¨ í•¨ìˆ˜ë¥¼ êµ¬í˜„í•  ë•Œ ìì£¼ ë“±ì¥í•˜ëŠ” íŒ¨í„´ìœ¼ë¡œ êµ¬ì„±ë˜ì–´ ìˆë‹¤.
1. **filter**: ì¡°ê±´(í•¨ìˆ˜)ì„ ì¸ìë¡œ ë°›ì•„, ë¦¬ìŠ¤íŠ¸ì—ì„œ í•„ìš”í•œ ìš”ì†Œë§Œ ì¶”ë ¤ë‚´ê¸°
2. **map**: ë³€í™˜ ë¡œì§(í•¨ìˆ˜)ì„ ì¸ìë¡œ ë°›ì•„, ë¦¬ìŠ¤íŠ¸ì˜ ê° ìš”ì†Œë¥¼ ë‹¤ë¥¸ í˜•íƒœë¡œ ë°”ê¾¸ê¸°
3. **reduce**: ëˆ„ì  ë¡œì§(í•¨ìˆ˜)ì„ ì¸ìë¡œ ë°›ì•„, ë¦¬ìŠ¤íŠ¸ì˜ ëª¨ë“  ìš”ì†Œë¥¼ í•˜ë‚˜ì˜ ê°’ìœ¼ë¡œ ì¶•ì•½í•˜ê¸°
4. **í•¨ìˆ˜ë¥¼ ë°˜í™˜**: ì–´ë–¤ ë¬¸ìì—´/ì •ìˆ˜ ë“±ì„ ë°›ì•„ì„œ, ê·¸ì— ë§ëŠ” ìƒˆë¡œìš´ "í•¨ìˆ˜"ë¥¼ ë§Œë“¤ì–´ ëŒë ¤ì£¼ê¸°
5. **í•¨ìˆ˜ í•©ì„±**: ë‘ í•¨ìˆ˜ë¥¼ ì´ì–´ ë¶™ì—¬, í•œ ë²ˆì— ë³€í™˜ ë¡œì§ì„ ì ìš©í•  ìˆ˜ ìˆëŠ” ìƒˆ í•¨ìˆ˜ë¥¼ ë§Œë“¤ê¸°

ì´ ë¬¸ì œë“¤ì„ í†µí•´ ë‹¤ìŒ ë‚´ìš©ë“¤ì„ ê¹Šì´ìˆê²Œ ì´í•´í•  ìˆ˜ ìˆë‹¤.
- ìë°”ì—ì„œ í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ë¥¼ ì´ìš©í•´ í•¨ìˆ˜ë¥¼ í‘œí˜„í•˜ê³ , ì´ë¥¼ ë§¤ê°œë³€ìˆ˜/ë°˜í™˜ê°’ìœ¼ë¡œ í™œìš©í•˜ëŠ” ë°©ì‹
- **ìµëª… í´ë˜ìŠ¤** ë˜ëŠ” **ëŒë‹¤**ë¥¼ í™œìš©í•´, ê°„ê²°í•˜ê²Œ ê³ ì°¨ í•¨ìˆ˜ë¥¼ êµ¬í˜„í•˜ëŠ” ë°©ë²•
- filter-map-reduceë“±, ì»¬ë ‰ì…˜/ìŠ¤íŠ¸ë¦¼ ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„œë„ í”íˆ ë³¼ ìˆ˜ ìˆëŠ” ê³ ì°¨ í•¨ìˆ˜ íŒ¨í„´(ì´ ë¶€ë¶„ì€ ë’¤ì—ì„œ ë‹¤ë£¬ë‹¤.)

ì²˜ìŒì—ëŠ” ëŒë‹¤ ë¬¸ë²•ì´ ìµìˆ™í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì—, ì²˜ìŒë¶€í„° ë°”ë¡œ ë¬¸ì œë¥¼ í’€ê¸°ëŠ” ì‰½ì§€ ì•Šì„ ê²ƒì´ë‹¤.  
ì§€ê¸ˆê¹Œì§€ ì„¤ëª…í•œ ë¬¸ì œë“¤ì€ ë°˜ë“œì‹œ ì´í•´ê°€ ë  ë•Œ ê¹Œì§€ ë°˜ë³µí•´ì„œ í’€ì–´ë´ì•¼ í•œë‹¤! ê·¸ë¦¬ê³  ë°˜ë³µì„ í†µí•´ ì–´ëŠì •ë„ ëŒë‹¤ì— ìµìˆ™í•´ì§€ëŠ” ì‹œê°„ì„ ë§Œë“¤ì–´ì•¼ í•œë‹¤.

### ì •ë¦¬
- ëŒë‹¤ë€?
  - ìë°” 8ì—ì„œ ë„ì…ëœ **ìµëª… í•¨ìˆ˜**ë¡œ, ì´ë¦„ ì—†ì´ ê°„ê²°í•˜ê²Œ í•¨ìˆ˜ë¥¼ í‘œí˜„í•œë‹¤.
  - ì˜ˆ: (x) -> x + 1
  - ìµëª… í´ë˜ìŠ¤ë³´ë‹¤ ë³´ì¼ëŸ¬í”Œë ˆì´íŠ¸ ì½”ë“œë¥¼ ì¤„ì—¬ ìƒì‚°ì„±ê³¼ ê°€ë…ì„±ì„ ë†’ì´ëŠ” **ë¬¸ë²• ì„¤íƒ•** ì—­í• 
- í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤
  - ëŒë‹¤ë¥¼ ì‚¬ìš© í•  ìˆ˜ ìˆëŠ” ê¸°ë°˜ìœ¼ë¡œ, **ë‹¨ì¼ ì¶”ìƒ ë©”ì„œë“œ(SAM)** ë§Œ í¬í•¨í•˜ëŠ” ì¸í„°í˜ì´ìŠ¤
  - ì˜ˆ: @FunctionalInterface ë¡œ ë³´ì¥í•˜ë©°, í•˜ë‚˜ì˜ ë©”ì„œë“œë§Œ ì •ì˜.
  - ì—¬ëŸ¬ ë©”ì„œë“œê°€ ìˆìœ¼ë©´ ëŒë‹¤ í• ë‹¹ ë¶ˆê°€(ëª¨í˜¸ì„± ë°©ì§€)
- ëŒë‹¤ ë¬¸ë²•
  - **ë³€ìˆ˜ ëŒ€ì…**: MyFunction f = (a, b) -> a + b; ì²˜ëŸ¼ ëŒë‹¤ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë³€ìˆ˜ì— ì €ì¥.
  - **ë©”ì„œë“œ ì „ë‹¬**: calculate((a, b) -> a + b) ë¡œ í•¨ìˆ˜ì²˜ëŸ¼ ì „ë‹¬ ê°€ëŠ¥.
  - **ë°˜í™˜**: return (a, b) -> a + b; ë¡œ ë©”ì„œë“œì—ì„œ ëŒë‹¤ë¥¼ ë°˜í™˜.
- ê³ ì°¨ í•¨ìˆ˜
  - í•¨ìˆ˜ë¥¼ ì¸ìë‚˜ ë°˜í™˜ê°’ìœ¼ë¡œ ë‹¤ë£¨ëŠ” í•¨ìˆ˜(ì˜ˆ: filter , map , reduce ).
  - ìë°”ì—ì„œëŠ” í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ì™€ ëŒë‹¤ë¡œ êµ¬í˜„í•˜ë©°, ì½”ë“œì˜ ìœ ì—°ì„±ê³¼ ì¶”ìƒí™” ìˆ˜ì¤€ì„ ë†’ì„.
  - ì˜ˆ: List<Integer> filter(List<Integer> list, MyPredicate p) ëŠ” ì¡°ê±´ í•¨ìˆ˜ë¥¼ ë°›ì•„ ë™ì‘
- ê¸°íƒ€
  - ëŒë‹¤ëŠ” ìµëª… í´ë˜ìŠ¤ë¥¼ ê°„ì†Œí™”í•œ ë„êµ¬ì§€ë§Œ, ë‚´ë¶€ì ìœ¼ë¡œ ì¸ìŠ¤í„´ìŠ¤ê°€ ìƒì„±ë¨.
  - ë°˜ë³µ ì—°ìŠµìœ¼ë¡œ ë¬¸ë²•ê³¼ í™œìš©ë²•ì„ ìµíˆëŠ” ê²ƒì´ ì¤‘ìš”!

### Reference
* [ê¹€ì˜í•œì˜ ì‹¤ì „ ìë°” - ê³ ê¸‰ 3í¸, ëŒë‹¤, ìŠ¤íŠ¸ë¦¼, í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°](https://inf.run/6eCAW)