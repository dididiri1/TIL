# 섹션 9 타입 조작하기

## 0. 타입 조작이란
타입 조작은 타입스크립트에서 원래 있던 타입을 상황에 맞게 다른 타입으로 변환하는 기능이다.  
이전에 배운 제네릭도 함수나 인터페이스, 타입 별칭, 클래스 등에서 상황에 맞는 타입을 정의하는데   
사용되니까 타입 조작의 일종이다. 제네릭 외에도 타입스크립트에는 다양한 타입 조작 기능이 있다
![](https://github.com/dididiri1/TIL/blob/main/Typescript/images/09_01.webp?raw=true)

첫번째로 살펴볼 타입 조작 기능은 객체, 배열, 튜플 타입으로부터 특정 프로퍼티나 특정 요소의 타입만
추출하는 인덱스드 엑세스 타입이다.

![](https://github.com/dididiri1/TIL/blob/main/Typescript/images/09_02.webp?raw=true)

두번째로는 객체 타입으로부터 해당 타입 내에 정의된 프로퍼티의 키들을 유니온 타입으로 추출하는 키오브 타입이다.

![](https://github.com/dididiri1/TIL/blob/main/Typescript/images/09_03.webp?raw=true)

세번째로는 마치 자바스크립트의 맵 함수처럼 기존의 객체 타입을 기반으로 새로운 객체 타입을 만드는 맵드 타입이다.

![](https://github.com/dididiri1/TIL/blob/main/Typescript/images/09_04.webp?raw=true)

마지막 네번째로는 기존의 스트링 리터럴 타입을 기반으로 정해진 패턴의 문자열만 포함하는 템플릿 리터럴 타입에   
대해 살펴보겠다.

![](https://github.com/dididiri1/TIL/blob/main/Typescript/images/09_05.webp?raw=true)

## 인덱스드 엑세스 타입
### 인덱스드 엑세스 타입
인덱스드 엑세스 타입은 인덱스를 이용해 다른 타입내의 특정 프로퍼티의 타입을 추출하는 타입이다.
인덱스드 엑세스 타입은 객체, 배열, 튜플에 사용할 수 있기 때문에 세가지를 순서대로 모두 살펴보겠다.

#### 객체 프로퍼티의 타입 추출하기
```
interface Post {
  title: string;
  content: string;
  author: {
    id: number;
    name: string;
  };
}

const post: Post = {
  title: "게시글 제목",
  content: "게시글 본문",
  author: {
    id: 1,
    name: "이정환",
  },
};
```

이 게시글에서 작성자의 이름과 아이디를 붙여서 출력하는 어떤 함수가 하나 있어야 한다면 다음과 같이 해야 한다.
```
interface Post {
  title: string;
  content: string;
  author: {
    id: number;
    name: string;
    age: number; // 추가된다면?
  };
}

function printAuthorInfo(author: { id: number; name: string }) {
  console.log(`${author.id} - ${author.name}`);
}
```
매개변수의 타입을 이렇게 정의하면 나중에 Post 타입의 author 프로퍼티의 타입이 다음과 같이 수정되면 매개변수의   
타입도 그때 마다 계속 수정해줘야 하는 불편함이 존재한다. 이럴 때에는 다음과 같이 **인덱스드 엑세스** 타입을 이용한다.
```
interface Post {
  title: string;
  content: string;
  author: {
    id: number;
    name: string;
    age: number;
  };
}

function printAuthorInfo(author: Post["author"]) {
  console.log(`${author.name}-${author.id}`);
}

const post: Post = {
  title: "게시글 제목",
  content: "게시글 본문",
  author: {
    id: 1,
    name: "홍길동",
    age: 27
  },
};
```
Post["author"]는 Post 타입으로부터 author 프로퍼티의 타입을 추출한다. 그 결과 author 매개변수의 타입은 
{id : number, name: string, age:number}가 된다.  

이때 대괄호 속에 들어가는 String Literal 타입인 “author” 를 인덱스 라고 부른다. 그래서 인덱스를 이용해   
특정 타입에 접근하다고 하여 인덱스드 엑세스 타입이라 부릅니다.  

주의할 점은 인덱스에는 값이 아니라 **타입만** 들어갈 수 있다. “author”를 문자열 값으로 다른 변수에 저장하고   
다음과 같이 인덱스로 사용하려고 하면 오류가 발생한다.
```
const key = "author";

function printAuthorInfo(author: Post[key]) { // ❌
  console.log(`${author.name}-${author.id}`);
}
```
한가지 주의할 점은 인덱스에 존재하지 않는 프로퍼티 이름을 쓰면 오류가 발생한다.
```
function printAuthorInfo(author: Post["what"]) { // ❌
  console.log(`${author.id} - ${author.name}`);
}
```

#### 배열 요소의 타입 추출하기
인덱스드 엑세스 타입은 객체 프로퍼티의 타입 뿐만 아니라 특정 배열의 요소 타입을 추출하는데에도 이용할 수 있다.
```
type PostList = {
  title: string;
  content: string;
  author: {
    id: number;
    name: string;
    age: number;
  };
}[];

function printAuthorInfo(author: PostList[number]["author"]) {
  console.log(`${author.name}-${author.id}`);
}

const post: PostList[number] = {
  title: "게시글 제목",
  content: "게시글 본문",
  author: {
    id: 1,
    name: "홍길동",
    age: 27,
  },
};
```

#### 튜플의 요소 타입 추출하기
마지막으로 튜플의 각 요소들의 타입또한 다음과 같이 인덱스드 엑세스 타입으로 쉽게 추출할 수 있다.
```
type Tup = [number, string, boolean];

type Tup0 = Tup[0];
// number

type Tup1 = Tup[1];
// string

type Tup2 = Tup[2];
// boolean

type Tup3 = Tup[number]
// number | string | boolean
```
한가지 주의할 점은 튜플 타입에 인덱스드 엑세스 타입을 사용할 때 인덱스에 number 타입을 넣으면 마치   
튜플을 배열 처럼 인식해 배열 요소의 타입을 추출하게 된다.

## 2.keyof & typeof 연산자
### Keyof 연산자
keyof 연산자는 객체 타입으로부터 프로퍼티의 모든 key들을 String Literal Union 타입으로 추출하는 연산자이다.
```
interface Person {
  name: string;
  age: number;
}

function getPropertyKey(person: Person, key: "name" | "age") {
  return person[key];
}

const person: Person = {
  name: "홍길동",
  age: 27,
};
```
erson 객체 타입을 정의하고 해당 타입을 갖는 변수를 하나 선언한다.
그리고 getPropertyKey 함수를 만든다. 이 함수는 두개의 매개변수가 있으면 두번째 매개변수 key해당 하는  
프로퍼티의 값을 첫번째 매개변수 person에서 꺼내 반환한다.

이때 key의 타입을 “name” | “age”로 정의했는데 이렇게 정의하면 다음과 같이 Person 타입에 새로운 프로퍼티가   
추가되거나 수정될 때 마다 이 타입도 계속 바꿔줘야 하고 함수가 많아질수록 불편해진다. 이럴 떄 다음과 같이 Keyof  
연산자를 이용하면 좋다.
```
interface Person {
  name: string;
  age: number;
}

function getPropertyKey(person: Person, key: keyof Person) {
  return person[key];
}

const person: Person = {
  name: "홍갈동",
  age: 17,
};

getPropertyKey(person, "name");
```
keyof 연산자는 위와 같이 keyof 타입 형태로 사용하며 타입의 모든 프로퍼티 key를 String Literal Union 타입으로  
추출한다. 따라서 keyof Person의 결과값은 “name” | “age” | “location”이 된다.

한가지 주의할 점은 keyof 연산자는 오직 타입에만 적용할 수 있는 연산자 라는 점 입니다.
예를 들어서 대문자 Person이 아니라 소문자 person, 변수 person을 여기다 넣어주면 오류가 발생한다.
```
function getPropertyKey(person: Person, key: keyof person) { // ❌
  return person[key];
}
```

### Typeof와 Keyof 함께 사용하기
typeof 연산자는 자바스크립트에서 특정 값의 타입을 문자열로 반환하는 연산자 였다. 그러나 다음과 같이 타입을
정의할 때 사용하면 특정 변수의 타입을 추론하는 기능도 가지고 있다.
```
type Person = typeof person;

function getPropertyKey(person: Person, key: keyof typeof person) {
  return person[key];
}

const person = {
  name: "홍갈동",
  age: 17,
};

getPropertyKey(person, "name");
```
> typeof person을 써주면 이 변수의 타입을 추론해서 이 타입 별칭에다가 정의해준다.
> 변수의 type을 이렇게 뽑아내는 용도로도 활용할 수 있따.