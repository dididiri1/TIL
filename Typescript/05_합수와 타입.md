# 섹션 5 함수와 타입

## 함수 타입

### 함수의 타입을 정의하는 방법
다음과 같은 자바스크립트 함수가 있을 때, 이 함수를 다른 사람에게 설명하는 가장 좋은 방법은
이 함수가 어떤 매개변수를 받고 어떤 값을 반환 하는지 이야기 하는 것이다.

```
function func(a: number, b: number) {
  return a + b;
}
```
그럼 타입스크립트에서는 어떨까요? 자바스크립트에서 함수를 소개하는 방식과 비슷하다 대신 타입만 
추가되면 된다. 어떤 타입의 매개변수를 받고, 어떤 타입의 값을 반환하는지 이야기 하면 된다.

```
function func(a: number, b: number): number {
  return a + b;
}

```
> 참고로 함수의 반환값 타입은 자동으로 추론되기 때문에 다음과 같이 생격해도 된다.
```
function func(a: number, b: number) {
  return a + b;
}
```

#### 화살표 함수 타입 정의하기
```
const add = (a: number, b: number) => a + b;
```

#### 매개변수 기본값 설정하기
다음과 같이 함수의 매개변수에 기본값이 설정되어있으면 타입이 자동으로 추론된다. 이럴 경우 타입 정의를 생략해도 됨
```
function introduce(name = "홍길동") {
  console.log(`name : ${name}`);
}
```
기본값과 다른 타입으로 매개변수의 타입을 정의하면 오류가 발생한다
```
function introduce(name:number = "홍길동") {
  console.log(`name : ${name}`);
}
```
기본값과 다른 타입의 값을 인수로 전달해도 오류가 발생
``` 
function introduce(name = "홍길동") {
  console.log(`name : ${name}`);
}

introduce(1);
```

#### 선택적 매개변수 설정하기
매개변수의 이름뒤에 물음표(?)를 붙여주면 선택적 매개변수가 되어 생략이 가능하다.
```
function introduce(name = "홍길동", tall?: number) {
  console.log(`name : ${name}`);
  console.log(`tall : ${tall}`);
}

introduce("홍길동", 156);

introduce("홍길동");
```
위 코드의 tall 같은 선택적 매개변수의 타입은 자동으로 undefined와 유니온 된 타입으로 추론된다. 
따라서 tall의 타입은 현재 number | undefined이 된다 그러므로 이 값이 number 타입의 값일 
거라고 기대하고 사용하려면 다음과 같이 타입 좁히기가 필요하다.

```
function introduce(name = "홍길동", tall?: number) {
  console.log(`name : ${name}`);
  if (typeof tall === "number") {
    console.log(`tall : ${tall + 10}`);
  }
}
```
또 한가지 주의할 점은 선택적 매개변수는 필수 매개변수 앞에 올 수 없다. 반드시 뒤에 배치해야 한다.
```
function introduce(name = "홍길동", tall?: number, age: number) {
  // 오류!
  console.log(`name : ${name}`);
  if (typeof tall === "number") {
    console.log(`tall : ${tall + 10}`);
  }
}
```

#### 나머지 매개변수
getSum 함수는 나머지 매개변수 rest로 배열 형태로 number 타입의 인수들을 담은 배열을 전달받는다.
이때 rest 파라미터의 타입은 다음과 같이 정의하면 된다.

```
function getSum(...rest: number[]) {
  let sum = 0;
  rest.forEach((it) => (sum += it));

  return sum;
}

getSum(1, 2, 3);       // ✅ 
getSum(1, 2, 3, 4, 5); // ✅
```
약 나머지 매개변수의 길이를 고정하고 싶다면 다음과 같이 튜플 타입을 이용해도 된다.
```
function getSum(...rest: [number, number, number]) {
  let sum = 0;
  rest.forEach((it) => (sum += it));

  return sum;
}

getSum(1, 2, 3);       // ✅ 
getSum(1, 2, 3, 4, 5); // ❌
```

## 함수 타입 표현식과 호출 시그니쳐
### 함수 타입 표현식

다음과 같이 함수 타입을 타입 별칭과 함께 별도로 정의할 수 있다. 이를 
함수 타입 표현식(Function Type Expression)이라고 부른다.

```
type Add = (a: number, b: number) => number;

const add: Add = (a, b) => a + b;
```
변수 add의 타입을 함수 타입 표현식으로 정의한 함수 타입으로 정의했다. 이렇게 
함수 타입 표현식을 이용하면 함수 선언 및 구현 코드와 타입 선언을 분리할 수 있어 유용하다.

```
const add = (a: number, b: number) => a + b;
const sub = (a: number, b: number) => a - b;
const multiply = (a: number, b: number) => a * b;
const divide = (a: number, b: number) => a / b;
```

위 코드를 함수 타입 표현식을 이용하면 다음과 같이 간결하게 만들 수 있다. 또 나중에 
동일한 타입의 함수가 추가되어도 타입 주석을 이용해 타입 정의만 해주면 되어 매우 편리하다.
```
type Operation = (a: number, b: number) => number;

const add: Operation = (a, b) => a + b;****
const sub: Operation = (a, b) => a - b;
const multiply: Operation = (a, b) => a * b;
const divide: Operation = (a, b) => a / b;
```

함수 타입 표현식이 반드시 타입 별칭과 함께 사용되어야 하는 것은 아닙니다. 다음과 같이 그냥 함수 타입 표현식을 타입 주석에 사용해도 문제는 없다.

![](https://github.com/dididiri1/TIL/blob/main/Typescript/images/05_01.png?raw=true)

### 호출 시그니쳐
호출 시그니쳐(Call Signature)는 함수 타입 표현식과 동일하게 함수의 타입을 별도로 정의하는 방식이다.
```
type Operation2 = {
  (a: number, b: number): number;
};

const add2: Operation2 = (a, b) => a + b;
const sub2: Operation2 = (a, b) => a - b;
const multiply2: Operation2 = (a, b) => a * b;
const divide2: Operation2 = (a, b) => a / b;
```
자바스크립트에서는 함수도 객체이기 때문에, 위 코드처럼 객체를 정의하듯 함수의 타입을 별도로 정의할 수 있다.

```
type Operation2 = {
  (a: number, b: number): number;
  name: string
};

const add2: Operation2 = (a, b) => a + b;

add2(1, 2);
add2.name;
```
참고로 이때 다음과 같이 호출 시그니쳐 아래에 프로퍼티를 추가 정의하는 것도 가능하다. 이렇게 할 경우 함수이자 
일반 객체를 의미하는 타입으로 정의되며 이를 하이브리드 타입이라고 부른다.