# 섹션 4 타입스크립트 이해하기

## 타입은 집합이다.



타입스크립트의 '타입'은 사실 여러개의 값을 포함하는 '집합'이다.
그리고 이러한 타입(집합)들은 수직관계를 가지고 있다.

### 타입 호환성
그림처럼 Number 타입과 Number Literal 타입이 있을 때 서브 타입인 Number Literal 타입의 값을   
슈퍼 타입인 Number 타입의 값으로 취급하는 것은 가능합니다. 그러나 반대로는 불가능하다.
그 이유는 Number 타입이 더 큰 타입이기 때문이다.

![](https://github.com/dididiri1/TIL/blob/main/Typescript/images/04_01.png?raw=true)

따라서 타입스크립트에서는 이렇게 슈퍼타입의 값을 서브타입의 값으로 취급하는것을 허용하지 않습니다. 반대로는 허용합니다.

![](https://github.com/dididiri1/TIL/blob/main/Typescript/images/04_02.webp?raw=true)

그리고 특별히 서브 타입의 값을 슈퍼 타입의 값으로 취급하는 것을 **업 캐스팅** 이라고 부르고 반대로는
**다운 캐스팅**이라고 부른다. 업 캐스팅은 모든 상황에서 가능하지만 다운 캐스팅은 불가능하다.

## 타입 계층도와 함께 기본타입 살펴보기

![](https://github.com/dididiri1/TIL/blob/main/Typescript/images/04_03.png?raw=true)

### unknown 타입 (전체 집합)
unknown 타입은 타입 계층도의 최 상단에 위치함
따라서 unknown 타입 변수에는 모든 타입의 값을 할당할 수 있다.
바꿔 말하면 모든 타입은 unknown 타입으로 업 캐스트 할 수 있다.

``` 
let a: unknown = 1;                 // number -> unknown
let b: unknown = "hello";           // string -> unknown
let c: unknown = true;              // boolean -> unknown
let d: unknown = null;              // null -> unknown
let e: unknown = undefined;         // undefined -> unknown
let f: unknown = [];                // Array -> unknown
let g: unknown = {};                // Object -> unknown
let h: unknown = () => {};          // Function -> unknown
``` 

다운캐스트는 예외적인 경우가 아니면 허용되지 않는다고 배웠다. 
따라서 unknown 타입의 값은 any를 제외한 어떤 타입의 변수에도 할당할 수 없다.

``` 
let unknownValue: unknown;

let a: number = unknownValue;
// 오류 : unknown 타입은 number 타입에 할당할 수 없습니다.
``` 

### never 타입 (공집합 타입)
never 타입은 타입 계층도에서 가장 아래에 위치한다.

![](https://github.com/dididiri1/TIL/blob/main/Typescript/images/04_04.webp?raw=true)

``` 
function NeverExam() {
  function neverFunc(): never {
    while (true) {}
  }

  let num: number = neverFunc();
  let str: string = neverFunc();
  let bool: boolean = neverFunc();
}
```
never 타입은 모든 타입의 서브 타입이다. 모든 타입으로 업캐스팅 할 수 있습니다.

```
function NeverExam() {
  function neverFunc(): never {
    while (true) {}
  }

  let never1: never = 10;         // number -> never ❌
  let never2: never = "string";   // string -> never ❌
  let never3: never = true;       // boolean -> never ❌
}
```

반면 그 어떤 타입도 never 타입으로 다운 캐스팅 할 수 없습니다.


### void 타입

![](https://github.com/dididiri1/TIL/blob/main/Typescript/images/04_05.webp?raw=true)


타입 계층도에서 void 타입을 찾아보면 void 타입은 undefined 타입의 슈퍼타입임을 알 수 있다.
```
function voidExam() {
  function voidFunc(): void {
    console.log("hi");
  }

  let voidVar: void = undefined;
  
}
```

따라서 반환값을 void로 선언한 함수에서 undefined을 반환 해도 오류가 발생하지 않는다.
undefined 타입은 void 타입의 서브 타입이므로 업캐스팅이 가능하기 때문이다.

### any 타입 (치트키)
any 타입은 사실상 타입 계층도를 완전히 무시한다. any는 일종의 치트키같은 타입이다.
![](https://github.com/dididiri1/TIL/blob/main/Typescript/images/04_06.webp?raw=true)


```
function anyExam() {
  let unknownVar: unknown;
  let anyVar: any;
  let undefinedVar: undefined;
  let neverVar: never;

  anyVar = unknownVar;
  undefinedVar = anyVar;

  neverVar = anyVar;  // never -> any ❌
}
```

> 💡  any 타입은 치트키 타입이지만 never타입까지 다운 캐스팅 할수는 없다라고 예외적으로 알아두자!

## 객체 타입의 호환성
지난 시간에 기본 타입간의 호환성에 대해 살펴보았다.
```
let num1: number = 10;
let num2: 10 = 10;

num1 = num2; // ✅ OK
num2 = num1; // ❌ NO
```

습겸 위 코드를 다시 살펴보자면, Number 타입 변수 num1에 Number Literal 타입 변수 num2를 할당하는 것은 
업 캐스팅에 해당 하므로 허용된다. 그러나 반대로는 다운캐스팅에 해당하므로 안된다고 알아보았다.
```
type Animal = {
    name: string;
    color: string;
  };
  
  type Dog = {
    name: string;
    color: string;
    breed: string;
  };
  
  let animal: Animal = {
    name: "기린",
    color: "yellow",
  };
  
  let dog: Dog = {
    name: "돌돌이",
    color: "brown",
    breed: "진도",
  };
  
  animal = dog; // ✅ OK
  dog = animal; // ❌ NO
```


Animal 타입의 변수 animal에 Dog 타입의 변수 dog를 할당하는 것은 가능하다. 그러나 반대로 dog 변수에 animal 변수를 할당하는 것은 불가능하다. Animal 타입이 Dog 타입의 슈퍼타입이기 때문이다.

그런데 Animal 타입이 왜 Dog 타입의 슈퍼타입일까? 언뜻 보면 Dog 타입이 더 많은 프로퍼티를 정의하고 있어 슈퍼타입처럼 보일 수 있지만, 사실 그 반대다.

타입스크립트는 프로퍼티를 기준으로 타입을 정의하는 구조적 타입 시스템을 따른다. 따라서 Animal 타입은 name과 color 프로퍼티를 갖는 모든 객체를 포함하는 집합이고, Dog 타입은 name과 color에 추가로 breed 프로퍼티를 갖는 모든 객체를 포함하는 집합이다.

그러므로 어떤 객체가 Dog 타입에 포함된다면 무조건 Animal 타입에도 포함된다. 그러나 반대로 Animal 타입에 포함되는 모든 객체가 Dog 타입에 포함되는 것은 아니다. 따라서 결국 Animal은 Dog의 슈퍼타입이다

> 💡 추가 프로퍼티가 있는 타입이 슈퍼 타입이 되는게 아니고 반대로 이렇게 추가 프로퍼티가 없는 조건이 더 적은 타입이 슈퍼타입이 된다.

```
type Book = {
  name: string;
  price: number;
};

type ProgrammingBook = {
  name: string;
  price: number;
  skill: string;
};

let book: Book;
let programmingBook: ProgrammingBook = {
  name: "한 입 크기로 잘라먹는 리액트",
  price: 33000,
  skill: "reactjs",
};

book = programmingBook; // ✅ OK
programmingBook = book; // ❌ NO
```

### 초과 프로퍼티 검사
만약 새로운 변수를 만들고 다음과 같이 초기값을 설정하면 오류가 발생한다.
```
type Book = {
  name: string;
  price: number;
};

type ProgrammingBook = {
  name: string;
  price: number;
  skill: string;
};

let book2: Book = { // 오류 발생
  name: "한 입 크기로 잘라먹는 리액트",
  price: 33000,
  skill: "reactjs",
};
```
Book 타입으로 정의된 변수에 ProgrammingBook 타입으로 보이는 초기값을 설정했습니다. 그 결과 오류가 발생합니다. 무언가 이상합니다 이것은 업캐스팅에 해당되는데 왜 오류가 발생하는 걸까요?
결론부터 말하면 이것은 ‘초과 프로퍼티 검사’가 발동해서 그렇습니다. 초과 프로퍼티 검사란 변수를 객체 리터럴로 초기화 할 때 발동하는 타입스크립트의 특수한 기능입니다. 이 기능은 타입에 정의된 프로퍼티 외의 다른 초과된 프로퍼티를 갖는 객체를 변수에 할당할 수 없도록 막습니다.
따라서 위 코드는 Book 타입에 정의되지 않은 skill 프로퍼티를 갖는 객체를 할당하려고 했으므로 초과 프로퍼티 검사가 실패해 오류가 발생하고 있는 것 입니다.
이런 초과 프로퍼티 검사는 단순히 변수를 초기화 할 때 객체 리터럴을 사용하지만 않으면 발생하지 않습니다. 따라서 다음과 같이 값을 별도의 다른 변수에 보관한 다음 변수 값을 초기화 값으로 사용하면 발생하지 않습니다.
```
let book3: Book = programmingBook; // 앞서 만들어둔 변수
```
초과 프로퍼티 검사는 함수의 매개변수에도 동일하게 발생한다.
```
function func(book: Book) {}

func({ // 오류 발생
  name: "한 입 크기로 잘라먹는 리액트",
  price: 33000,
  skill: "reactjs",
});
```
함수의 매개변수에 인수로 값을 전달하는 과정도 변수를 초기화 하는 과정과 동일하다.
따라서 초과 프로퍼티 검사가 발동하게 된다. 
이때에도 역시 검사를 피하고 싶다면 다음과 같이 변수에 미리 값을 담아둔 다음 변수값을 인수로 전달하면 된다.
```
func(programmingBook);
```

## 대수 타입
### 대수 타입(Algebraic type)이란
대수 타입이란 여러개의 타입을 합성해서 만드는 타입을 말한다.
대수 타입에서는 합집합 타입과 교집합 타입이 존재한다. 합집한은 Union 타입, 교집합은 Intersection 타입이라고 부른다.

### 합집합(Union) 타입
다음과 같이 string과 number의 유니온 타입을 정의할 수 있다.
```
let a: string | number | boolean;
a = 1;
a = "hello";

a = true;
```
#### Union 타입으로 배열 타입 정의하기
```
let arr: (number | string | boolean)[] = [1, "hello", true];
```

#### Union 타입과 객체 타입
```
type Dog = {
  name: string;
  color: string;
};

type Person = {
  name: string;
  language: string;
};

type Union1 = Dog | Person;
```

정의된 Union1 타입은 다음과 같이 교집합이 존재하는 두 집합으로 표현할 수 있다.

![](https://github.com/dididiri1/TIL/blob/main/Typescript/images/04_07.webp?raw=true)
```
let union1: Union1 = { // ✅
  name: "",
  color: "",
};

let union2: Union1 = { // ✅
  name: "",
  language: "",
};

let union3: Union1 = { // ✅
  name: "",
  color: "",
  language: "",
};

let union4: Union1 = { // ❌
    name: "",
}
```
![](https://github.com/dididiri1/TIL/blob/main/Typescript/images/04_08.webp?raw=true)

> 💡 Dog 타입에 해당하는 객체를 넣었을때랑 union2에서 처럼 Person 타입에 해당하는 객체를 넣었을떄랑 
> 마지마긍로 두 타입의 모든 프로퍼티를 다 갖는 객체를 넣었을 때 이렇게 세가지 경우는 허용이 되었는데
> 마지막 union4은 두타입이 공통적으로 가지고 있는 name이라는 프로퍼티만 넣은 객체는 허용이 안된다.
> 왜 그럴까? 그림을 보면 이 두타입은 누구도 서로의 슈퍼 타입이거나 서브타입이지 않고 교집합 관계를 갖는다
> 이런 관계를 갖는 이유는 Dog 타입과 Person 타입이 각각 color와 language라는 서로에게는 없는 프로퍼티를
> 가지고 있기 때문이다.

### 교집합(Intersection) 타입
string과 number의 인터섹션 타입을 정의할 수 있다.
```
let variable: number & string; 
```
number 타입과 string 타입은 서로 교집합을 공유하지 않는 서로소 집합이므로 변수 variable의 타입은 대부분 never 타입이다.
대다수의 기본 타입들 간에는 서로 공유하는 교집합이 없기 때문에 이런 인터섹션 타입은 보통 객체 타입들에 자주 사용된다.

#### Intersection 타입과 객체 타입
```
type Dog = {
  name: string;
  color: string;
};

type Person = {
  name: string;
  language: string;
};

type Intersection = Dog & Person;

let intersection1: Intersection = {
  name: "",
  color: "",
  language: "",
};
```
> 💡 이 교집합에 들어올 수 있는 객체는 오직 이 Dog 타입과 Person 타입의 모든 프로퍼티를 다 갖곡 있는
> 객체만 교집합 타입으로 포함 될 수 있다.

![](https://github.com/dididiri1/TIL/blob/main/Typescript/images/04_09.webp?raw=true)

## 타입 추론
### 타입 추론이란
타입스크립트는 타입이 정의되어 있지 않은 변수의 타입을 자동으로 추론한다.
```
let a = 10;
// number 타입으로 추론
```
따라서 타입스크립트는 프로그래머에게 모든 변수에 일일이 타입을 정의하지 않아도 되는 편리함을 제공한다.
그러나 모든 상황에 타입을 잘 추론하는 것은 아니다.

예를 들어 다음과 같이 함수의 매개변수 타입은 자동으로 추론할 수 없다.
```
function func(param){ // 오류

}
```
### 타입 추론이 가능한 상황들
#### 1. 변수 선언
일반적인 변수 선언의 경우 초기값을 기준으로 타입이 잘 추론된다.
```
let b = "hello";
// string 타입으로 추론

let c = {
  id: 1,
  name: "홍길동",
  profile: {
    nickname: "winterlood",
  },
  urls: ["https//winterlood.com"],
};

// id, name, profile, urls 프로퍼티가 있는 객체 타입으로 추론
```
#### 2. 구조 분해 할당
```
let { id, name, profile } = c;

let [one, two, three] = [1, "hello", true];
```

#### 3. 함수의 반환값
```
function func() {
  return "hello";
}
// 반환값이 string 타입으로 추론된다
```

#### 4. 기본값이 설정된 매개변수
```
function func(message = "hello") {
  return "hello";
}
```

### 주의해야 할 상황들
#### 1. 암시적으로 any 타입으로 추론
변수를 선언할때 초기값을 생략하면 암시적인 any 타입으로 추론된다. 이때 매개변수의 타입이 암시적 
any로 추론될 때와 달리 일반 변수의 타입이 암시적 any 타입으로 추론되는 상황은 오류로 판단하지 않는다.

![](https://github.com/dididiri1/TIL/blob/main/Typescript/images/04_10.png?raw=true)


```
let d;
d = 10;
d.toFixed();

d = "hello";
d.toUpperCase();
d.toFixed(); // ❌
```

> 💡 d = 10; 다음 라인부터는 d가 number 타입이 되고, d = “hello” 다음 라인부터는 d가 string 타입이 된다.
> 따라서 마지막 라인에서 d가 string 타입일 때 toFixed 같은 number 타입의 메서드를 사용하려고 하면 오류가 발생한다. 
> 이렇게 암시적으로 추론된 any 타입은 코드의 흐름에 따라 타입이 계속 변화한다. 이를 **any의 진화**라고 표현하기도 한다.
> 왠만하면 이렇게 안목적인 any로 변수의 타입을 추론하게 두는 것을 추천하지 않고, 초기 값을 지정하지 않으면
> 이 변수의 타입이 이렇게 진화할 수 있다고 알아두자

#### 2. const 상수의 추론
const로 선언된 상수도 타입 추론이 된다. 그러나 let으로 선언한 변수와는 다른 방식으로 추론된다.
상수는 초기화 때 설정한 값을 변경할 수 없기 때문에 특별히 가장 좁은 타입으로 추론됩니다.
![](https://github.com/dididiri1/TIL/blob/main/Typescript/images/04_11.png?raw=true)

> 💡 변수를 선언했을 때에는 number 타입으로 추론이 되었지만 const로 선언한 변수에 타입을 보면
> number literal 타입으로 추론이 된다. 왜냐하면 이 const로 선언한 이 num 이라는 변수는 어차피
> 상수이기 때문에 이제부터는 이 10이라는 값 이오ㅔ이는 다른 값을 담을 일이 없다.

### 최적 공통 타입(Best Common Type)
다음과 같이 다양한 타입의 요소를 담은 배열을 변수의 초기값으로 설정하면, 최적의 공통 타입으로 추론된다.
```
let arr = [1, "string"];
```
> 이렇게 초기 값을 배열처럼 다양한 타입들의 값을 담을 수 있는 값으로 초기화할 경우에는 타입 추론이 진행될 떄
> 타입스크립트가 모든 배열 요소들의 타입을 비교해서 최적의 공통 타입으로 추론을 해준다.

