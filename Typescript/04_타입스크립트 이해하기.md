# 섹션 4 타입스크립트 이해하기

## 타입은 집합이다.



타입스크립트의 '타입'은 사실 여러개의 값을 포함하는 '집합'이다.
그리고 이러한 타입(집합)들은 수직관계를 가지고 있다.

### 타입 호환성
그림처럼 Number 타입과 Number Literal 타입이 있을 때 서브 타입인 Number Literal 타입의 값을   
슈퍼 타입인 Number 타입의 값으로 취급하는 것은 가능합니다. 그러나 반대로는 불가능하다.
그 이유는 Number 타입이 더 큰 타입이기 때문이다.

![](https://github.com/dididiri1/TIL/blob/main/Typescript/images/04_01.png?raw=true)

따라서 타입스크립트에서는 이렇게 슈퍼타입의 값을 서브타입의 값으로 취급하는것을 허용하지 않습니다. 반대로는 허용합니다.

![](https://github.com/dididiri1/TIL/blob/main/Typescript/images/04_02.webp?raw=true)

그리고 특별히 서브 타입의 값을 슈퍼 타입의 값으로 취급하는 것을 **업 캐스팅** 이라고 부르고 반대로는
**다운 캐스팅**이라고 부른다. 업 캐스팅은 모든 상황에서 가능하지만 다운 캐스팅은 불가능하다.

## 타입 계층도와 함께 기본타입 살펴보기

![](https://github.com/dididiri1/TIL/blob/main/Typescript/images/04_03.png?raw=true)

### unknown 타입 (전체 집합)
unknown 타입은 타입 계층도의 최 상단에 위치함
따라서 unknown 타입 변수에는 모든 타입의 값을 할당할 수 있다.
바꿔 말하면 모든 타입은 unknown 타입으로 업 캐스트 할 수 있다.

``` 
let a: unknown = 1;                 // number -> unknown
let b: unknown = "hello";           // string -> unknown
let c: unknown = true;              // boolean -> unknown
let d: unknown = null;              // null -> unknown
let e: unknown = undefined;         // undefined -> unknown
let f: unknown = [];                // Array -> unknown
let g: unknown = {};                // Object -> unknown
let h: unknown = () => {};          // Function -> unknown
``` 

다운캐스트는 예외적인 경우가 아니면 허용되지 않는다고 배웠다. 
따라서 unknown 타입의 값은 any를 제외한 어떤 타입의 변수에도 할당할 수 없다.

``` 
let unknownValue: unknown;

let a: number = unknownValue;
// 오류 : unknown 타입은 number 타입에 할당할 수 없습니다.
``` 

### never 타입 (공집합 타입)
never 타입은 타입 계층도에서 가장 아래에 위치한다.

![](https://github.com/dididiri1/TIL/blob/main/Typescript/images/04_04.webp?raw=true)

``` 
function NeverExam() {
  function neverFunc(): never {
    while (true) {}
  }

  let num: number = neverFunc();
  let str: string = neverFunc();
  let bool: boolean = neverFunc();
}
```
never 타입은 모든 타입의 서브 타입이다. 모든 타입으로 업캐스팅 할 수 있습니다.

```
function NeverExam() {
  function neverFunc(): never {
    while (true) {}
  }

  let never1: never = 10;         // number -> never ❌
  let never2: never = "string";   // string -> never ❌
  let never3: never = true;       // boolean -> never ❌
}
```

반면 그 어떤 타입도 never 타입으로 다운 캐스팅 할 수 없습니다.


### void 타입

![](https://github.com/dididiri1/TIL/blob/main/Typescript/images/04_05.webp?raw=true)


타입 계층도에서 void 타입을 찾아보면 void 타입은 undefined 타입의 슈퍼타입임을 알 수 있다.
```
function voidExam() {
  function voidFunc(): void {
    console.log("hi");
  }

  let voidVar: void = undefined;
  
}
```

따라서 반환값을 void로 선언한 함수에서 undefined을 반환 해도 오류가 발생하지 않는다.
undefined 타입은 void 타입의 서브 타입이므로 업캐스팅이 가능하기 때문이다.

### any 타입 (치트키)
any 타입은 사실상 타입 계층도를 완전히 무시한다. any는 일종의 치트키같은 타입이다.
![](https://github.com/dididiri1/TIL/blob/main/Typescript/images/04_06.webp?raw=true)


```
function anyExam() {
  let unknownVar: unknown;
  let anyVar: any;
  let undefinedVar: undefined;
  let neverVar: never;

  anyVar = unknownVar;
  undefinedVar = anyVar;

  neverVar = anyVar;  // never -> any ❌
}
```

> 참고: any 타입은 치트키 타입이지만 never타입까지 다운 캐스팅 할수는 없다라고 예외적으로 알아두자!

## 객체 타입의 호환성
지난 시간에 기본 타입간의 호환성에 대해 살펴보았다.
```
let num1: number = 10;
let num2: 10 = 10;

num1 = num2; // ✅ OK
num2 = num1; // ❌ NO
```

습겸 위 코드를 다시 살펴보자면, Number 타입 변수 num1에 Number Literal 타입 변수 num2를 할당하는 것은 
업 캐스팅에 해당 하므로 허용된다. 그러나 반대로는 다운캐스팅에 해당하므로 안된다고 알아보았다.
```
type Animal = {
    name: string;
    color: string;
  };
  
  type Dog = {
    name: string;
    color: string;
    breed: string;
  };
  
  let animal: Animal = {
    name: "기린",
    color: "yellow",
  };
  
  let dog: Dog = {
    name: "돌돌이",
    color: "brown",
    breed: "진도",
  };
  
  animal = dog; // ✅ OK
  dog = animal; // ❌ NO
```


Animal 타입의 변수 animal에 Dog 타입의 변수 dog를 할당하는 것은 가능하다. 그러나 반대로 dog 변수에 animal 변수를 할당하는 것은 불가능하다. Animal 타입이 Dog 타입의 슈퍼타입이기 때문이다.

그런데 Animal 타입이 왜 Dog 타입의 슈퍼타입일까? 언뜻 보면 Dog 타입이 더 많은 프로퍼티를 정의하고 있어 슈퍼타입처럼 보일 수 있지만, 사실 그 반대다.

타입스크립트는 프로퍼티를 기준으로 타입을 정의하는 구조적 타입 시스템을 따른다. 따라서 Animal 타입은 name과 color 프로퍼티를 갖는 모든 객체를 포함하는 집합이고, Dog 타입은 name과 color에 추가로 breed 프로퍼티를 갖는 모든 객체를 포함하는 집합이다.

그러므로 어떤 객체가 Dog 타입에 포함된다면 무조건 Animal 타입에도 포함된다. 그러나 반대로 Animal 타입에 포함되는 모든 객체가 Dog 타입에 포함되는 것은 아니다. 따라서 결국 Animal은 Dog의 슈퍼타입이다

> 추가 프로퍼티가 있는 타입이 슈퍼 타입이 되는게 아니고 반대로 이렇게 추가 프로퍼티가 없는 조건이 더 적은 타입이 슈퍼타입이 된다.

```
type Book = {
  name: string;
  price: number;
};

type ProgrammingBook = {
  name: string;
  price: number;
  skill: string;
};

let book: Book;
let programmingBook: ProgrammingBook = {
  name: "한 입 크기로 잘라먹는 리액트",
  price: 33000,
  skill: "reactjs",
};

book = programmingBook; // ✅ OK
programmingBook = book; // ❌ NO
```

### 초과 프로퍼티 검사
만약 새로운 변수를 만들고 다음과 같이 초기값을 설정하면 오류가 발생한다.
```
type Book = {
  name: string;
  price: number;
};

type ProgrammingBook = {
  name: string;
  price: number;
  skill: string;
};

let book2: Book = { // 오류 발생
  name: "한 입 크기로 잘라먹는 리액트",
  price: 33000,
  skill: "reactjs",
};
```
Book 타입으로 정의된 변수에 ProgrammingBook 타입으로 보이는 초기값을 설정했습니다. 그 결과 오류가 발생합니다. 무언가 이상합니다 이것은 업캐스팅에 해당되는데 왜 오류가 발생하는 걸까요?
결론부터 말하면 이것은 ‘초과 프로퍼티 검사’가 발동해서 그렇습니다. 초과 프로퍼티 검사란 변수를 객체 리터럴로 초기화 할 때 발동하는 타입스크립트의 특수한 기능입니다. 이 기능은 타입에 정의된 프로퍼티 외의 다른 초과된 프로퍼티를 갖는 객체를 변수에 할당할 수 없도록 막습니다.
따라서 위 코드는 Book 타입에 정의되지 않은 skill 프로퍼티를 갖는 객체를 할당하려고 했으므로 초과 프로퍼티 검사가 실패해 오류가 발생하고 있는 것 입니다.
이런 초과 프로퍼티 검사는 단순히 변수를 초기화 할 때 객체 리터럴을 사용하지만 않으면 발생하지 않습니다. 따라서 다음과 같이 값을 별도의 다른 변수에 보관한 다음 변수 값을 초기화 값으로 사용하면 발생하지 않습니다.
```
let book3: Book = programmingBook; // 앞서 만들어둔 변수
```
초과 프로퍼티 검사는 함수의 매개변수에도 동일하게 발생한다.
```
function func(book: Book) {}

func({ // 오류 발생
  name: "한 입 크기로 잘라먹는 리액트",
  price: 33000,
  skill: "reactjs",
});
```
함수의 매개변수에 인수로 값을 전달하는 과정도 변수를 초기화 하는 과정과 동일하다.
따라서 초과 프로퍼티 검사가 발동하게 된다. 
이때에도 역시 검사를 피하고 싶다면 다음과 같이 변수에 미리 값을 담아둔 다음 변수값을 인수로 전달하면 된다.
```
func(programmingBook);
```



