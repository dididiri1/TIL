# 섹션 11 최적화

## 10.1) 최적화란

![](https://github.com/dididiri1/TIL/blob/main/React/images/11_01.png?raw=true)

![](https://github.com/dididiri1/TIL/blob/main/React/images/11_02.png?raw=true)

![](https://github.com/dididiri1/TIL/blob/main/React/images/11_03.png?raw=true)


## 10.2) useMemo와 연산 최적화

![](https://github.com/dididiri1/TIL/blob/main/React/images/11_04.png?raw=true)

![](https://github.com/dididiri1/TIL/blob/main/React/images/11_05.png?raw=true)

![](https://github.com/dididiri1/TIL/blob/main/React/images/11_06.png?raw=true)

![](https://github.com/dididiri1/TIL/blob/main/React/images/11_07.png?raw=true)

### 
``` 
  const filteredTodos = getFiltereData(); // (2)

  const getAnalyzedDate = () => {
    console.log("getAnalyzedData 호출!");
  
    const totalCount = todos.length;
    const doneCount = todos.filter((todo) => todo.isDone).length; // 1()
    const notDoneCount = totalCount - doneCount;

    return {
      totalCount,
      doneCount,
      notDoneCount,
    };
  };

  const { totalCount, doneCount, notDoneCount } = getAnalyzedDate();

``` 
> (1) 연산 과정은 Filter라는 배열 메소드를 이용하고 있기 때문에 Todos state에 보관된 데이터의 갯수가  
> 증가할수록 훨씬 더 오래 걸리는 함수가 될 것이다. 왜냐면 Filter 메소드는 배열 내에 전체 요소들을  
> 한 번씩 다 순회하기 떄문이다. 그래서 함수가 불필요하게 호출되는 경우를 방지 할 수 있어야 된다.  
> (2)를 보면 이함수는 컴포넌트 내에서 바로 호출되고 있다. 결국에는 리스트 컴포넌트가 리렌더링 될  
> 때마다 계속 새롭게 호출되고 있다.

![](https://github.com/dididiri1/TIL/blob/main/React/images/11_08.png?raw=true)

### 메모제이 
``` 
import "./List.css";
import TodoItem from "./TodoItem";
import { useState, useMemo } from "react";

const List = ({ todos, onUpdate, onDelete }) => {
  const [search, setSearch] = useState("");

  const onChangeSearch = (e) => {
    setSearch(e.target.value);
  };

  const getFiltereData = () => {
    if (search === "") {
      return todos;
    }

    return todos.filter((todo) =>
      todo.content.toLowerCase().includes(search.toLocaleLowerCase())
    );
  };

  const filteredTodos = getFiltereData();

  const { totalCount, doneCount, notDoneCount } = useMemo(() => {
    console.log("getAnalyzedData 호출!");

    const totalCount = todos.length;
    const doneCount = todos.filter((todo) => todo.isDone).length;
    const notDoneCount = totalCount - doneCount;

    return {
      totalCount,
      doneCount,
      notDoneCount,
    };
  }, [todos]);
  // 의존성 배열 : deps

  return (
    <div className="List">
      <h4>Todo List</h4>
      <div>
        <div>total: {totalCount}</div>
        <div>done: {doneCount}</div>
        <div>notDone: {notDoneCount}</div>
      </div>
      <input
        value={search}
        onChange={onChangeSearch}
        placeholder="검색어를 입력하세요."
      />
      <div className="todos_wrapper">
        {filteredTodos.map((todo) => {
          return (
            <TodoItem
              key={todo.id}
              {...todo}
              onUpdate={onUpdate}
              onDelete={onDelete}
            />
          );
        })}
      </div>
    </div>
  );
};

export default List;

``` 
 
## 10.3) React.memo와 컴포넌트 렌더링 최적화

### 1) memo 리엑트의 내장 메소드
- 인수로 리엑트의 컴퍼넌트를 받아서 해당 컴포넌트에 최적화 기능을 추가한 다음에 결과 값으로 반환
- props를 기준으로 메모이제이션 된다. 
- 부모 컴포넌트가 리렌더링 되더라도 자신이 받는 props가 바뀌지 않으면 다시는 리렌더링이 발생되지 않는다.
- 불필요한 리렌더링 방지 최적화됨

![](https://github.com/dididiri1/TIL/blob/main/React/images/11_09.png?raw=true)

![](https://github.com/dididiri1/TIL/blob/main/React/images/11_10.png?raw=true)

### 2) memo 최적화 전
- 화면에 발생하는 모든 컴포넌트가 라렌더링 되고 있다. 
- 헤더 컴포넌트는 리렌더링이 발생할 이유가 없음

![](https://github.com/dididiri1/TIL/blob/main/React/images/11_11.png?raw=true)

### 3) memo 최적화 후
- 메모를 이용하면 불필요한 리렌더링을 방지할 수 있다. 
- 단, 자신이 받는 props가 바뀌지 않으면 다시는 리렌더링이 발생하지 않음
#### Header.jsx
``` 
import "./Header.css";
import { memo } from "react";

const Header = () => {
  return (
    <div className="Header">
      <h3>오늘은 📖</h3>
      <h1>{new Date().toDateString()}</h1>
    </div>
  );
};

const memoizedHeader = memo(Header);

export default memoizedHeader;

```
``` 
"react-refresh/only-export-components": "off",
``` 

#### TodoItem.jsx

``` 
import "./TodoItem.css";
import { memo } from "react";

const TodoItem = ({ id, isDone, content, date, onUpdate, onDelete }) => {
  const onChageCheckBox = () => {
    onUpdate(id);
  };

  const onClickDeleteButton = () => {
    onDelete(id);
  };

  return (
    <div className="TodoItem">
      <input onChange={onChageCheckBox} checked={isDone} type="checkbox" />
      <div className="content">{content}</div>
      <div className="date">{new Date(date).toLocaleDateString()}</div>
      <button onClick={onClickDeleteButton}>삭제</button>
    </div>
  );
};

export default memo(TodoItem);

```

> 참고: TodoItem은 컴포넌트가 props로 받는 이 onUpdate와 onDelete 새로운 함수로서  
> 전달이 되고 있기 때문에 그래서 결국은 메모를 적용했다고 하더라도 리렌더링이 발생하게 된다.  
> 그렇기 떄문에 이렇게 객체 타입의 값을 props로 받고 있는 컴포넌트는 메모 메서드를 적용하기만 한다고  
> 해서 최적화가 이루어지지 않는다. 그래서 두 가지 방법을 적용할 수 있는데 첫 번쨰 방법은 앱컴포넌에서   
> 이 함수를 자제를 메모이제이션해서 리렌더링 되더라도 다시 생성되지 않게 방지하는 방법과 두 번째 방법은  
> toDoItem 컴포넌트의 메모 함수안에 두 번째 인수로 콜백 함수를 추가로 전달해서 최적화 기능을  
> 커스터마이징 해주는 방법이 있다.

### 4) 두 번쨰 방법 - 고차 컴포넌트 (HOC)

```
export default memo(TodoItem, (prevProps, nextProps) => {
  // 반환값에 따라, Props가 바뀌었는지 안바뀌었는지 판단
  // T -> Props 바뀌지 않음 -> 리렌더링 X
  // F -> Props 바뀜 -> 리렌더링 O
  // onUpdate, onDelete만 뺴고 id, isDone, content, data 값만
  // 바뀌었을 떄만 리렌더링 시켜주면 되니깐 콜백 함수 안에 조건문 정의

  if (prevProps.id !== nextProps.id) {
    return false;
  }
  if (prevProps.isDone !== nextProps.isDone) {
    return false;
  }
  if (prevProps.content !== nextProps.content) {
    return false;
  }
  if (prevProps.date !== nextProps.date) {
    return false;
  }
});

```

고차 컴포넌트(HOC) 관련 아티클

https://patterns-dev-kr.github.io/design-patterns/hoc-pattern/

