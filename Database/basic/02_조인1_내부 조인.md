# 2. 조인1 - 내부 조인

## 실습 데이터 준비
데이터베이스를 본격적으로 사용하기 전에 아직 MySQL이 설치되어 있지 않다면 다음을 참고해서 본인의 환경에 맞는 MySQL을 설치하고, 
MySQL 워크벤치도 실행하자.

#### 1.강의 소개와 수업 자료
- 윈도우 - MySQL 설치 안내
- macOS - MySQL 설치 안내

### 주요 비즈니스 규칙 및 제약사항
우리가 만들 쇼핑몰의 비즈니스 규칙은 다음과 같다.

1. 고객 가입: 모든 고객은 고유한 이메일 주소를 가져야 한다. 이름과 이메일은 필수 정보다.
2. 주문 생성: 주문은 반드시 특정 고객( user_id )과 특정 상품( product_id )에 연결되어야 한다. 하나의 주문에 한 종류의 상품만 선택할 수 있다. 
   상품의 수량은 선택할 수 있다.
3. 주문 상태 관리: 주문이 생성되면 기본 상태는 'PENDING'이며, 이후 'COMPLETED', 'SHIPPED', 'CANCELLED'로 변경될 수 있다.
  - PENDING(대기)
  - SHIPPED(배송)
  - COMPLETED(완료)
  - CANCELLED(취소)
4. 재고 관리: 주문이 발생하면 해당 products 테이블의 stock_quantity (재고)는 주문 quantity (수량)만큼 차감되어야 한다.
  - 이 로직은 데이터베이스가 아니라 애플리케이션에서 구현해야 한다.
5. 직원 관리 구조: 직원은 매니저를 가질 수 있으며, 매니저 또한 직원이다. 매니저가 없는 최상위 직원이 존재할 수 있다.

> 💡왜 이런 비즈니스 규칙과 제약사항을 먼저 살펴볼까?
> 실제로 데이터베이스를 만들 때는 먼저 어떤 데이터가 필요하고, 그 데이터들이 어떻게 연결되는지 설계하는 과정이 꼭 필요하다.
> 하지만 이번 강의는 데이터베이스 설계가 주제가 아니기 때문에, 이런 규칙과 구조가 있다는 것만 간단히 이해하고 넘어가자.
> 데이터베이스 설계에 관한 부분은 데이터베이스 설계 강의에서 자세히 다룬다.

### 데이터 모델 다이어그램 (ERD)
![](https://github.com/dididiri1/TIL/blob/main/Database/basic/images/01_01.png?raw=true)

#### 고객 주문 상품의 관계
- 고객(users)은 여러 개의 주문(orders)을 생성할 수 있다.
- 상품(products)은 여러 주문(orders)에 포함될 수 있다.
- 하나의 주문(orders)은 한 명의 고객과 하나의 상품에 연결된다.

#### 나머지 관계
- 직원(employees)은 다른 직원을 관리하는 계층 구조(SELF JOIN)를 가진다.
  - manager_id 를 통해 상사를 알 수 있다.
- 사이즈(sizes)와 색상(colors) 테이블은 상품의 모든 옵션 조합을 생성하기 위해 사용된다.

### 테이블별 상세 요구사항
고객 (users) 테이블
고객의 개인 정보 및 계정 정보를 저장한다.

| 컬럼명      | 데이터 타입   | 제약 조건                       | 설명                                                   |
|-------------|---------------|---------------------------------|--------------------------------------------------------|
| user_id     | BIGINT        | PK, AUTO_INCREMENT              | 고객의 고유 식별자 (자동 증가)                         |
| name        | VARCHAR(255)  | NOT NULL                        | 고객의 이름 (필수 입력)                               |
| email       | VARCHAR(255)  | NOT NULL, UNIQUE                | 고객의 이메일. 로그인 ID로 사용 가능하며, 중복 불가 (필수 입력) |
| address     | VARCHAR(255)  |                                 | 고객의 주소 (선택 입력)                               |
| birth_date  | DATE          |                                 | 고객의 생년월일 (선택 입력, YYYY-MM-DD 형식)          |
| created_at  | DATETIME      | DEFAULT CURRENT_TIMESTAMP       | 고객 정보 생성 일시 (자동으로 현재 시간 기록)         |

#### 상품 (products) 테이블
판매하는 상품의 정보를 관리한다.\

| 컬럼명         | 데이터 타입   | 제약 조건                  | 설명                                   |
|----------------|---------------|----------------------------|----------------------------------------|
| product_id     | BIGINT        | PK, AUTO_INCREMENT         | 상품의 고유 식별자 (자동 증가)         |
| name           | VARCHAR(255)  | NOT NULL                   | 상품의 이름 (필수 입력)                |
| category       | VARCHAR(100)  |                            | 상품의 카테고리 (선택 입력)            |
| price          | INT           | NOT NULL                   | 상품의 가격 (필수 입력)                |
| stock_quantity | INT           | NOT NULL                   | 상품의 재고 수량 (필수 입력)           |

#### 주문 (orders) 테이블
고객의 상품 주문 내역을 기록한다.

| 컬럼명     | 데이터 타입  | 제약 조건                         | 설명                                                                 |
|------------|--------------|-----------------------------------|----------------------------------------------------------------------|
| order_id   | BIGINT       | PK, AUTO_INCREMENT                | 주문의 고유 식별자 (자동 증가)                                       |
| user_id    | BIGINT       | NOT NULL, FK                      | 주문한 고객의 ID (`users.user_id` 참조)                              |
| product_id | BIGINT       | NOT NULL, FK                      | 주문된 상품의 ID (`products.product_id` 참조)                        |
| order_date | DATETIME     | DEFAULT CURRENT_TIMESTAMP         | 주문 생성 일시 (자동으로 현재 시간 기록)                             |
| quantity   | INT          | NOT NULL                          | 주문 수량 (필수 입력)                                                |
| status     | VARCHAR(50)  | DEFAULT 'PENDING'                 | 주문 상태:<br>- PENDING (대기)<br>- COMPLETED (완료)<br>- SHIPPED (배송)<br>- CANCELLED (취소) |

#### 직원 (employees) 테이블
직원 및 관리자(매니저) 관계를 정의한다. (Self Join 관계)

| 컬럼명      | 데이터 타입  | 제약 조건               | 설명                                                                 |
|-------------|--------------|-------------------------|----------------------------------------------------------------------|
| employee_id | BIGINT       | PK, AUTO_INCREMENT      | 직원의 고유 식별자 (자동 증가)                                       |
| name        | VARCHAR(255) | NOT NULL                | 직원의 이름 (필수 입력)                                              |
| manager_id  | BIGINT       | FK                      | 해당 직원의 관리자 ID (`employees.employee_id` 참조).<br>최상위 관리자는 NULL 가능 |

#### 사이즈 (sizes) 및 색상 (colors) 테이블
상품의 다양한 옵션을 조합하기 위한 기준 데이터를 정의한다. (CROSS JOIN 실습용)

#### sizes 테이블

| 컬럼명 | 데이터 타입 | 제약 조건 | 설명                                   |
|--------|-------------|-----------|----------------------------------------|
| size   | VARCHAR(10) | PK        | 상품의 사이즈 옵션 (예: 'S', 'M', 'L', 'XL') |

#### colors 테이블

| 컬럼명 | 데이터 타입  | 제약 조건 | 설명                                   |
|--------|--------------|-----------|----------------------------------------|
| color  | VARCHAR(20)  | PK        | 상품의 색상 옵션 (예: 'Red', 'Blue', 'Black') |

### 테이블 설계 및 생성
우리는 쇼핑몰의 핵심 데이터인 고객(users) , 상품(products) , 그리고 주문(orders) 을 관리할 세 개의 기본 테이블을 설계했다. 
또한, 이후의 다양한 조인 기법을 실습하기 위해 직원(employees) 테이블과 상품 옵션을 위한 sizes , colors 테이블도 설계했다. 
이제 해당 테이블들을 실제로 만들어보자.

각 테이블을 생성하는 SQL(DDL)은 다음과 같다. 각 컬럼의 데이터 타입과 제약 조건을 유심히 살펴보길 바란다. 예를 들어, orders 테이블의 
user_id 는 users 테이블의 user_id 를 참조하는 외래 키(Foreign Key)로 설정되어 데이터의 무결성을 지키도록 설계했다.

데이터베이스 이름의 경우 데이터베이스 입문 강의 예제와 겹치지 않게 하기 위해 my_shop2 로 진행한다. 이 부분에 유의하자.

> 💡SQL 소스 파일 참고
> 강의 자료가 PDF 파일이라 복잡한 SQL 코드를 복사할 때 오류가 발생할 수 있다.
> 이 경우, 섹션 1. 강의 소개와 수업 자료 SQL 소스 파일을 다운로드해서 사용하자.

```
-- 데이터베이스가 존재하지 않으면 생성
CREATE DATABASE IF NOT EXISTS my_shop2;
USE my_shop2;

-- 테이블이 존재하면 삭제 (실습을 위해 초기화)
DROP TABLE IF EXISTS orders;
DROP TABLE IF EXISTS users;
DROP TABLE IF EXISTS products;
DROP TABLE IF EXISTS employees;
DROP TABLE IF EXISTS sizes;
DROP TABLE IF EXISTS colors;

-- 고객 테이블 생성
CREATE TABLE users (
    user_id BIGINT AUTO_INCREMENT,
    name VARCHAR(255) NOT NULL,
    email VARCHAR(255) NOT NULL UNIQUE,
    address VARCHAR(255),
    birth_date DATE,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (user_id)
);

-- 상품 테이블 생성
CREATE TABLE products (
    product_id BIGINT AUTO_INCREMENT,
    name VARCHAR(255) NOT NULL,
    category VARCHAR(100),
    price INT NOT NULL,
    stock_quantity INT NOT NULL,
    PRIMARY KEY (product_id)
);

-- 주문 테이블 생성
CREATE TABLE orders (
    order_id BIGINT AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    product_id BIGINT NOT NULL,
    order_date DATETIME DEFAULT CURRENT_TIMESTAMP,
    quantity INT NOT NULL,
    status VARCHAR(50) DEFAULT 'PENDING',
    PRIMARY KEY (order_id),
    CONSTRAINT fk_orders_users FOREIGN KEY (user_id) REFERENCES users(user_id),
    CONSTRAINT fk_orders_products FOREIGN KEY (product_id) REFERENCES products(product_id)
);

-- 직원 테이블 생성 (SELF JOIN 실습용)
CREATE TABLE employees (
    employee_id BIGINT AUTO_INCREMENT,
    name VARCHAR(255) NOT NULL,
    manager_id BIGINT,
    PRIMARY KEY (employee_id),
    FOREIGN KEY (manager_id) REFERENCES employees(employee_id)
);

-- 사이즈 테이블 (CROSS JOIN 실습용)
CREATE TABLE sizes (
    size VARCHAR(10) PRIMARY KEY
);

-- 색상 테이블 (CROSS JOIN 실습용)
CREATE TABLE colors (
    color VARCHAR(20) PRIMARY KEY
);
```
- CREATE DATABASE IF NOT EXISTS my_shop2 : my_shop2 데이터베이스가 존재하지 않으면 생성한다.
- DROP TABLE IF EXISTS orders : 주문 테이블이 만약에 존재하면 DROP 한다.
- 이렇게 IF EXISTS 구문을 활용하면 기존에 테이블이 있는 경우에만 깔끔하게 제거할 수 있다. 덕분에 같은 구문을 여러 번 실행해도 오류가 발생하지 않는다.
  - 만약 테이블이 없다면 DROP을 할 수 없기 때문에 DROP TABLE에서 오류가 발생한다. IF EXISTS 구문은 이런 번거로움을 해결해준다.

### 샘플 데이터 입력
앞서 생성한 테이블에 앞으로 우리가 분석하고 다룰 샘플 데이터를 입력한다. 일부러 한 번도 주문하지 않은 고객(레오나르도 다빈치)과 한 번도 팔리지 않은 
상품(고급 가죽 지갑)을 포함시켰다. 그 이유는 OUTER JOIN 수업에서 알게 될 것이다.

아래 INSERT 문을 실행해서 데이터를 채워 넣자.
```
-- 고객 데이터 입력
INSERT INTO users (name, email, address, birth_date) VALUES
    ('션', 'sean@example.com', '서울시 강남구', '1990-01-15'),
    ('네이트', 'nate@example.com', '경기도 성남시', '1988-05-22'),
    ('세종대왕', 'sejong@example.com', '서울시 종로구', '1397-05-15'),
    ('이순신', 'sunsin@example.com', '전라남도 여수시', '1545-04-28'),
    ('마리 퀴리', 'marie@example.com', '서울시 강남구', '1867-11-07'),
    ('레오나르도 다빈치', 'vinci@example.com', '이탈리아 피렌체', '1452-04-15');

-- 상품 데이터 입력
INSERT INTO products (name, category, price, stock_quantity) VALUES
    ('프리미엄 게이밍 마우스', '전자기기', 75000, 50),
    ('기계식 키보드', '전자기기', 120000, 30),
    ('4K UHD 모니터', '전자기기', 350000, 20),
    ('관계형 데이터베이스 입문', '도서', 28000, 100),
    ('고급 가죽 지갑', '패션', 150000, 15),
    ('스마트 워치', '전자기기', 280000, 40);

-- 주문 데이터 입력
INSERT INTO orders (user_id, product_id, quantity, status, order_date) VALUES
    (1, 1, 1, 'COMPLETED', '2025-06-10 10:00:00'),
    (1, 4, 2, 'COMPLETED', '2025-06-10 10:05:00'),
    (2, 2, 1, 'SHIPPED',   '2025-06-11 14:20:00'),
    (3, 4, 1, 'COMPLETED', '2025-06-12 09:00:00'),
    (4, 3, 1, 'PENDING',   '2025-06-15 11:30:00'),
    (5, 1, 1, 'COMPLETED', '2025-06-16 18:00:00'),
    (2, 1, 2, 'SHIPPED',   '2025-06-17 12:00:00');

-- 직원 데이터 입력
INSERT INTO employees (employee_id, name, manager_id) VALUES
    (1, '김회장', NULL),
    (2, '박사장', 1),
    (3, '이부장', 2),
    (4, '최과장', 3),
    (5, '정대리', 4),
    (6, '홍사원', 4);

-- 사이즈 데이터 입력
INSERT INTO sizes (size) VALUES
    ('S'),
    ('M'),
    ('L'),
    ('XL');

-- 색상 데이터 입력
INSERT INTO colors (color) VALUES
    ('Red'),
    ('Blue'),
    ('Black');
```

### 준비된 데이터 확인
모든 준비가 끝났다. 각 테이블에 데이터가 어떻게 들어갔는지 SELECT 문으로 직접 확인해 보자. 앞으로 우리는 이 데이터를 기반으로 흩어진 정보를 연결하고, 
숨겨진 의미를 찾아내는 여정을 떠날 것이다.

#### users 테이블
```
SELECT * FROM users;
```

| user_id | name             | email             | address         | birth_date  | created_at |
|---------|------------------|-------------------|-----------------|-------------|------------|
| 1       | 션               | sean@example.com  | 서울시 강남구   | 1990-01-15  | (생성일시) |
| 2       | 네이트           | nate@example.com  | 경기도 성남시   | 1988-05-22  | (생성일시) |
| 3       | 세종대왕         | sejong@example.com| 서울시 종로구   | 1397-05-15  | (생성일시) |
| 4       | 이순신           | sunsin@example.com| 전라남도 여수시 | 1545-04-28  | (생성일시) |
| 5       | 마리 퀴리        | marie@example.com | 서울시 강남구   | 1867-11-07  | (생성일시) |
| 6       | 레오나르도 다빈치| vinci@example.com | 이탈리아 피렌체 | 1452-04-15  | (생성일시) |

- created_at 필드(컬럼)의 날짜는 생성한 날짜이므로 각각 다르다.

#### products 테이블
```
SELECT * FROM products;
```

| product_id | name                     | category   | price   | stock_quantity |
|------------|--------------------------|-----------|---------|----------------|
| 1          | 프리미엄 게이밍 마우스   | 전자기기  | 75000   | 50             |
| 2          | 기계식 키보드            | 전자기기  | 120000  | 30             |
| 3          | 4K UHD 모니터            | 전자기기  | 350000  | 20             |
| 4          | 관계형 데이터베이스 입문 | 도서      | 28000   | 100            |
| 5          | 고급 가죽 지갑           | 패션      | 150000  | 15             |
| 6          | 스마트 워치              | 전자기기  | 280000  | 40             |

#### orders 테이블
```
SELECT * FROM orders;
```

| order_id | user_id | product_id | order_date           | quantity | status    |
|----------|---------|------------|---------------------|---------|-----------|
| 1        | 1       | 1          | 2025-06-10 10:00:00 | 1       | COMPLETED |
| 2        | 1       | 4          | 2025-06-10 10:05:00 | 2       | COMPLETED |
| 3        | 2       | 2          | 2025-06-11 14:20:00 | 1       | SHIPPED   |
| 4        | 3       | 4          | 2025-06-12 09:00:00 | 1       | COMPLETED |
| 5        | 4       | 3          | 2025-06-15 11:30:00 | 1       | PENDING   |
| 6        | 5       | 1          | 2025-06-16 18:00:00 | 1       | COMPLETED |
| 7        | 2       | 1          | 2025-06-17 12:00:00 | 2       | SHIPPED   |

이제 모든 준비가 완료되었다. 다음 시간부터 이 데이터를 가지고 JOIN 의 세계로 본격적으로 뛰어들어 보자.

> 💡참고
> 실무에서 다루는 주문 테이블들은 더 복잡하다. 지금은 데이터베이스 설계를 배우는 것이 목적이 아니기 때문에, 예제를 쉽게 이해할 수 있도록 
> 테이블의 수를 최소화 했다. 실무에 가까운 복잡한 설계 예시는 데이터 베이스 설계 강의에서 다루겠다.

