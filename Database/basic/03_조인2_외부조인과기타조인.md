## 3. 조인2 - 외부 조인과 기타 조인

## 외부 조인 1
내부 조인( INNER JOIN )을 통해 우리는 양쪽 테이블에 모두 존재하는, 짝이 맞는 데이터들을 성공적으로 연결했다.
하지만 실무에서는 종종 짝이 없는, 소외된 데이터를 찾아야 할 때가 있다.

지난 시간에 던졌던 질문을 다시 떠올려 보자.
**"우리 쇼핑몰에 가입은 했지만, 아직 한 번도 주문하지 않은 고객은 누구일까?"**
또는 이런 질문도 있을 수 있다.
**"야심차게 출시했지만, 아직 단 한 번도 팔리지 않은 비운의 상품은 무엇일까?"**

이 질문들에 내부 조인은 답할 수 없다. 왜냐하면 내부 조인은 주문 기록이 있는 고객, 판매 기록이 있는 상품, 즉
orders 테이블과 짝이 맞는 데이터만 보여주기 때문이다. 주문한 적 없는 고객이나 팔린 적 없는 상품은 orders 테
이블에 짝이 없으므로 결과에서 아예 누락된다. 이런 경우 왜 내부 조인을 사용할 수 없는지 예제로 확인해보자.

### 실습: '한 번도 주문하지 않은 고객' 찾기
'한 번도 주문하지 않은 고객'을 찾는 문제를 단계별로 접근해보자. 먼저 각 테이블을 개별적으로 조회해서 어떤 데이터
가 있는지 확인하고, 왜 내부 조인으로는 해결할 수 없는지 이해해보자.

#### 1단계: 각 테이블 개별 조회하기
먼저 users 테이블과 orders 테이블을 각각 조회해서 어떤 고객이 있고, 어떤 주문이 있는지 직접 확인해보자.

```sql
-- users 테이블 조회 (최소한의 필드만)
SELECT user_id, name, email FROM users;
```

#### [실행 결과 - users]
| user_id | name             | email              |
|--------|------------------|--------------------|
| 1      | 션               | sean@example.com   |
| 2      | 네이트            | nate@example.com   |
| 3      | 세종대왕          | sejong@example.com |
| 4      | 이순신            | sunsin@example.com |
| 5      | 마리 퀴리         | marie@example.com  |
| 6      | 레오나르도 다빈치 | vinci@example.com  |

```sql
-- orders 테이블 조회 (최소한의 필드만)
SELECT user_id, order_id FROM orders
order by user_id;
```

#### [실행 결과 - orders]
| user_id | order_id |
|---------|----------|
| 1       | 1        |
| 1       | 2        |
| 2       | 3        |
| 2       | 7        |
| 3       | 4        |
| 4       | 5        |
| 5       | 6        |

이제 눈으로 직접 비교해보자. users 테이블에는 user_id 가 {1, 2, 3, 4, 5, 6} 인 고객이 있다. 그런데
orders 테이블에는 user_id 가 {1, 2, 3, 4, 5} 인 주문만 있고, user_id 가 6인 주문은 없다. 즉, '레오나
르도 다빈치'는 가입은 했지만 한 번도 주문하지 않은 고객이다.

이렇게 눈으로 각각의 테이블을 하나하나 비교하는 것은 너무 많은 시간이 걸린다. 조인을 사용해보자.

#### 2단계: 내부 조인으로 시도해보기
결과를 한 번에 쉽게 확인하기 위해 내부 조인( INNER JOIN )을 사용해서 고객과 주문을 연결해보자.
```sql
SELECT
    u.user_id,
    u.name,
    o.user_id,
    o.order_id
FROM users u
JOIN orders o ON u.user_id = o.user_id
ORDER BY u.user_id;
```
- INNER 는 생략했다. INNER 를 생략하고 JOIN 만 적으면 내부 조인( INNER JOIN )으로 작동한다.

![](https://github.com/dididiri1/TIL/blob/main/Database/basic/images/03_01.png?raw=true)
- 조인 과정을 보면 레오나르도 다빈치의 users.user_id:6 에 해당하는 orders.user_id:6 이 없다.
- 따라서 레오나르도 다빈치는 조인 대상에서 제외된다.

#### [실행 결과]
| user_id | name       | user_id | order_id |
|---------|------------|---------|----------|
| 1       | 션         | 1       | 1        |
| 1       | 션         | 1       | 2        |
| 2       | 네이트     | 2       | 3        |
| 2       | 네이트     | 2       | 7        |
| 3       | 세종대왕   | 3       | 4        |
| 4       | 이순신     | 4       | 5        |
| 5       | 마리 퀴리  | 5       | 6        |
결과를 보면 '레오나르도 다빈치'( user_id : 6)가 결과에서 완전히 사라졌다. 내부 조인( INNER JOIN )은 양쪽 테이
블에 모두 존재하는 데이터만 보여주기 때문이다. 즉 주문 기록이 없는 고객은 orders 테이블에 짝이 없어서 결과에서 제외된다.

#### 외부 조인(OUTER JOIN)의 필요성
내부 조인( INNER JOIN )으로는 주문 기록이 없는 고객을 찾을 수 없다. 이런 경우에는 외부 조인( OUTER JOIN )이
필요하다. 외부 조인을 사용하면 한쪽 테이블에만 존재하는 데이터도 결과에 포함시킬 수 있다.

이처럼 한쪽에는 데이터가 있지만, 다른 한쪽에는 없는 데이터까지 모두 포함해서 보고 싶을 때 사용하는 기술이 바로
외부 조인이다.

### 외부 조인의 필요성 및 개념
조인은 본질적으로 두 테이블의 집합에 대한 이야기다.
그 중에 내부 조인은 교집합이다.

![](https://github.com/dididiri1/TIL/blob/main/Database/basic/images/03_02.png?raw=true)
- 내부 조인은 교집합 영역이기 때문에 users 에만 속한 '레오나르도 다빈치'( user_id : 6)를 결과에 포함할 수 없다.

그렇다면 교집합 영역 뿐만 아니라 왼쪽 영역을 모두 포함하는 집합 또는 오른쪽 영역을 모두 포함하는 집합 또는 양쪽을
모두 포함하는 집합은 어떻게 선택할 수 있을까?
예를 들어서 레오나르도 다빈치'(user_id: 6)를 결과에 포함하려면 어떻게 해야할까?


#### 외부 조인의 필요성
외부 조인( OUTER JOIN )은 두 테이블을 조인할 때, 특정 테이블의 데이터는 ON 조건이 맞지 않더라도 모두 결과에
포함시키는 방법이다.

![](https://github.com/dididiri1/TIL/blob/main/Database/basic/images/03_03.png?raw=true)

![](https://github.com/dididiri1/TIL/blob/main/Database/basic/images/03_04.png?raw=true)
이때 기준이 되는 테이블이 어느 쪽이냐에 따라 LEFT OUTER JOIN 과 RIGHT OUTER JOIN 으로 나뉜다.
그리고 교집합 영역은 물론이고, 기준이 되는 **테이블의 데이터는 결과에 모두 포함**된다.
레오나르도 다빈치'( user_id : 6)를 결과에 포함하려면 LEFT OUTER JOIN 을 선택하면 된다.

> 용어 - 외부 조인 (OUTER JOIN)
> 내부 조인(INNER JOIN)은 교집합 안(INNER)을 의미한다.
> 외부 조인은 교집합 밖(OUTER)의 영역을 포함한다는 의미다.

![](https://github.com/dididiri1/TIL/blob/main/Database/basic/images/03_05.png?raw=true)
> 풀 외부 조인(FULL OUTER JOIN)
> 양쪽 모두를 함께 포함하는 풀 외부 조인이라는 방법도 있다.
> 실무에서 잘 사용하지 않고, MySQL은 지원하지 않는다.

### LEFT OUTER JOIN vs RIGHT OUTER JOIN
외부 조인의 핵심은 '기준 테이블'을 정하는 것이다. LEFT OUTER JOIN 은 왼쪽 테이블을, RIGHT OUTER JOIN은 오른쪽 테이블을 
기준으로 삼는다.

> OUTER는 생략 가능
> 다음과 같이 OUTER는 생략해서 사용할 수 있다. 실무에서는 생략하는 것을 권장한다.
> - LEFT OUTER JOIN LEFT JOIN
> - RIGHT OUTER JOIN RIGHT JOIN

- LEFT JOIN (또는 LEFT OUTER JOIN )
  - LEFT JOIN 구문의 왼쪽(FROM 절)에 있는 테이블이 기준이 된다.
  - 일단 왼쪽 테이블의 모든 데이터를 결과에 포함시킨다.
  - 그다음, ON 조건에 맞는 데이터를 오른쪽 테이블에서 찾아 옆에 붙여준다.
  - 만약 오른쪽 테이블에 짝이 맞는 데이터가 없다면, 그 자리는 NULL 값으로 채워진다.

- RIGHT JOIN (또는 RIGHT OUTER JOIN )
  - RIGHT JOIN 구문의 오른쪽(JOIN 절)에 있는 테이블이 기준이 된다.
  - 일단 오른쪽 테이블의 모든 데이터를 결과에 포함시킨다.
  - 그다음, ON 조건에 맞는 데이터를 왼쪽 테이블에서 찾아 붙인다.
  - 마찬가지로 왼쪽 테이블에 짝이 맞는 데이터가 없다면, 그 자리는 NULL 로 채워진다.

### 실습 1: LEFT JOIN 으로 '한 번도 주문하지 않은 고객' 찾기
첫 번째 질문, "한 번도 주문하지 않은 고객은 누구인가?"에 답을 찾아보자. 이 질문의 기준은 '고객'이다. 따라서
users 테이블이 LEFT JOIN 의 왼쪽에 위치해야 한다.

### 1단계: users 를 기준으로 orders 테이블 LEFT JOIN 하기
먼저 users 테이블의 모든 고객을 일단 다 보여주고, 오른쪽에 주문 정보를 붙여보자. 어떤 결과가 나오는지 직접 확인하는 것이 중요하다.

```sql
SELECT
   u.user_id,
   u.name,
   o.user_id,
   o.order_id
FROM users u
LEFT JOIN orders o ON u.user_id = o.user_id
ORDER BY u.user_id;
```
- LEFT JOIN 을 사용했다.
- users 가 왼쪽이고, orders 가 오른쪽이다.
  - SQL을 보면 FROM 다음에 users 가 먼저 나오고 그 다음에 orders 가 나온다.

#### [실행 결과]
| user_id | name             | user_id | order_id |
|---------|------------------|---------|----------|
| 1       | 션               | 1       | 1        |
| 1       | 션               | 1       | 2        |
| 2       | 네이트            | 2       | 3        |
| 2       | 네이트            | 2       | 7        |
| 3       | 세종대왕          | 3       | 4        |
| 4       | 이순신            | 4       | 5        |
| 5       | 마리 퀴리         | 5       | 6        |
| 6       | 레오나르도 다빈치 | NULL    | NULL     |

실행 결과를 보자. INNER JOIN 에서는 보이지 않던 '레오나르도 다빈치( user_id:6 )'가 드디어 나타났다. 그는 주 문 기록이 없기 때문에, 
orders 테이블에서 가져온 user_id 와 order_id 컬럼의 값이 모두 NULL 로 채워져 있다. 이것이 바로 OUTER JOIN 이다.

![](https://github.com/dididiri1/TIL/blob/main/Database/basic/images/03_06.png?raw=true)

- LEFT JOIN 은 왼쪽에 있는 기준이 되는 테이블( users )의 모든 행을 포함한다.
- 참고로 여기서 레오나르도 다빈치( user_id:6 )는 orders 에 조인할 대상이 없다.

#### [조인 결과 - LEFT JOIN]
![](https://github.com/dididiri1/TIL/blob/main/Database/basic/images/03_07.png?raw=true)
- 이렇게 조인 대상이 없는 경우에는 나머지 값을 NULL 로 채우면서 조인 결과에 포함한다.

> OUTER JOIN은 기준 테이블의 데이터를 모두 포함한다.

2단계: NULL 인 데이터만 필터링하기
주문 정보가 NULL 인 고객이 바로 '한 번도 주문하지 않은 고객'이다. WHERE 절을 사용해서 이들만 찾아보자.

```sql
SELECT
    u.user_id,
    u.name,
    u.email
FROM users AS u
LEFT JOIN orders AS o ON u.user_id = o.user_id
WHERE o.order_id IS NULL;
```
> NULL 비교
> NULL 은 '값이 없음'을 나타내는 특별한 상태이므로, = 연산자로 비교할 수 없다. 반드시 IS NULL 또는
> IS NOT NULL 을 사용해야 한다.

#### [실행 결과]
| user_id | name             | email              |
|---------|------------------|--------------------|
| 6       | 레오나르도 다빈치 | vinci@example.com |

드디어 우리 쇼핑몰에서 한 번도 주문하지 않은 고객을 찾아냈다. 이제 이 고객에게만 특별 할인 쿠폰을 보내는 등의 타
겟 마케팅을 할 수 있는 근거 데이터가 마련된 것이다.


## 외부 조인 2
### 실습 2: LEFT JOIN 으로 '단 한 번도 팔리지 않은 상품' 찾기
이번에는 두 번째 질문, "단 한 번도 팔리지 않은 상품은 무엇인가?"에 답해보자. 이번 분석의 기준은 '상품'이다.
products 테이블의 데이터는 모두 결과에 나와야 한다. 따라서 products 테이블이 기준이 되어야 한다.

#### [products 테이블 주요 정보]
```sql
SELECT
    product_id,
    name,
    price
FROM products;
```

| product_id | name                      | price  |
|------------|---------------------------|--------|
| 1          | 프리미엄 게이밍 마우스    | 75000  |
| 2          | 기계식 키보드              | 120000 |
| 3          | 4K UHD 모니터             | 350000 |
| 4          | 관계형 데이터베이스 입문   | 28000  |

#### [orders 테이블 주요 정보]
```sql
SELECT
    product_id,
    order_id
FROM orders
order by product_id;
```

| product_id | order_id |
|------------|----------|
| 1          | 1        |
| 1          | 6        |
| 1          | 7        |
| 2          | 3        |
| 3          | 5        |
| 4          | 2        |
| 4          | 4        |

- product_id 로 정렬해서 조인을 더 이해하기 쉽게 확인하자.

눈으로 하나하나 비교해보니 고급 가죽 지갑(product_id:5) , 스마트 워치(product_id:6) 상품이 주문 내역에 보이지 않는다.

1단계: products 를 기준으로 orders 테이블 LEFT JOIN 하기
products 테이블을 기준으로 LEFT JOIN 을 사용해보자.

![](https://github.com/dididiri1/TIL/blob/main/Database/basic/images/03_08.png?raw=true)

```sql
SELECT
   p.product_id,
   p.name,
   p.price,
   o.product_id,
   o.order_id
FROM products p
LEFT JOIN orders o ON p.product_id = o.product_id
```

#### 조인 진행
![](https://github.com/dididiri1/TIL/blob/main/Database/basic/images/03_09.png?raw=true)

- 고급 가죽 지갑, 스마트 워치는 주문 내역에 없다.

#### [실행 결과]
| product_id | name                      | price  | product_id | order_id |
|------------|---------------------------|--------|------------|----------|
| 1          | 프리미엄 게이밍 마우스    | 75000  | 1          | 1        |
| 1          | 프리미엄 게이밍 마우스    | 75000  | 1          | 6        |
| 1          | 프리미엄 게이밍 마우스    | 75000  | 1          | 7        |
| 2          | 기계식 키보드              | 120000 | 2          | 3        |
| 3          | 4K UHD 모니터             | 350000 | 3          | 5        |
| 4          | 관계형 데이터베이스 입문   | 28000  | 4          | 2        |
| 4          | 관계형 데이터베이스 입문   | 28000  | 4          | 4        |
| 5          | 고급 가죽 지갑            | 150000 | NULL       | NULL     |
| 6          | 스마트 워치               | 280000 | NULL       | NULL     |

- products 테이블을 기준으로 LEFT OUTER JOIN 했으므로 products 의 제품은 조인 결과에 모두 포함된다.
- 따라서 주문 내역이 없는 고급 가죽 지갑, 스마트 워치도 조인 결과에 포함된다. 이 경우 조인 결과의 주문 관련 필드 값은 NULL 이 된다.

2단계: NULL 인 데이터만 필터링하기
주문 정보가 NULL 인 상품이 바로 '단 한 번도 팔리지 않은 상품'이다. WHERE 절을 사용해서 이들만 찾아보자.
```sql
SELECT
    p.product_id,
    p.name,
 p.price,
 o.product_id,
 o.order_id
FROM products AS p
LEFT JOIN orders AS o ON p.product_id = o.product_id
WHERE o.order_id IS NULL;
```

| product_id | name           | price  | product_id | order_id |
|------------|----------------|--------|------------|----------|
| 5          | 고급 가죽 지갑 | 150000 | NULL       | NULL     |
| 6          | 스마트 워치    | 280000 | NULL       | NULL     |

고급 가죽 지갑, 스마트 워치가 단 한 번도 팔리지 않은 상품인 것을 알 수 있다.