# 8. 인덱스1

## 인덱스를 위한 샘플 데이터
인덱스를 학습하기 위해 새로운 테이블들을 사용하자.
쇼핑몰의 판매자와 상품 정보를 담고 있는 sellers 와 items 테이블이다. 인덱스 예제는 이 두 테이블을 기반으로 한다.

> SQL 소스 파일 참고
> 강의 자료가 PDF 파일이라 복잡한 SQL 코드를 복사할 때 오류가 발생할 수 있다.
> 이 경우, 섹션 1. 강의 소개와 수업 자료 SQL 소스 파일을 다운로드해서 사용하자.

```sql
-- 데이터베이스가 존재하지 않으면 생성
CREATE DATABASE IF NOT EXISTS my_shop2;
USE my_shop2;

-- 테이블 초기화 (실습용)
DROP TABLE IF EXISTS items;
DROP TABLE IF EXISTS sellers;

-- 판매자 테이블 생성
CREATE TABLE sellers (
    seller_id INT PRIMARY KEY AUTO_INCREMENT,
    seller_name VARCHAR(100) UNIQUE NOT NULL,
    registered_date DATE NOT NULL
);

-- 상품 테이블 생성
CREATE TABLE items (
    item_id INT PRIMARY KEY AUTO_INCREMENT,
    seller_id INT NOT NULL,
    item_name VARCHAR(255) NOT NULL,
    category VARCHAR(100) NOT NULL,
    price INT NOT NULL,
    stock_quantity INT NOT NULL,
    registered_date DATE NOT NULL,
    is_active BOOLEAN NOT NULL,
    CONSTRAINT fk_items_sellers FOREIGN KEY (seller_id)
        REFERENCES sellers (seller_id)
);

-- 판매자 데이터 입력
INSERT INTO sellers (seller_id, seller_name, registered_date) VALUES
    (1, '행복쇼핑', '2020-01-15'),
    (2, '스마트상점', '2021-03-22'),
    (3, '글로벌셀러', '2019-11-01'),
    (4, '에코마켓', '2022-07-10'),
    (5, '베스트딜', '2020-05-30'),
    (6, '패션리더', '2023-01-05'),
    (7, '리빙스타', '2021-09-12'),
    (8, '테크월드', '2022-04-18'),
    (9, '북스토리', '2020-08-25'),
    (10, '헬스앤뷰티', '2023-03-01');

-- 상품 데이터 입력
INSERT INTO items (item_id, seller_id, item_name, category, price,
                   stock_quantity, registered_date, is_active)
VALUES
    (1, 1, '무선 기계식 키보드', '전자기기', 120000, 100, '2022-01-20', TRUE),
    (2, 1, '4K UHD 모니터', '전자기기', 450000, 50, '2022-02-15', TRUE),
    (3, 2, '프리미엄 게이밍 마우스', '전자기기', 80000, 200, '2021-11-10', TRUE),
    (4, 3, '관계형 데이터베이스 입문', '도서', 30000, 500, '2020-05-01', TRUE),
    (5, 4, '친환경 세제', '생활용품', 15000, 300, '2023-08-01', FALSE),
    (6, 5, '고급 가죽 지갑', '패션', 70000, 120, '2022-06-25', TRUE),
    (7, 1, '스마트 워치', '전자기기', 250000, 80, '2023-03-10', TRUE),
    (8, 6, '캐시미어 스웨터', '패션', 95000, 70, '2023-10-05', FALSE),
    (9, 7, '아로마 디퓨저', '생활용품', 40000, 150, '2022-09-01', TRUE),
    (10, 8, '게이밍 노트북', '전자기기', 1500000, 30, '2023-01-30', TRUE),
    (11, 9, 'SQL 마스터 가이드', '도서', 35000, 400, '2021-04-12', TRUE),
    (12, 10, '유기농 비누 세트', '헬스/뷰티', 20000, 250, '2023-02-20', FALSE),
    (13, 1, '노이즈 캔슬링 헤드폰', '전자기기', 300000, 90, '2023-07-01', TRUE),
    (14, 2, '인체공학 키보드', '전자기기', 90000, 110, '2022-05-05', TRUE),
    (15, 3, '파이썬 프로그래밍 가이드', '도서', 28000, 600, '2021-01-01', FALSE),
    (16, 4, '재활용 쇼핑백', '생활용품', 5000, 1000, '2023-09-15', TRUE),
    (17, 5, '빈티지 가죽 백팩', '패션', 180000, 60, '2022-08-01', TRUE),
    (18, 6, '여름용 린넨 셔츠', '패션', 45000, 180, '2023-04-20', TRUE),
    (19, 7, '친환경 주방 세트', '생활용품', 60000, 130, '2022-10-10', FALSE),
    (20, 8, '고성능 그래픽 카드', '전자기기', 800000, 40, '2023-06-01', TRUE),
    (21, 9, '어린이를 위한 그림책', '도서', 18000, 700, '2022-03-01', TRUE),
    (22, 10, '천연 에센셜 오일', '헬스/뷰티', 25000, 200, '2023-05-10', TRUE),
    (23, 1, '휴대용 빔 프로젝터', '전자기기', 350000, 70, '2023-02-01', TRUE),
    (24, 2, '게이밍 의자', '전자기기', 200000, 90, '2022-07-20', TRUE),
    (25, 3, '세계사 탐험', '도서', 22000, 350, '2021-02-28', FALSE);
```

### sellers 테이블
sellers 테이블은 쇼핑몰에 입점한 판매자 정보를 저장한다.

| 컬럼명          | 타입           | 설명                                   |
|-----------------|----------------|----------------------------------------|
| seller_id       | INT            | 판매자의 고유 식별자 (기본 키)         |
| seller_name     | VARCHAR(100)   | 판매자의 이름 (유니크 제약 조건)       |
| registered_date | DATE           | 판매자가 쇼핑몰에 등록한 날짜          |

### items 테이블
items 테이블은 판매자가 등록한 상품 정보를 저장한다. 각 상품은 특정 판매자( seller_id )에 의해 등록된다.

| 컬럼명          | 타입           | 설명                                                         |
|-----------------|----------------|--------------------------------------------------------------|
| item_id         | INT            | 상품의 고유 식별자 (기본 키)                                 |
| seller_id       | INT            | 상품을 등록한 판매자의 ID (FK, sellers.seller_id 참조)       |
| item_name       | VARCHAR(255)   | 상품의 이름                                                  |
| category        | VARCHAR(100)   | 상품의 카테고리 (예: 전자기기, 도서, 패션)                   |
| price           | INT            | 상품의 가격                                                  |
| stock_quantity  | INT            | 상품의 재고 수량                                             |
| registered_date | DATE           | 상품이 등록된 날짜                                           |
| is_active       | BOOLEAN        | 상품 판매 활성 여부 (TRUE: 활성, FALSE: 비활성)              |

### [셀러 데이터 확인]
```sql
SELECT * FROM sellers;
```

| seller_id | seller_name | registered_date |
|-----------|-------------|-----------------|
| 1         | 행복쇼핑    | 2020-01-15      |
| 2         | 스마트상점  | 2021-03-22      |
| 3         | 글로벌셀러  | 2019-11-01      |
| 4         | 에코마켓    | 2022-07-10      |
| 5         | 베스트딜    | 2020-05-30      |
| 6         | 패션리더    | 2023-01-05      |
| 7         | 리빙스타    | 2021-09-12      |
| 8         | 테크월드    | 2022-04-18      |
| 9         | 북스토리    | 2020-08-25      |
| 10        | 헬스앤뷰티  | 2023-03-01      |

#### [상품 데이터 확인]
```
SELECT * FROM items;
```

| item_id | seller_id | item_name               | category     | price    | registered_date | is_active |
|---------|-----------|--------------------------|--------------|----------|------------------|-----------|
| 1       | 1         | 무선 기계식 키보드       | 전자기기     | 120000   | 2022-01-20       | 1         |
| 2       | 1         | 4K UHD 모니터            | 전자기기     | 450000   | 2022-02-15       | 1         |
| 3       | 2         | 프리미엄 게이밍 마우스   | 전자기기     | 80000    | 2021-11-10       | 1         |
| 4       | 3         | 관계형 데이터베이스 입문 | 도서         | 30000    | 2020-05-01       | 1         |
| 5       | 4         | 친환경 세제              | 생활용품     | 15000    | 2023-08-01       | 0         |
| 6       | 5         | 고급 가죽 지갑           | 패션         | 70000    | 2022-06-25       | 1         |
| 7       | 1         | 스마트 워치              | 전자기기     | 250000   | 2023-03-10       | 1         |
| 8       | 6         | 캐시미어 스웨터          | 패션         | 95000    | 2023-10-05       | 0         |
| 9       | 7         | 아로마 디퓨저            | 생활용품     | 40000    | 2022-09-01       | 1         |
| 10      | 8         | 게이밍 노트북            | 전자기기     | 1500000  | 2023-01-30       | 1         |
| 11      | 9         | SQL 마스터 가이드        | 도서         | 35000    | 2021-04-12       | 1         |
| 12      | 10        | 유기농 비누 세트         | 헬스/뷰티    | 20000    | 2023-02-20       | 0         |
| 13      | 1         | 노이즈 캔슬링 헤드폰     | 전자기기     | 300000   | 2023-07-01       | 1         |
| 14      | 2         | 인체공학 키보드          | 전자기기     | 90000    | 2022-05-05       | 1         |
| 15      | 3         | 파이썬 프로그래밍 가이드 | 도서         | 28000    | 2021-01-01       | 0         |
| 16      | 4         | 재활용 쇼핑백            | 생활용품     | 5000     | 2023-09-15       | 1         |
| 17      | 5         | 빈티지 가죽 백팩         | 패션         | 180000   | 2022-08-01       | 1         |
| 18      | 6         | 여름용 린넨 셔츠         | 패션         | 45000    | 2023-04-20       | 1         |
| 19      | 7         | 친환경 주방 세트         | 생활용품     | 60000    | 2022-10-10       | 0         |
| 20      | 8         | 고성능 그래픽 카드       | 전자기기     | 800000   | 2023-06-01       | 1         |
| 21      | 9         | 어린이를 위한 그림책     | 도서         | 18000    | 2022-03-01       | 1         |
| 22      | 10        | 천연 에센셜 오일         | 헬스/뷰티    | 25000    | 2023-05-10       | 1         |
| 23      | 1         | 휴대용 빔 프로젝터       | 전자기기     | 350000   | 2023-02-01       | 1         |
| 24      | 2         | 게이밍 의자              | 전자기기     | 200000   | 2022-07-20       | 1         |
| 25      | 3         | 세계사 탐험              | 도서         | 22000    | 2021-02-28       | 0         |

- 일부 컬럼은 제외했다.


## 인덱스가 필요한 이유
우리는 지금까지 데이터를 효과적으로 조회하고 가공하는 다양한 SQL 문법들을 배웠다. 하지만 실제 세상에서는 문법
을 아는 것만으로는 부족하다. 우리 쇼핑몰이 대성공을 거두어, 판매하는 상품 수가 25개가 아니라 50만 개, 100만 개
로 늘어났다고 상상해 보자.

이제 고객이 우리 쇼핑몰에서 '게이밍 노트북'을 검색한다. 우리 시스템은 데이터베이스에 다음의 쿼리를 실행할 것이다.
```
SELECT * FROM items WHERE item_name = '게이밍 노트북';
```
데이터가 몇 건 없었을 때는 눈 깜짝할 사이에 끝나던 이 쿼리가, 이제는 3초, 5초, 혹은 그 이상이 걸리기 시작한다. 서
비스 속도가 느려지고 고객들은 답답함을 느껴 떠나간다. 분명 쿼리는 똑같은데, 왜 이렇게 느려진 걸까? 데이터베이스
안에서 도대체 무슨 일이 벌어지고 있는 걸까?
물론 데이터가 아주 많아야 이렇게 느려진다. 지금의 샘플 데이터는 많지 않기 때문에 금방 출력될 것이다. 여기서는 데
이터가 수백만 수천만 건이라고 가정하고 진행하겠다.

### 느린 검색의 원인: 풀 테이블 스캔 (Full Table Scan)
인덱스가 없는 테이블에서 특정 데이터를 찾는 과정은, 비유하자면 100만 페이지짜리 거대한 책에서 특정 단어 하나를
찾기 위해, 책의 첫 페이지부터 마지막 페이지까지 한 장 한 장 넘겨보는 것과 같다.
데이터베이스는 item_name 컬럼에 '게이밍 노트북'이라는 값이 어디에 있는지 알 수 있는 아무런 '힌트'가 없다. 그래
서 데이터베이스는 가장 무식하고 정직한 방법을 선택한다. 바로 items 테이블 전체를 디스크에서 메모리로 읽어 들
인 후, 첫 번째 행부터 마지막 100만 번째 행까지 하나씩 차례대로 item_name 컬럼의 값을 비교하는 것이다.

#### [items 테이블 전체 내용, 일부 컬럼 생략]
| item_id | seller_id | item_name                 | category     | price    | registered_date |
|---------|-----------|---------------------------|--------------|----------|------------------|
| 1       | 1         | 무선 기계식 키보드        | 전자기기     | 120000   | 2022-01-20       |
| 2       | 1         | 4K UHD 모니터             | 전자기기     | 450000   | 2022-02-15       |
| 3       | 2         | 프리미엄 게이밍 마우스    | 전자기기     | 80000    | 2021-11-10       |
| 4       | 3         | 관계형 데이터베이스 입문  | 도서         | 30000    | 2020-05-01       |
| 5       | 4         | 친환경 세제               | 생활용품     | 15000    | 2023-08-01       |
| 6       | 5         | 고급 가죽 지갑            | 패션         | 70000    | 2022-06-25       |
| 7       | 1         | 스마트 워치               | 전자기기     | 250000   | 2023-03-10       |
| 8       | 6         | 캐시미어 스웨터           | 패션         | 95000    | 2023-10-05       |
| 9       | 7         | 아로마 디퓨저             | 생활용품     | 40000    | 2022-09-01       |
| 10      | 8         | 게이밍 노트북             | 전자기기     | 1500000  | 2023-01-30       |
| 11      | 9         | SQL 마스터 가이드         | 도서         | 35000    | 2021-04-12       |
| 12      | 10        | 유기농 비누 세트          | 헬스/뷰티    | 20000    | 2023-02-20       |

이러한 작업 방식을 풀 테이블 스캔(Full Table Scan)이라고 부른다.
- 최선의 경우: 우리가 찾는 데이터가 우연히 첫 번째 행에 있다면 한 번의 비교만으로 끝난다.
  - 예) 무선 기계식 키보드
- 최악의 경우: 우리가 찾는 데이터가 맨 마지막 행에 있거나, 아예 존재하지 않는다면 100만 번의 비교를 모두 수 행해야만 결과를 알 수 있다.

풀 테이블 스캔은 빅오 표기법으로 O(n) 으로 표현한다. 여기서 n 은 레코드 건수를 나타내며, 레코드 수가 두 배로 증
가하면 스캔 시간도 대략 두 배로 증가한다는 의미다. 쉽게 이야기해서 풀 테이블 스캔은 데이터 건 수 만큼 데이터를 탐
색해야 한다는 뜻이다.

이렇듯 풀 테이블 스캔에서 데이터가 많아질수록 검색 시간이 정비례해서 늘어나는 것은 당연한 결과다. 이것이 바로 우
리의 서비스가 느려진 근본적인 원인이다.

이런 방식을 계속 유지한다면 우리 서비스는 장사가 잘 되면 잘 될수록, 그래서 데이터가 많아 질 수록 점점 더 느려지게
된다. 나중에는 사용자들이 답답해서 우리 서비스를 찾지 않게 될 것이다. 이러한 성능 문제는 반드시 해결해야 한다.

### 데이터 양에 따른 성능 저하
데이터 양에 따른 정확한 응답시간을 예측하는 것은 거의 불가능하다. 왜냐하면 응답시간은 데이터베이스 서버의 사양
(CPU, 메모리, 디스크 I/O 성능), 환경 설정, 데이터의 한 행(Row)당 크기, 시스템의 현재 부하 등 수많은 변수에 따라
크게 달라지기 때문이다.

하지만 **일반적인 기업용 서버 환경(SSD 디스크 기반)을 가정하고**, 한 행당 약 1KB의 데이터를 가진 테이블을 기준으
로 대략적인 예상 응답시간을 정리하면 다음과 같다.

#### 데이터 건수에 따른 풀테이블 스캔 예상 응답시간
| 데이터 건수    | 총 데이터 크기 (행당 1KB 가정) | 예상 응답시간                   | 비고                                                                 |
|----------------|----------------------------------|----------------------------------|----------------------------------------------------------------------|
| 100만 건       | 약 1GB                          | 수 초 (예: 0.2초 ~ 3초)         | 디스크 I/O 속도에 따라 좌우. 메모리(버퍼 캐시)에 일부가 있으면 더 빨라짐 |
| 1,000만 건     | 약 10GB                         | 수 초 ~ 1분 내외 (예: 2초 ~ 30초)| 본격적으로 디스크 I/O 병목이 발생하기 시작하는 구간                   |
| 1억 건         | 약 100GB                        | 수십 초 이상 (예: 20초 ~ 5분)   | 다른 작업과 경합이 발생하면 응답시간이 예측불가하게 길어질 수 있음     |

> 이 표는 단순 참고용이며, 실제 환경에서는 몇 배 이상 차이가 날 수 있다.
> 실무에서는 본인 환경에 맞는 성능 테스트를 통해 성능을 확인해야 한다.
> 실제로는 수 많은 요청을 동시에 처리한다. 예를 들어서 10명의 사용자가 동시에 요청하면 풀테
> 이블 스캔도 10개가 동시에 발생할 수 있다. 이런 경우 성능은 훨씬 더 느려진다.

### 실무 이야기1
오늘날의 사용자들은 단 몇 초의 로딩 시간도 기다리지 않는다.

> 페이지 로딩 속도에 관한 연구
> 이지 로딩 속도에 관한 다양한 논문들이 있는데 대략 정리하면 다음과 같다.
> - 모바일 페이지 로딩 속도가 1초에서 3초로 늘어나면 이탈률이 32% 증가한다.
> - 모바일 페이지 로딩 속도가 1초에서 5초로 늘어나면 이탈률이 90% 이상 증가한다.
> 정리하면 웹 서비스는 최소한 3초 이내, 이상적으로는 1~2초 이내의 빠른 로딩 속도를 목표로 해야 한다.

일반적인 서비스를 생각해보자. 하나의 화면에 단순히 items 테이블 하나만 조회할까? 아니다. 보통 한 화면을 보여
주기 위해서는 다양한 데이터가 필요하다. 따라서 다양한 테이블들을 함께 조회한다. 이 테이블들이 모두 풀 테이블 스
캔이라면 데이터의 양이 적을 때는 문제가 없어 보이겠지만, 데이터가 점점 증가하기 시작하는 순간 서비스도 점점 느려
지며 많은 사용자들이 이탈할 것이다.

### 실무 이야기2
풀테이블 스캔은 매우 비용이 높은 작업이므로, 서비스의 핵심 기능에서 가급적 풀테이블 스캔이 발생하지 않도록 설계
하는 것은 필수다.

- 인덱스 활용: WHERE 절에 자주 사용되는 검색 조건 컬럼에는 인덱스(Index)를 생성하여 풀테이블 스캔을 방지 하는 것이 가장 기본적인 해결책이다.
- 실행 계획 확인: 쿼리 실행 전 실행 계획(Execution Plan)을 확인하여 의도치 않은 풀테이블 스캔이 발생하는지 반드시 점검해야 한다.
- 작업 시간 분리: 대용량 데이터에 대한 전체 스캔이 불가피한 통계/배치 작업이라면, 서비스 이용자가 적은 새벽 시간에 실행하는 것을 권장한다.

다음 시간부터 인덱스에 대해서 알아보자.

## 인덱스 소개
그렇다면 이 무식한 풀 테이블 스캔을 피할 방법은 없을까?
다시 책의 비유로 돌아가 보자. 우리는 책에서 특정 단어를 찾을 때 책을 처음부터 다 읽지 않는다. 책의 맨 뒤에 있는 '찾
아보기(색인)' 페이지를 활용한다.

참고로 찾아보기를 다른 말로 색인이라 한다. 색인은 영어로 인덱스(INDEX)이다.

'찾아보기' 페이지는 어떻게 구성되어 있는가?
1. 책의 중요한 키워드들이 알파벳순, 가나다순(정렬된 순서)으로 정리되어 있다.
2. 각 키워드 옆에는 그 키워드가 등장하는 페이지 번호가 적혀 있다.

우리는 이 '찾아보기' 덕분에, 찾고 싶은 단어가 어느 페이지에 있는지 아주 빠르게 알아낸 뒤, 해당 페이지로 곧장 점프 할 수 있다.
그런데 여기서 중요한 점이 있다. 우리는 찾아보기 페이지를 보고 어떻게 빨리 데이터를 찾을 수 있을까? 바로 중요한
키워드들이 가나다순(정렬된 순서)로 정리되어 있기 때문이다!

데이터베이스의 인덱스(INDEX)는 이 책의 '찾아보기'와 정확히 동일한 역할을 한다.

인덱스는 특정 컬럼(들)의 데이터를 기반으로 생성되는, 원본 테이블과는 별개의 특수한 자료 구조다.
- 인덱스는 지정된 컬럼(예: item_name )의 값과, 해당 값을 가진 실제 데이터 행의 위치(예: 주소값, 포인터, PK 값 등)를 한 쌍으로 저장한다.
- 가장 중요한 것은, 인덱스 내부의 데이터는 항상 정렬된 상태를 유지한다는 점이다.

item_name 을 기반으로 인덱스를 만들면 다음과 같은 구조를 가진다.

#### [item_name 기반의 인덱스]
| item_name                   | 원본 데이터 위치 (PK: item_id) |
|-----------------------------|---------------------------------|
| 4K UHD 모니터               | 2                               |
| SQL 마스터 가이드           | 11                              |
| 관계형 데이터베이스 입문    | 4                               |
| 고급 가죽 지갑              | 6                               |
| 고성능 그래픽 카드          | 20                              |
| 게이밍 노트북               | 10                              |
| 게이밍 의자                 | 24                              |
| 노이즈 캔슬링 헤드폰        | 13                              |
| 무선 기계식 키보드          | 1                               |
| 빈티지 가죽 백팩            | 17                              |
| 세계사 탐험                 | 25                              |
| 스마트 워치                 | 7                               |
| 아로마 디퓨저               | 9                               |
| 어린이를 위한 그림책        | 21                              |
| 여름용 린넨 셔츠            | 18                              |
| 유기농 비누 세트            | 12                              |
| 인체공학 키보드             | 14                              |
| 재활용 쇼핑백               | 16                              |
| 천연 에센셜 오일            | 22                              |
| 친환경 세제                 | 5                               |
| 친환경 주방 세트            | 19                              |
| 캐시미어 스웨터             | 8                               |
| 파이썬 프로그래밍 가이드    | 15                              |
| 프리미엄 게이밍 마우스      | 3                               |
| 휴대용 빔 프로젝터          | 23                              |
- item_name 이 가나다라 순으로 정렬되어 있는 것을 확인할 수 있다.
- 정렬된 순서를 보면 숫자, 영문, 가나다라 순으로 정렬된다.
  - 4K UHD 모니터
  - SQL 마스터 가이드
  - 관계형 데이터베이스 입문
  - ...
- 이렇게 정렬된 상태면 사람도 원하는 데이터를 빨리 찾을 수 있듯이 데이터베이스도 원하는 데이터를 빨리 찾을 수 있다.
  - 정렬된 데이터에서 데이터베이스가 원하는 데이터를 어떻게 빨리 찾을 수 있는지 그 원리는 뒤에서 설명한다.
- 원본 데이터의 위치에는 해당 값을 가진 실제 데이터 행의 위치(예: 주소값, 포인터, PK 값 등)를 저장한다. 이 값을 통해 원본 데이터에 빠르게 접근할 수 있다.
  - 예시에서는 보기 쉽게 편의상 PK 값을 적어두었다. 실제로 저장되는 값은 데이터베이스와 인덱스의 종류에 따라서 다르다.

![](https://github.com/dididiri1/TIL/blob/main/Database/basic/images/08_01.png?raw=true)

item_name 컬럼에 인덱스가 생성된 후, 다시 검색 쿼리를 실행하면 데이터베이스는 완전히 다르게 동작한다.
```sql
SELECT * FROM items WHERE item_name = '게이밍 노트북';
```
1. items 테이블 전체를 순서대로 스캔하는 대신, 먼저 item_name 기반의 인덱스를 찾아간다.
2. 인덱스는 정렬되어 있으므로, '게이밍 노트북'이라는 값을 아주 빠르게 찾아낸다. (원리는 뒤에서 설명)
3. 찾아낸 인덱스 항목에서 실제 데이터 행의 위치를 확인한다.
4. 그 위치를 이용해 원본 테이블의 해당 위치로 점프해서, 단번에 원하는 데이터를 가져온다. (예시에서는 편의상
   PK 값을 적어두었지만 해당 행의 실제 위치 값을 가지고 있다고 생각하면 된다.)

인덱스 덕분에 100만 번의 비교 작업이 단 몇 번의 작업으로 줄어들게 된다. 데이터가 1억 건으로 늘어나도 검색 속도
는 거의 차이가 나지 않을 정도로 비약적인 성능 향상이 일어난다.
이것이 바로 우리가 인덱스를 사용해야 하는 이유다. 인덱스는 느려진 데이터베이스에 날개를 달아주는, 성능 최적화의
가장 기본적이고 핵심적인 기술이다.

실제 인덱스의 구현
이번 강의에서는 특정 데이터베이스 시스템(예: MySQL)에 종속된 복잡한 구현 세부사항은 다루지 않고, 일반적이고
논리적인 인덱스의 개념을 중심으로 설명한다. 참고로 실제 물리적인 인덱스는 그 종류에 따라 구현이 다 다르다.
예를들어 MySQL의 경우 클러스터 인덱스(Clustered Index)와 보조 인덱스(Secondary Index)라는 2가지 종류의
인덱스를 제공한다.
클러스터 인덱스는 기본 키(PK)를 기반으로 만드는 인덱스이다. 클러스터 인덱스는 원본 데이터 자체를 인덱스에 함께
보관해서 원본 데이터를 매우 빠르게 찾을 수 있다.
보조 인덱스는 원본 데이터의 기본 키(PK) 값을 함께 보관한다. 그리고 이 기본 키(PK) 값으로 클러스터 인덱스를 통해
원하는 데이터를 조회한다.
이처럼 인덱스의 종류에 따라 내부 동작 방식은 다양하지만, 핵심적인 목적은 변함없이 데이터 검색 속도를 향상시키고
쿼리 성능을 최적화하는 것이다. 마치 책의 목차나 찾아보기가 특정 내용을 빠르게 찾을 수 있도록 돕는 것처럼, 데이터
베이스 인덱스는 방대한 양의 데이터 속에서 필요한 정보를 효율적으로 찾아낼 수 있도록 돕는 특별한 데이터 구조라고
이해하면 된다.
클러스터 인덱스, 보조 인덱스와 같은 실제 물리적인 인덱스가 어떻게 작동하고, 또 왜 이렇게 나누어 두었는지 궁금할
수 있다.
지금 단계에서는 '특정 컬럼을 정렬해서 저장하고, 이를 통해 원본 데이터에 빠르게 접근할 수 있는 특별한 목차'라는 인
덱스의 큰 그림을 이해하면 충분하다.


## 인덱스 생성, 조회, 삭제
이번 시간에는 CREATE , SHOW , DROP 이라는 간단한 명령어를 통해 인덱스를 직접 다루는 실습을 진행하자.

### CREATE INDEX : 인덱스 생성하기
가장 기본이 되는 인덱스 생성 명령어는 CREATE INDEX 이다. 문법은 다음과 같다.

```
CREATE INDEX 인덱스이름 ON 테이블이름 (컬럼1, 컬럼2, ...);
```
- 인덱스 이름: 생성할 인덱스에 고유한 이름을 붙여준다. 보통 idx_테이블명_컬럼명 과 같은 규칙으로 지으면 관리하기 편하다.
- 테이블 이름: 인덱스를 생성할 대상 테이블.
- 컬럼: 인덱스를 구성할 컬럼. 하나 이상의 컬럼을 지정할 수 있다.

이제 실습을 해보자. 우리는 items 테이블에서 특정 item_name 으로 상품을 검색하는 경우가 많다고 가정하고,
item_name 컬럼에 대한 인덱스를 생성해 보겠다.

```
CREATE INDEX idx_items_item_name ON items (item_name);
```
이 쿼리를 실행하면, 데이터베이스는 items 테이블의 모든 item_name 값을 읽어 정렬한 뒤,
idx_items_item_name 인덱스를 디스크에 생성한다. 테이블의 데이터가 많을수록 이 작업은 시간이 오래 걸릴 수 있다.

### SHOW INDEX : 테이블의 인덱스 정보 확인하기
"테이블에 어떤 인덱스들이 생성되어 있는지 확인하려면 어떻게 해야 할까?"
SHOW INDEX 명령어를 사용하면 테이블에 걸려있는 모든 인덱스의 정보를 한눈에 볼 수 있다.

#### items 인덱스 확인
```
SHOW INDEX FROM items;
```
| Table | Non_unique | Key_name           | Column_name | Cardinality |
|-------|------------|--------------------|-------------|-------------|
| items | 0          | PRIMARY            | item_id     | 25          |
| items | 1          | fk_items_sellers   | seller_id   | 10          |
| items | 1          | idx_items_item_name| item_name   | 25          |

결과를 자세히 살펴보자.
- Key_name: 인덱스의 이름이다. 우리가 방금 만든 idx_items_item_name 이 보인다.
- Column_name: 해당 인덱스가 어떤 컬럼을 기반으로 만들어졌는지 보여준다.
- PRIMARY 와 seller_id : 여기서 흥미로운 점은, 우리는 item_name 컬럼에 대한 인덱스만 만들었는데
  PRIMARY 와 fk_items_sellers 라는 인덱스가 이미 존재한다는 것이다.
  - MySQL에서는 PRIMARY KEY (기본 키)나 FOREIGN KEY (외래 키) 제약조건을 설정하면, 해당 컬럼에
    대해 자동으로 인덱스를 생성한다. item_id 는 기본 키이므로 PRIMARY 인덱스가, seller_id 는 외래 
    키이므로 fk_items_sellers 인덱스가 이미 존재했던 것이다. 매우 중요한 사실이니 꼭 기억해 두자!
    (UNIQUE 제약조건도 마찬가지로 인덱스가 생성된다.)
- Non_unique: 1 이면 중복 값을 허용하는 인덱스, 0 이면 중복을 허용하지 않는 고유 인덱스( UNIQUE 또는
  PRIMARY KEY )라는 의미다. idx_items_item_name 은 1 이므로, 상품명이 같은 다른 상품이 등록될 수 있다는 것을 알 수 있다.
- Cardinality: 인덱스에 저장된 유니크한 값의 개수에 대한 추정치다. 이 값이 높을수록 중복도가 낮다는 의미이며, 인덱스의 성능이 좋다고 판단할 수 있다. (Cardinality는 뒤에서 설명한다.)

#### sellers 인덱스 확인
```
SHOW INDEX FROM sellers;
```

#### [실행 결과]
| Table   | Non_unique | Key_name    | Seq_in_index | Column_name | Cardinality |
|---------|------------|-------------|--------------|-------------|-------------|
| sellers | 0          | PRIMARY     | 1            | seller_id   | 10          |
| sellers | 0          | seller_name | 1            | seller_name | 10          |
- PRIMARY : seller_id 기본 키로 인덱스가 자동 생성되었다.
- seller_name : seller_name 에 UNIQUE 제약조건으로 인덱스가 자동 생성되었다.

#### 유니크 제약조건에 인덱스를 자동 생성하는 이유
유니크 제약조건은 컬럼 내 데이터의 유일성을 보장해야 한다. 따라서 새로운 데이터를 삽입(INSERT)하거나 기존 데
이터를 수정(UPDATE)할 때마다, 입력하려는 값이 테이블에 이미 존재하는지 빠르게 확인해야 한다. 만약 인덱스가 없
다면 이 중복 검사를 위해 매번 풀 테이블 스캔이 발생하여 쓰기 성능이 크게 저하될 것이다.

### DROP INDEX : 인덱스 삭제하기
시간이 지나 더 이상 사용하지 않거나, 오히려 쓰기 성능에 방해가 되는 인덱스는 삭제해야 한다. DROP INDEX 명령
어로 간단하게 삭제할 수 있다.

```
DROP INDEX 인덱스이름 ON 테이블이름;
```
